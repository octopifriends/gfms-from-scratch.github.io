<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Understanding Neural Networks: From Neurons to Transformers</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">GEOG 288KC</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">🏠 home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Syllabus.html"> 
<span class="menu-text">📋 syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-weekly-sessions" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">💻 weekly sessions</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-weekly-sessions">    
        <li>
    <a class="dropdown-item" href="../chapters/c01-geospatial-data-foundations.html">
 <span class="dropdown-text">Week 1 - 🚀 Core Tools and Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c02-spatial-temporal-attention-mechanisms.html">
 <span class="dropdown-text">Week 2 - ⚡ Rapid Remote Sensing Preprocessing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c03a-terratorch-foundations.html">
 <span class="dropdown-text">Week 3a - 🌍 TerraTorch Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c03-complete-gfm-architecture.html">
 <span class="dropdown-text">Week 3b - 🤖 Machine Learning on Remote Sensing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c04-pretraining-implementation.html">
 <span class="dropdown-text">Week 4 - 🏗️ Foundation Models in Practice</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c05-training-loop-optimization.html">
 <span class="dropdown-text">Week 5 - 🔧 Fine-Tuning &amp; Transfer Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c06-model-evaluation-analysis.html">
 <span class="dropdown-text">Week 6 - ⏰ Spatiotemporal Modeling &amp; Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cheatsheets" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">👀 cheatsheets</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-cheatsheets">    
        <li>
    <a class="dropdown-item" href="../cheatsheets.html">
 <span class="dropdown-text">📋 All Cheatsheets</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">⚡ Quick Starts</li>
        <li>
    <a class="dropdown-item" href="../extras/cheatsheets/week01_imports.html">
 <span class="dropdown-text">Week 01: Import Guide</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-explainers" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">🧩 explainers</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-explainers">    
        <li class="dropdown-header">1️⃣ Week 1</li>
        <li>
    <a class="dropdown-item" href="../extras/ai-ml-dl-fm-hierarchy.html">
 <span class="dropdown-text">🤖 AI/ML/DL/FM Hierarchy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/geospatial-foundation-model-predictions-standalone.html">
 <span class="dropdown-text">🎯 GFM Predictions (Standalone)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/geospatial-prediction-hierarchy.html">
 <span class="dropdown-text">✅ Geospatial Task/Prediction Types</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/neural_networks_explainer.html">
 <span class="dropdown-text">🧠 Neural Networks: Neurons to Transformers</span></a>
  </li>  
        <li class="dropdown-header">2️⃣ Week 2</li>
        <li>
    <a class="dropdown-item" href="../chapters/c00a-foundation_model_architectures.html">
 <span class="dropdown-text">🏗️ Foundation Model Architectures</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../chapters/c00b-introduction-to-deeplearning-architecture.html">
 <span class="dropdown-text">🎓 Introduction to Deep Learning Architecture</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-extras" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📖 extras</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-extras">    
        <li class="dropdown-header">🎯 Practical Examples</li>
        <li>
    <a class="dropdown-item" href="../extras/examples/normalization_comparison.html">
 <span class="dropdown-text">Normalization Comparison</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/examples/resnet.html">
 <span class="dropdown-text">ResNet Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/examples/text_encoder.html">
 <span class="dropdown-text">Text Encoder</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/examples/tiling-and-patches.html">
 <span class="dropdown-text">Tiling and Patches</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/examples/terratorch_workflows.html">
 <span class="dropdown-text">TerraTorch Workflows</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/resources/course_resources.html">
 <span class="dropdown-text">📚 Reference Materials</span></a>
  </li>  
        <li class="dropdown-header">📁 Project Templates</li>
        <li>
    <a class="dropdown-item" href="../extras/projects/project-proposal-template.html">
 <span class="dropdown-text">Project Proposal Template</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../extras/projects/mvp-template.html">
 <span class="dropdown-text">Project Results Template</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/gfms-from-scratch/gfms-from-scratch.github.io" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <div class="quarto-title-block"><div><h1 class="title">Understanding Neural Networks: From Neurons to Transformers</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
            <p class="subtitle lead">A Progressive Guide to Deep Learning Architecture</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#part-1-the-individual-neuron" id="toc-part-1-the-individual-neuron" class="nav-link" data-scroll-target="#part-1-the-individual-neuron">Part 1: The Individual Neuron</a>
  <ul class="collapse">
  <li><a href="#what-does-a-neuron-do" id="toc-what-does-a-neuron-do" class="nav-link" data-scroll-target="#what-does-a-neuron-do">What Does a Neuron Do?</a></li>
  <li><a href="#activation-functions-adding-non-linearity" id="toc-activation-functions-adding-non-linearity" class="nav-link" data-scroll-target="#activation-functions-adding-non-linearity">Activation Functions: Adding Non-Linearity</a></li>
  <li><a href="#seeing-the-effect-of-activation-functions" id="toc-seeing-the-effect-of-activation-functions" class="nav-link" data-scroll-target="#seeing-the-effect-of-activation-functions">Seeing the Effect of Activation Functions</a></li>
  </ul></li>
  <li><a href="#part-2-from-single-neurons-to-layers" id="toc-part-2-from-single-neurons-to-layers" class="nav-link" data-scroll-target="#part-2-from-single-neurons-to-layers">Part 2: From Single Neurons to Layers</a>
  <ul class="collapse">
  <li><a href="#the-power-of-vectorization" id="toc-the-power-of-vectorization" class="nav-link" data-scroll-target="#the-power-of-vectorization">The Power of Vectorization</a></li>
  <li><a href="#building-a-multi-layer-network" id="toc-building-a-multi-layer-network" class="nav-link" data-scroll-target="#building-a-multi-layer-network">Building a Multi-Layer Network</a></li>
  <li><a href="#visualizing-the-transformation" id="toc-visualizing-the-transformation" class="nav-link" data-scroll-target="#visualizing-the-transformation">Visualizing the Transformation</a></li>
  </ul></li>
  <li><a href="#part-3-attention-mechanisms-and-transformers" id="toc-part-3-attention-mechanisms-and-transformers" class="nav-link" data-scroll-target="#part-3-attention-mechanisms-and-transformers">Part 3: Attention Mechanisms and Transformers</a>
  <ul class="collapse">
  <li><a href="#the-limitation-of-basic-neural-networks" id="toc-the-limitation-of-basic-neural-networks" class="nav-link" data-scroll-target="#the-limitation-of-basic-neural-networks">The Limitation of Basic Neural Networks</a></li>
  <li><a href="#what-is-attention" id="toc-what-is-attention" class="nav-link" data-scroll-target="#what-is-attention">What is Attention?</a></li>
  <li><a href="#visualizing-attention-patterns" id="toc-visualizing-attention-patterns" class="nav-link" data-scroll-target="#visualizing-attention-patterns">Visualizing Attention Patterns</a></li>
  <li><a href="#multi-head-attention" id="toc-multi-head-attention" class="nav-link" data-scroll-target="#multi-head-attention">Multi-Head Attention</a></li>
  <li><a href="#how-attention-changes-encodings" id="toc-how-attention-changes-encodings" class="nav-link" data-scroll-target="#how-attention-changes-encodings">How Attention Changes Encodings</a></li>
  </ul></li>
  <li><a href="#part-4-putting-it-all-together---the-transformer-block" id="toc-part-4-putting-it-all-together---the-transformer-block" class="nav-link" data-scroll-target="#part-4-putting-it-all-together---the-transformer-block">Part 4: Putting It All Together - The Transformer Block</a></li>
  <li><a href="#summary-the-neural-network-hierarchy" id="toc-summary-the-neural-network-hierarchy" class="nav-link" data-scroll-target="#summary-the-neural-network-hierarchy">Summary: The Neural Network Hierarchy</a>
  <ul class="collapse">
  <li><a href="#level-1-single-neuron" id="toc-level-1-single-neuron" class="nav-link" data-scroll-target="#level-1-single-neuron">Level 1: Single Neuron</a></li>
  <li><a href="#level-2-layer-of-neurons" id="toc-level-2-layer-of-neurons" class="nav-link" data-scroll-target="#level-2-layer-of-neurons">Level 2: Layer of Neurons</a></li>
  <li><a href="#level-3-multi-layer-network" id="toc-level-3-multi-layer-network" class="nav-link" data-scroll-target="#level-3-multi-layer-network">Level 3: Multi-Layer Network</a></li>
  <li><a href="#level-4-attention-transformers" id="toc-level-4-attention-transformers" class="nav-link" data-scroll-target="#level-4-attention-transformers">Level 4: Attention &amp; Transformers</a></li>
  </ul></li>
  <li><a href="#interactive-exploration" id="toc-interactive-exploration" class="nav-link" data-scroll-target="#interactive-exploration">Interactive Exploration</a></li>
  <li><a href="#further-resources" id="toc-further-resources" class="nav-link" data-scroll-target="#further-resources">Further Resources</a>
  <ul class="collapse">
  <li><a href="#video-explanations-3blue1brown" id="toc-video-explanations-3blue1brown" class="nav-link" data-scroll-target="#video-explanations-3blue1brown">Video Explanations (3Blue1Brown)</a></li>
  <li><a href="#key-papers" id="toc-key-papers" class="nav-link" data-scroll-target="#key-papers">Key Papers</a></li>
  <li><a href="#next-steps-in-this-course" id="toc-next-steps-in-this-course" class="nav-link" data-scroll-target="#next-steps-in-this-course">Next Steps in This Course</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This guide builds your understanding of neural networks from the ground up, starting with how individual neurons process data, scaling to vectorized layer operations, and culminating in transformer architectures with attention mechanisms.</p>
<div class="cell" data-fig-width="10" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    start["🎯 Start Here"] --&gt; part1["Part 1&lt;br/&gt;Single Neuron&lt;br/&gt;────&lt;br/&gt;Activation&lt;br/&gt;Functions"]
    part1 --&gt; part2["Part 2&lt;br/&gt;Layers&lt;br/&gt;────&lt;br/&gt;Vectorization&lt;br/&gt;&amp; Depth"]
    part2 --&gt; part3["Part 3&lt;br/&gt;Attention&lt;br/&gt;────&lt;br/&gt;Context-Aware&lt;br/&gt;Processing"]
    part3 --&gt; part4["Part 4&lt;br/&gt;Transformers&lt;br/&gt;────&lt;br/&gt;Complete&lt;br/&gt;Architecture"]
    part4 --&gt; end_goal["🎓 Goal Achieved&lt;br/&gt;────&lt;br/&gt;Understand GPT,&lt;br/&gt;BERT, GFMs"]
    
    style start fill:#e1f5ff
    style part1 fill:#e8f0ff
    style part2 fill:#f0e1ff
    style part3 fill:#ffe8e1
    style part4 fill:#ffe1e1
    style end_goal fill:#e1ffe1
</pre>
</div>
<p></p><figcaption> Learning Roadmap: Our Journey Through Neural Networks</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>What you’ll learn</strong>: - How neurons transform data with activation functions - How vectorization makes processing efficient - Why attention is revolutionary for sequence modeling - How transformers combine these ideas into powerful models</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Video Resources
</div>
</div>
<div class="callout-body-container callout-body">
<p>For excellent visual explanations of neural networks, check out 3Blue1Brown’s Neural Networks series:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=aircAruvnKk">But what is a neural network?</a> - Foundation concepts</li>
<li><a href="https://www.youtube.com/watch?v=IHZwWFHWa-w">Gradient descent, how neural networks learn</a> - Training process</li>
</ul>
</div>
</div>
<hr>
</section>
<section id="part-1-the-individual-neuron" class="level2">
<h2 class="anchored" data-anchor-id="part-1-the-individual-neuron">Part 1: The Individual Neuron</h2>
<section id="what-does-a-neuron-do" class="level3">
<h3 class="anchored" data-anchor-id="what-does-a-neuron-do">What Does a Neuron Do?</h3>
<p>At its core, a neuron is a simple computational unit that:</p>
<ol type="1">
<li>Takes multiple inputs</li>
<li>Combines them with learned weights</li>
<li>Adds a bias term</li>
<li>Passes the result through an activation function</li>
</ol>
<div class="cell" data-fig-width="8" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    subgraph inputs["Inputs"]
        x1["x₁ = 1.5"]
        x2["x₂ = 2.0"]
        x3["x₃ = -0.5"]
    end
    
    subgraph weights["× Weights"]
        w1["w₁ = 0.5"]
        w2["w₂ = -1.0"]
        w3["w₃ = 0.3"]
    end
    
    subgraph computation["Weighted Sum"]
        sum["Σ(xᵢ × wᵢ) + b"]
        bias["+ bias (0.5)"]
    end
    
    subgraph activation["Activation"]
        z["z = -0.35"]
        act["f(z)"]
        output["Output"]
    end
    
    x1 --&gt; w1
    x2 --&gt; w2
    x3 --&gt; w3
    w1 --&gt; sum
    w2 --&gt; sum
    w3 --&gt; sum
    bias --&gt; sum
    sum --&gt; z
    z --&gt; act
    act --&gt; output
    
    style inputs fill:#e1f5ff
    style weights fill:#fff3e1
    style computation fill:#f0e1ff
    style activation fill:#e1ffe1
</pre>
</div>
<p></p><figcaption> Single Neuron Computation Flow</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key insight</strong>: A neuron is just a weighted sum followed by a non-linear function. That’s it!</p>
<p>Let’s see this in action with code:</p>
<div id="b5fcd521" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># A single neuron processes inputs</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> single_neuron(inputs, weights, bias, activation_fn):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Simulate a single neuron's computation.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">        inputs: array of input values</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">        weights: array of weights (same length as inputs)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">        bias: single bias value</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">        activation_fn: function to apply to weighted sum</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">        The neuron's output after activation</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Weighted sum</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.dot(inputs, weights) <span class="op">+</span> bias</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Apply activation function</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> activation_fn(z)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output, z</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Example inputs and parameters</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">2.0</span>, <span class="op">-</span><span class="fl">0.5</span>])</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.3</span>])</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>bias <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Without activation (just linear combination)</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>output_linear, z <span class="op">=</span> single_neuron(inputs, weights, bias, <span class="kw">lambda</span> x: x)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input values: </span><span class="sc">{</span>inputs<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weights: </span><span class="sc">{</span>weights<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Bias: </span><span class="sc">{</span>bias<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Weighted sum (z): </span><span class="sc">{</span>z<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Linear output: </span><span class="sc">{</span>output_linear<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input values: [ 1.5  2.  -0.5]
Weights: [ 0.5 -1.   0.3]
Bias: 0.5

Weighted sum (z): -0.900
Linear output: -0.900</code></pre>
</div>
</div>
<p><strong>What to notice:</strong> The neuron computes a weighted sum of its inputs plus a bias. Without an activation function, this is just a linear transformation—not very powerful for learning complex patterns.</p>
</section>
<section id="activation-functions-adding-non-linearity" class="level3">
<h3 class="anchored" data-anchor-id="activation-functions-adding-non-linearity">Activation Functions: Adding Non-Linearity</h3>
<p>Activation functions introduce <strong>non-linearity</strong>, which is crucial for neural networks to learn complex patterns. Let’s explore the most common ones:</p>
<div id="74258bc4" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define common activation functions</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> relu(x):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""ReLU: Rectified Linear Unit"""</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(<span class="dv">0</span>, x)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigmoid(x):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Sigmoid: Squashes values to (0, 1)"""</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>x))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tanh(x):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Tanh: Squashes values to (-1, 1)"""</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.tanh(x)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leaky_relu(x, alpha<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Leaky ReLU: Like ReLU but allows small negative values"""</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(x <span class="op">&gt;</span> <span class="dv">0</span>, x, alpha <span class="op">*</span> x)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize these functions</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">100</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="co"># ReLU</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(x, relu(x), <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'ReLU: max(0, x)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmoid</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(x, sigmoid(x), <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Sigmoid: 1/(1+e^(-x))'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'r'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Tanh</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(x, tanh(x), <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Tanh: (e^x - e^(-x))/(e^x + e^(-x))'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Leaky ReLU</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(x, leaky_relu(x), <span class="st">'m-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Leaky ReLU: max(0.01x, x)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="neural_networks_explainer_files/figure-html/cell-3-output-1.png" width="1141" height="948" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>What to notice:</strong></p>
<ul>
<li><strong>ReLU</strong> is the most popular: simple, fast, and effective. It “turns off” negative values completely.</li>
<li><strong>Sigmoid</strong> squashes values between 0 and 1, useful for probabilities.</li>
<li><strong>Tanh</strong> centers outputs around 0, often better than sigmoid for hidden layers.</li>
<li><strong>Leaky ReLU</strong> prevents “dead neurons” by allowing small negative values.</li>
</ul>
</section>
<section id="seeing-the-effect-of-activation-functions" class="level3">
<h3 class="anchored" data-anchor-id="seeing-the-effect-of-activation-functions">Seeing the Effect of Activation Functions</h3>
<p>Let’s see how different activation functions transform our neuron’s output:</p>
<div id="2b9ed802" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the same inputs from before</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">2.0</span>, <span class="op">-</span><span class="fl">0.5</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.3</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>bias <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute weighted sum</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> np.dot(inputs, weights) <span class="op">+</span> bias</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weighted sum (z): </span><span class="sc">{</span>z<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply different activations</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>activations <span class="op">=</span> {</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Linear (no activation)'</span>: <span class="kw">lambda</span> x: x,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ReLU'</span>: relu,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Sigmoid'</span>: sigmoid,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Tanh'</span>: tanh,</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Leaky ReLU'</span>: leaky_relu</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, fn <span class="kw">in</span> activations.items():</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> fn(z)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:25s}</span><span class="ss">: </span><span class="sc">{</span>output<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Weighted sum (z): -0.900

Linear (no activation)   : -0.900
ReLU                     : 0.000
Sigmoid                  : 0.289
Tanh                     : -0.716
Leaky ReLU               : -0.009</code></pre>
</div>
</div>
<p><strong>Why this matters:</strong> The activation function dramatically changes the neuron’s output. This non-linear transformation is what allows neural networks to learn complex, non-linear patterns in data.</p>
<hr>
</section>
</section>
<section id="part-2-from-single-neurons-to-layers" class="level2">
<h2 class="anchored" data-anchor-id="part-2-from-single-neurons-to-layers">Part 2: From Single Neurons to Layers</h2>
<section id="the-power-of-vectorization" class="level3">
<h3 class="anchored" data-anchor-id="the-power-of-vectorization">The Power of Vectorization</h3>
<p>Rather than computing neurons one at a time, we can process an entire layer simultaneously using matrix operations. This is both computationally efficient and conceptually elegant.</p>
<div class="cell" data-fig-width="10" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    subgraph single["Single Neuron (Sequential)"]
        direction LR
        i1["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n1["Neuron 1"]
        i2["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n2["Neuron 2"]
        i3["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n3["Neuron 3"]
        n1 --&gt; o1["Output 1"]
        n2 --&gt; o2["Output 2"]
        n3 --&gt; o3["Output 3"]
    end
    
    subgraph vectorized["Vectorized Layer (Parallel)"]
        direction LR
        iv["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; matrix["Weight Matrix&lt;br/&gt;(3 × 5)&lt;br/&gt;+ Bias&lt;br/&gt;+ Activation"]
        matrix --&gt; ov["Output&lt;br/&gt;Vector&lt;br/&gt;(5 dims)"]
    end
    
    single -.-&gt;|"Matrix Operation"| vectorized
    
    style single fill:#ffe1e1
    style vectorized fill:#e1ffe1
    style matrix fill:#fff3e1
</pre>
</div>
<p></p><figcaption> From Single Neuron to Layer of Neurons</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key insight</strong>: Instead of looping through neurons, one matrix multiplication processes all neurons simultaneously!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Video Resource
</div>
</div>
<div class="callout-body-container callout-body">
<p>For understanding how layers work together, see 3Blue1Brown’s <a href="https://www.youtube.com/watch?v=aircAruvnKk&amp;t=420s">Neural network intuitions</a> (timestamp 7:00 onwards).</p>
</div>
</div>
<div id="c2bc2763" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A layer is just multiple neurons working in parallel</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NeuralLayer:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A single layer of neurons with vectorized operations."""</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_inputs, n_neurons):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Initialize a layer.</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">            n_inputs: number of input features</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">            n_neurons: number of neurons in this layer</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Each neuron has n_inputs weights</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shape: (n_inputs, n_neurons)</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> np.random.randn(n_inputs, n_neurons) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Each neuron has one bias</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shape: (n_neurons,)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.biases <span class="op">=</span> np.zeros(n_neurons)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs, activation_fn<span class="op">=</span>relu):</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass through the layer.</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co">            inputs: input array of shape (n_samples, n_inputs)</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co">            activation_fn: activation function to apply</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co">            outputs after activation, shape (n_samples, n_neurons)</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Matrix multiplication: (n_samples, n_inputs) @ (n_inputs, n_neurons)</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Result: (n_samples, n_neurons)</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.dot(inputs, <span class="va">self</span>.weights) <span class="op">+</span> <span class="va">self</span>.biases</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply activation function element-wise</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> activation_fn(z)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a layer with 3 inputs and 5 neurons</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> NeuralLayer(n_inputs<span class="op">=</span><span class="dv">3</span>, n_neurons<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a batch of 4 samples</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>batch_inputs <span class="op">=</span> np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> layer.forward(batch_inputs, activation_fn<span class="op">=</span>relu)</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>batch_inputs<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weight matrix shape: </span><span class="sc">{</span>layer<span class="sc">.</span>weights<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>outputs<span class="sc">.</span>shape<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sample input:"</span>)</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(batch_inputs[<span class="dv">0</span>])</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding output:"</span>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(outputs[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: (4, 3)
Weight matrix shape: (3, 5)
Output shape: (4, 5)

Sample input:
[-0.09917586  1.846637   -1.07008477]

Corresponding output:
[0.         0.14226798 0.04979847 0.         0.07559149]</code></pre>
</div>
</div>
<p><strong>What to notice:</strong></p>
<ul>
<li>The weight matrix has shape <code>(n_inputs, n_neurons)</code> - each column represents one neuron’s weights.</li>
<li>One matrix multiplication processes all neurons and all samples simultaneously.</li>
<li>Output shape is <code>(n_samples, n_neurons)</code> - each sample gets transformed into a vector of neuron activations.</li>
</ul>
</section>
<section id="building-a-multi-layer-network" class="level3">
<h3 class="anchored" data-anchor-id="building-a-multi-layer-network">Building a Multi-Layer Network</h3>
<p>Now let’s stack multiple layers to create a deep neural network:</p>
<div class="cell" data-fig-width="10" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    subgraph input["Input Layer"]
        i1["x₁"]
        i2["x₂"]
        i3["x₃"]
    end
    
    subgraph hidden1["Hidden Layer 1&lt;br/&gt;(8 neurons)"]
        h11["🔵"]
        h12["🔵"]
        h13["🔵"]
        h14["🔵"]
        h15["🔵"]
        h16["🔵"]
        h17["🔵"]
        h18["🔵"]
    end
    
    subgraph hidden2["Hidden Layer 2&lt;br/&gt;(5 neurons)"]
        h21["🟢"]
        h22["🟢"]
        h23["🟢"]
        h24["🟢"]
        h25["🟢"]
    end
    
    subgraph output["Output Layer&lt;br/&gt;(2 neurons)"]
        o1["🔴"]
        o2["🔴"]
    end
    
    i1 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18
    i2 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18
    i3 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18
    
    h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18 --&gt; h21 &amp; h22 &amp; h23 &amp; h24 &amp; h25
    
    h21 &amp; h22 &amp; h23 &amp; h24 &amp; h25 --&gt; o1 &amp; o2
    
    style input fill:#e1f5ff
    style hidden1 fill:#e8e1ff
    style hidden2 fill:#e1ffe8
    style output fill:#ffe1e1
</pre>
</div>
<p></p><figcaption> Multi-Layer Neural Network Architecture</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key insight</strong>: Data flows forward through the network, with each layer creating progressively more abstract representations.</p>
<p>Now let’s implement this:</p>
<div id="ed83bc82" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNeuralNetwork:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A simple feedforward neural network."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, layer_sizes):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">            layer_sizes: list of layer sizes, e.g., [3, 8, 5, 2]</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">                        means 3 inputs, two hidden layers (8 and 5 neurons),</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">                        and 2 output neurons</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.layers <span class="op">=</span> []</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(layer_sizes) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            layer <span class="op">=</span> NeuralLayer(layer_sizes[i], layer_sizes[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.layers.append(layer)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs):</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Forward pass through all layers."""</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        activation <span class="op">=</span> inputs</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Forward pass through network:"</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>activation<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.layers):</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use ReLU for hidden layers, linear for output</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.layers) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>                activation <span class="op">=</span> layer.forward(activation, activation_fn<span class="op">=</span>relu)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>                activation <span class="op">=</span> layer.forward(activation, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"After layer </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>activation<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> activation</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a network: 3 inputs -&gt; 8 hidden -&gt; 5 hidden -&gt; 2 outputs</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> SimpleNeuralNetwork([<span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">5</span>, <span class="dv">2</span>])</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a batch of data</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>batch <span class="op">=</span> np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> network.forward(batch)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Final output:</span><span class="ch">\n</span><span class="sc">{</span>output<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Forward pass through network:
Input shape: (4, 3)
After layer 1: (4, 8)
After layer 2: (4, 5)
After layer 3: (4, 2)

Final output:
[[ 0.00230489  0.00411068]
 [-0.00171528  0.00183165]
 [ 0.01574223  0.01413083]
 [ 0.00275095  0.00187454]]</code></pre>
</div>
</div>
<p><strong>What to notice:</strong> - Each layer transforms the data: <code>(batch, n_in) -&gt; (batch, n_out)</code> - The output of one layer becomes the input to the next - This creates a series of increasingly abstract representations</p>
</section>
<section id="visualizing-the-transformation" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-the-transformation">Visualizing the Transformation</h3>
<p>Let’s see how data is transformed as it flows through the network:</p>
<div id="423ebaef" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a simpler network for visualization</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>viz_network <span class="op">=</span> SimpleNeuralNetwork([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create some structured input data</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">100</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.column_stack([np.cos(theta), np.sin(theta)])</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Track activations at each layer</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>activations <span class="op">=</span> [inputs]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>current <span class="op">=</span> inputs</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(viz_network.layers):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(viz_network.layers) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> layer.forward(current, activation_fn<span class="op">=</span>relu)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> layer.forward(current, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    activations.append(current)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the transformations</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (ax, act) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(axes, activations)):</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Input Space"</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> i <span class="op">==</span> <span class="bu">len</span>(activations) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Output Space"</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="ss">f"Hidden Layer </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot first two dimensions</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    ax.scatter(act[:, <span class="dv">0</span>], act[:, <span class="dv">1</span>], c<span class="op">=</span>theta, cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Dimension 1'</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Dimension 2'</span>)</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="neural_networks_explainer_files/figure-html/cell-7-output-1.png" width="1534" height="372" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>What to notice:</strong> Each layer progressively transforms the data, creating new representations. The network learns to map inputs to outputs through these transformations.</p>
<hr>
</section>
</section>
<section id="part-3-attention-mechanisms-and-transformers" class="level2">
<h2 class="anchored" data-anchor-id="part-3-attention-mechanisms-and-transformers">Part 3: Attention Mechanisms and Transformers</h2>
<section id="the-limitation-of-basic-neural-networks" class="level3">
<h3 class="anchored" data-anchor-id="the-limitation-of-basic-neural-networks">The Limitation of Basic Neural Networks</h3>
<p>Traditional feedforward networks process each input independently. But what if relationships <em>between</em> inputs matter? This is where <strong>attention mechanisms</strong> come in.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Video Resource
</div>
</div>
<div class="callout-body-container callout-body">
<p>For an excellent visual explanation of attention and transformers, watch: - <a href="https://www.youtube.com/watch?v=eMlx5fFNoYc">Attention in transformers, visually explained</a> by 3Blue1Brown - <a href="https://www.youtube.com/watch?v=eMlx5fFNoYc&amp;t=0s">Visualizing Attention, a Transformer’s Heart</a> (full explanation)</p>
</div>
</div>
</section>
<section id="what-is-attention" class="level3">
<h3 class="anchored" data-anchor-id="what-is-attention">What is Attention?</h3>
<p>Attention allows the network to <strong>focus on relevant parts of the input</strong> when processing each element. Think of reading a sentence: to understand “it,” you need to look back and find what “it” refers to.</p>
<div class="cell" data-fig-width="10" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    subgraph input["Input Sequence"]
        t1["Token 1"]
        t2["Token 2"]
        t3["Token 3"]
        t4["Token 4"]
    end
    
    subgraph qkv["Linear Projections"]
        direction LR
        q["Query (Q)&lt;br/&gt;What I'm looking for"]
        k["Key (K)&lt;br/&gt;What I offer"]
        v["Value (V)&lt;br/&gt;What I return"]
    end
    
    subgraph attention["Attention Computation"]
        similarity["Compute Similarity&lt;br/&gt;Q · Kᵀ"]
        weights["Softmax&lt;br/&gt;(Attention Weights)"]
        output["Weighted Sum&lt;br/&gt;Σ(weights × V)"]
    end
    
    subgraph result["Context-Aware Output"]
        o1["Output 1&lt;br/&gt;(informed by all tokens)"]
        o2["Output 2&lt;br/&gt;(informed by all tokens)"]
        o3["Output 3&lt;br/&gt;(informed by all tokens)"]
        o4["Output 4&lt;br/&gt;(informed by all tokens)"]
    end
    
    t1 &amp; t2 &amp; t3 &amp; t4 --&gt; qkv
    qkv --&gt; similarity
    similarity --&gt; weights
    weights --&gt; output
    output --&gt; o1 &amp; o2 &amp; o3 &amp; o4
    
    style input fill:#e1f5ff
    style qkv fill:#fff3e1
    style attention fill:#f0e1ff
    style result fill:#e1ffe1
</pre>
</div>
<p></p><figcaption> Attention Mechanism: Query-Key-Value</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key insight</strong>: Each token can “attend to” (look at) all other tokens, deciding which are most relevant for its own representation.</p>
<div id="4523b46b" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_attention(query, keys, values):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Simplified attention mechanism.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">        query: what we're looking for (n_queries, d_k)</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">        keys: what we're comparing against (n_keys, d_k)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">        values: what we return (n_keys, d_v)</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">        weighted combination of values</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute similarity scores</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># How much does each key match the query?</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> np.dot(query, keys.T)  <span class="co"># (n_queries, n_keys)</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Convert to attention weights (softmax)</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale by sqrt of dimension for stability</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    d_k <span class="op">=</span> keys.shape[<span class="dv">1</span>]</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> scores <span class="op">/</span> np.sqrt(d_k)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    attention_weights <span class="op">=</span> np.exp(scores) <span class="op">/</span> np.exp(scores).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Weighted sum of values</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> np.dot(attention_weights, values)  <span class="co"># (n_queries, d_v)</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output, attention_weights</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: A simple sequence</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's say we have 4 tokens (words), each represented by a 3D vector</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>sequence <span class="op">=</span> np.array([</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.5</span>],  <span class="co"># Token 0</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>],  <span class="co"># Token 1</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">1.0</span>],  <span class="co"># Token 2</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>],  <span class="co"># Token 3</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's see what Token 2 attends to</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> sequence[<span class="dv">2</span>:<span class="dv">3</span>]  <span class="co"># Query is Token 2</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> sequence        <span class="co"># Keys are all tokens</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> sequence      <span class="co"># Values are all tokens (simplified)</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>output, attention_weights <span class="op">=</span> simple_attention(query, keys, values)</span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Attention weights for Token 2:"</span>)</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, weight <span class="kw">in</span> <span class="bu">enumerate</span>(attention_weights[<span class="dv">0</span>]):</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Token </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>weight<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Original Token 2: </span><span class="sc">{</span>sequence[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"After attention:  </span><span class="sc">{</span>output[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Attention weights for Token 2:
  Token 0: 0.238
  Token 1: 0.225
  Token 2: 0.305
  Token 3: 0.231

Original Token 2: [0.2 0.3 1. ]
After attention:  [0.64324521 0.43223908 0.53893462]</code></pre>
</div>
</div>
<p><strong>What to notice:</strong> - The attention weights sum to 1.0 - Token 2 attends most to itself, but also considers other tokens - The output is a weighted combination - it’s been “informed” by the context</p>
</section>
<section id="visualizing-attention-patterns" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-attention-patterns">Visualizing Attention Patterns</h3>
<div id="39a833f6" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute full attention matrix (all tokens attending to all tokens)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>all_queries <span class="op">=</span> sequence</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>all_keys <span class="op">=</span> sequence</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>all_values <span class="op">=</span> sequence</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>outputs, full_attention <span class="op">=</span> simple_attention(all_queries, all_keys, all_values)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the attention matrix</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">5</span>))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention matrix</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>im <span class="op">=</span> ax1.imshow(full_attention, cmap<span class="op">=</span><span class="st">'viridis'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Attention Matrix</span><span class="ch">\n</span><span class="st">(Which tokens attend to which)'</span>, </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>              fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Key Token'</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Query Token'</span>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks(<span class="bu">range</span>(<span class="dv">4</span>))</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>ax1.set_yticks(<span class="bu">range</span>(<span class="dv">4</span>))</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im, ax<span class="op">=</span>ax1, label<span class="op">=</span><span class="st">'Attention Weight'</span>)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Add values to cells</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        text <span class="op">=</span> ax1.text(j, i, <span class="ss">f'</span><span class="sc">{</span>full_attention[i, j]<span class="sc">:.2f}</span><span class="ss">'</span>,</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>                       ha<span class="op">=</span><span class="st">"center"</span>, va<span class="op">=</span><span class="st">"center"</span>, color<span class="op">=</span><span class="st">"white"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Show transformation</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>ax2.bar(<span class="bu">range</span>(<span class="dv">4</span>), sequence[:, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Original (dim 0)'</span>)</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>ax2.bar(<span class="bu">range</span>(<span class="dv">4</span>), outputs[:, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'After attention (dim 0)'</span>)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Token Representations</span><span class="ch">\n</span><span class="st">(First dimension)'</span>, </span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>              fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Token'</span>)</span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Value'</span>)</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="neural_networks_explainer_files/figure-html/cell-9-output-2.png" width="1333" height="469" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>What to notice:</strong> The attention matrix shows which tokens influence each other. Diagonal values are often high (tokens attend to themselves), but off-diagonal values capture contextual relationships.</p>
</section>
<section id="multi-head-attention" class="level3">
<h3 class="anchored" data-anchor-id="multi-head-attention">Multi-Head Attention</h3>
<p>Transformers use <strong>multiple attention heads</strong> to capture different types of relationships simultaneously.</p>
<div class="cell" data-fig-width="10" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    subgraph input_seq["Input Sequence (d_model = 512)"]
        seq["Token 1, Token 2, ..., Token n"]
    end
    
    subgraph linear_proj["Linear Projections"]
        wq["W_Q"]
        wk["W_K"]
        wv["W_V"]
    end
    
    subgraph heads["Split into Multiple Heads (e.g., 8 heads × 64 dims)"]
        direction LR
        head1["Head 1&lt;br/&gt;🔵&lt;br/&gt;Attends to&lt;br/&gt;Syntax"]
        head2["Head 2&lt;br/&gt;🟢&lt;br/&gt;Attends to&lt;br/&gt;Semantics"]
        head3["Head 3&lt;br/&gt;🟡&lt;br/&gt;Attends to&lt;br/&gt;Position"]
        dots["..."]
        head8["Head 8&lt;br/&gt;🔴&lt;br/&gt;Attends to&lt;br/&gt;Context"]
    end
    
    subgraph attention_ops["Parallel Attention Operations"]
        att1["Attention&lt;br/&gt;Computation"]
        att2["Attention&lt;br/&gt;Computation"]
        att3["Attention&lt;br/&gt;Computation"]
        att4["Attention&lt;br/&gt;Computation"]
    end
    
    subgraph concat["Concatenate Heads"]
        combined["Combined Output&lt;br/&gt;(8 heads × 64 = 512 dims)"]
    end
    
    subgraph final["Final Projection"]
        wo["W_O&lt;br/&gt;(512 × 512)"]
        output["Context-Aware&lt;br/&gt;Representations"]
    end
    
    seq --&gt; linear_proj
    linear_proj --&gt; heads
    head1 --&gt; att1
    head2 --&gt; att2
    head3 --&gt; att3
    head8 --&gt; att4
    att1 &amp; att2 &amp; att3 &amp; att4 --&gt; combined
    combined --&gt; wo
    wo --&gt; output
    
    style input_seq fill:#e1f5ff
    style linear_proj fill:#fff3e1
    style heads fill:#f0e1ff
    style attention_ops fill:#ffe1f0
    style concat fill:#e1ffe8
    style final fill:#e1ffe1
</pre>
</div>
<p></p><figcaption> Multi-Head Attention Architecture</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key insight</strong>: Multiple heads can learn different attention patterns - some might focus on nearby words, others on distant relationships, enabling richer representations.</p>
<div id="55699f8f" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MultiHeadAttention:</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Multi-head attention mechanism."""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d_model, n_heads):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">            d_model: dimension of the model (e.g., 512)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">            n_heads: number of attention heads (e.g., 8)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_heads <span class="op">=</span> n_heads</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.d_model <span class="op">=</span> d_model</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.d_k <span class="op">=</span> d_model <span class="op">//</span> n_heads  <span class="co"># dimension per head</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Linear projections for Q, K, V</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_q <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_k <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_v <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_o <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> split_heads(<span class="va">self</span>, x):</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Split the last dimension into (n_heads, d_k)."""</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, d_model <span class="op">=</span> x.shape</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reshape to (batch_size, seq_len, n_heads, d_k)</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.reshape(batch_size, seq_len, <span class="va">self</span>.n_heads, <span class="va">self</span>.d_k)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transpose to (batch_size, n_heads, seq_len, d_k)</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x.transpose(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> attention(<span class="va">self</span>, q, k, v):</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Scaled dot-product attention."""</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        d_k <span class="op">=</span> q.shape[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        scores <span class="op">=</span> np.matmul(q, k.transpose(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)) <span class="op">/</span> np.sqrt(d_k)</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        attention_weights <span class="op">=</span> np.exp(scores) <span class="op">/</span> np.exp(scores).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> np.matmul(attention_weights, v)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attention_weights</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass.</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="co">            x: input tensor of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="co">            output of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, _ <span class="op">=</span> x.shape</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Linear projections</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_q)</span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_k)</span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_v)</span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Split into multiple heads</span></span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> <span class="va">self</span>.split_heads(q.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="va">self</span>.split_heads(k.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="va">self</span>.split_heads(v.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply attention</span></span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>        attended, attention_weights <span class="op">=</span> <span class="va">self</span>.attention(q, k, v)</span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Concatenate heads</span></span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>        attended <span class="op">=</span> attended.transpose(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a>        concatenated <span class="op">=</span> attended.reshape(batch_size, seq_len, <span class="va">self</span>.d_model)</span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Final linear projection</span></span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> np.dot(concatenated, <span class="va">self</span>.W_o)</span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attention_weights</span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a><span class="co"># Create multi-head attention</span></span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a>d_model <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>n_heads <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb15-73"><a href="#cb15-73" aria-hidden="true" tabindex="-1"></a>mha <span class="op">=</span> MultiHeadAttention(d_model, n_heads)</span>
<span id="cb15-74"><a href="#cb15-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-75"><a href="#cb15-75" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a sequence</span></span>
<span id="cb15-76"><a href="#cb15-76" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-77"><a href="#cb15-77" aria-hidden="true" tabindex="-1"></a>seq_len <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb15-78"><a href="#cb15-78" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.randn(batch_size, seq_len, d_model)</span>
<span id="cb15-79"><a href="#cb15-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-80"><a href="#cb15-80" aria-hidden="true" tabindex="-1"></a>output, attention_weights <span class="op">=</span> mha.forward(x)</span>
<span id="cb15-81"><a href="#cb15-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-82"><a href="#cb15-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-83"><a href="#cb15-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-84"><a href="#cb15-84" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Attention weights shape: </span><span class="sc">{</span>attention_weights<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-85"><a href="#cb15-85" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Number of heads: </span><span class="sc">{</span>n_heads<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-86"><a href="#cb15-86" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Each head attends to sequence of length: </span><span class="sc">{</span>seq_len<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: (1, 4, 8)
Output shape: (1, 4, 8)
Attention weights shape: (1, 2, 4, 4)

Number of heads: 2
Each head attends to sequence of length: 4</code></pre>
</div>
</div>
<p><strong>What to notice:</strong></p>
<ul>
<li>Each head learns different attention patterns</li>
<li>Multiple heads capture multiple types of relationships simultaneously</li>
<li>This is much more powerful than single-head attention</li>
</ul>
</section>
<section id="how-attention-changes-encodings" class="level3">
<h3 class="anchored" data-anchor-id="how-attention-changes-encodings">How Attention Changes Encodings</h3>
<p>Let’s see how attention modifies representations compared to a simple feedforward layer:</p>
<div class="cell" data-fig-width="12" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    subgraph comparison["Processing Paradigms"]
        direction LR
        
        subgraph ff["Feedforward Network"]
            direction TB
            ff_input["Token 1 | Token 2 | Token 3 | Token 4"]
            ff_process["↓ Independent Processing ↓"]
            ff_layer["Layer applies SAME transformation&lt;br/&gt;to each position separately"]
            ff_output["Output 1 | Output 2 | Output 3 | Output 4"]
            ff_note["❌ No communication between positions"]
            
            ff_input --&gt; ff_process
            ff_process --&gt; ff_layer
            ff_layer --&gt; ff_output
            ff_output --&gt; ff_note
        end
        
        subgraph attn["Attention Network"]
            direction TB
            attn_input["Token 1 | Token 2 | Token 3 | Token 4"]
            attn_process["↓ Context-Aware Processing ↓"]
            attn_layer["Each position looks at ALL positions&lt;br/&gt;Weighted combination based on relevance"]
            attn_output["Output 1 | Output 2 | Output 3 | Output 4"]
            attn_note["✅ Each output informed by full context"]
            
            attn_input --&gt; attn_process
            attn_process --&gt; attn_layer
            attn_layer --&gt; attn_output
            attn_output --&gt; attn_note
        end
    end
    
    subgraph examples["Real-World Example"]
        direction LR
        sentence["'The animal didn't cross the street because it was too tired'"]
        ff_ex["Feedforward: 'it' processed in isolation&lt;br/&gt;❌ Can't determine if 'it' = animal or street"]
        attn_ex["Attention: 'it' attends to all words&lt;br/&gt;✅ Learns 'it' → 'animal' (via context)"]
        
        sentence --&gt; ff_ex
        sentence --&gt; attn_ex
    end
    
    style ff fill:#ffe1e1
    style attn fill:#e1ffe1
    style ff_note fill:#ffcccc
    style attn_note fill:#ccffcc
    style examples fill:#fff9e1
</pre>
</div>
<p></p><figcaption> Feedforward vs Attention: The Key Difference</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Why this is revolutionary</strong>: Attention allows the network to dynamically route information based on context, rather than applying fixed transformations. This is essential for understanding language, time series, and sequential data where relationships between elements matter.</p>
<div id="4c55f376" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create sample sequence data</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>seq_length <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>d_model <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Input sequence</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>input_seq <span class="op">=</span> np.random.randn(<span class="dv">1</span>, seq_length, d_model)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Option 1: Process with feedforward layer (no attention)</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>ff_layer <span class="op">=</span> NeuralLayer(d_model, d_model)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>ff_output <span class="op">=</span> ff_layer.forward(input_seq.reshape(<span class="op">-</span><span class="dv">1</span>, d_model), activation_fn<span class="op">=</span>relu)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>ff_output <span class="op">=</span> ff_output.reshape(<span class="dv">1</span>, seq_length, d_model)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Option 2: Process with attention</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>mha <span class="op">=</span> MultiHeadAttention(d_model, n_heads<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>attn_output, attn_weights <span class="op">=</span> mha.forward(input_seq)</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the difference</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Input</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> axes[<span class="dv">0</span>].imshow(input_seq[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Input Sequence'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im0, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Feedforward output</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">1</span>].imshow(ff_output[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'After Feedforward Layer</span><span class="ch">\n</span><span class="st">(No attention)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention output</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">2</span>].imshow(attn_output[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'After Multi-Head Attention</span><span class="ch">\n</span><span class="st">(Context-aware)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">2</span>])</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Show how representations relate to each other</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Cosine similarity between position encodings:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Feedforward (independent processing):"</span>)</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>ff_norm <span class="op">=</span> ff_output[<span class="dv">0</span>] <span class="op">/</span> np.linalg.norm(ff_output[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>ff_similarity <span class="op">=</span> np.dot(ff_norm, ff_norm.T)</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average off-diagonal similarity: </span><span class="sc">{</span>(ff_similarity.<span class="bu">sum</span>() <span class="op">-</span> seq_length) <span class="op">/</span> (seq_length <span class="op">*</span> (seq_length <span class="op">-</span> <span class="dv">1</span>))<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Attention (context-aware processing):"</span>)</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>attn_norm <span class="op">=</span> attn_output[<span class="dv">0</span>] <span class="op">/</span> np.linalg.norm(attn_output[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>attn_similarity <span class="op">=</span> np.dot(attn_norm, attn_norm.T)</span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average off-diagonal similarity: </span><span class="sc">{</span>(attn_similarity.<span class="bu">sum</span>() <span class="op">-</span> seq_length) <span class="op">/</span> (seq_length <span class="op">*</span> (seq_length <span class="op">-</span> <span class="dv">1</span>))<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="neural_networks_explainer_files/figure-html/cell-11-output-1.png" width="1509" height="373" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Cosine similarity between position encodings:

Feedforward (independent processing):
Average off-diagonal similarity: 0.421

Attention (context-aware processing):
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel MKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Average off-diagonal similarity: 0.998</code></pre>
</div>
</div>
<p><strong>Why this matters:</strong></p>
<ul>
<li><strong>Feedforward layers</strong> process each position independently - no position “knows” about others</li>
<li><strong>Attention layers</strong> mix information across positions - each position is informed by context</li>
<li>This context-awareness is crucial for sequential data like language, time series, or video</li>
</ul>
<hr>
</section>
</section>
<section id="part-4-putting-it-all-together---the-transformer-block" class="level2">
<h2 class="anchored" data-anchor-id="part-4-putting-it-all-together---the-transformer-block">Part 4: Putting It All Together - The Transformer Block</h2>
<p>A complete transformer block combines attention with feedforward layers:</p>
<div class="cell" data-fig-width="8" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TB
    input["Input&lt;br/&gt;(Sequence of Embeddings)"]
    
    subgraph mha_block["Multi-Head Attention Block"]
        mha["Multi-Head&lt;br/&gt;Attention"]
        add1["Add"]
        norm1["Layer Norm"]
    end
    
    subgraph ff_block["Feedforward Block"]
        ff1["Linear&lt;br/&gt;(expand)"]
        relu["ReLU"]
        ff2["Linear&lt;br/&gt;(project)"]
        add2["Add"]
        norm2["Layer Norm"]
    end
    
    output["Output&lt;br/&gt;(Enriched Representations)"]
    
    input --&gt; mha
    input -.-&gt;|"Residual&lt;br/&gt;Connection"| add1
    mha --&gt; add1
    add1 --&gt; norm1
    
    norm1 --&gt; ff1
    ff1 --&gt; relu
    relu --&gt; ff2
    norm1 -.-&gt;|"Residual&lt;br/&gt;Connection"| add2
    ff2 --&gt; add2
    add2 --&gt; norm2
    
    norm2 --&gt; output
    
    style input fill:#e1f5ff
    style mha_block fill:#f0e1ff
    style ff_block fill:#ffe8e1
    style output fill:#e1ffe1
    style mha fill:#d8b3ff
    style add1 fill:#ffd8b3
    style add2 fill:#ffd8b3
</pre>
</div>
<p></p><figcaption> Complete Transformer Block Architecture</figcaption> </figure><p></p>
</div>
</div>
</div>
<p><strong>Key components</strong>:</p>
<ol type="1">
<li><strong>Multi-Head Attention</strong>: Mix information across positions (context)</li>
<li><strong>Residual Connection</strong>: Add input back to help gradient flow</li>
<li><strong>Layer Normalization</strong>: Stabilize training</li>
<li><strong>Feedforward Network</strong>: Transform features independently</li>
<li><strong>Another Residual Connection</strong>: More gradient flow</li>
</ol>
<p>This pattern repeats for each transformer layer in a model!</p>
<div id="70aa23ea" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TransformerBlock:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A single transformer block with attention and feedforward."""</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d_model, n_heads, d_ff):</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">            d_model: model dimension</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">            n_heads: number of attention heads</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">            d_ff: feedforward network dimension</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.attention <span class="op">=</span> MultiHeadAttention(d_model, n_heads)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff1 <span class="op">=</span> NeuralLayer(d_model, d_ff)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff2 <span class="op">=</span> NeuralLayer(d_ff, d_model)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass through transformer block.</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="co">            x: input of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="co">            output of same shape as input</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, d_model <span class="op">=</span> x.shape</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Multi-head attention</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>        attn_out, attn_weights <span class="op">=</span> <span class="va">self</span>.attention.forward(x)</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Add &amp; Norm (simplified - just add)</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> attn_out</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 3: Feedforward network</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reshape for layer processing</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        x_flat <span class="op">=</span> x.reshape(<span class="op">-</span><span class="dv">1</span>, d_model)</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> <span class="va">self</span>.ff1.forward(x_flat, activation_fn<span class="op">=</span>relu)</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> <span class="va">self</span>.ff2.forward(ff_out, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> ff_out.reshape(batch_size, seq_len, d_model)</span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 4: Add &amp; Norm (simplified - just add)</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> x <span class="op">+</span> ff_out</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attn_weights</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and test a transformer block</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>transformer <span class="op">=</span> TransformerBlock(d_model<span class="op">=</span><span class="dv">8</span>, n_heads<span class="op">=</span><span class="dv">2</span>, d_ff<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a sequence</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>input_seq <span class="op">=</span> np.random.randn(<span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">8</span>)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>output, attention <span class="op">=</span> transformer.forward(input_seq)</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>input_seq<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Transformer block completed:"</span>)</span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  1. Multi-head attention (context mixing)"</span>)</span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  2. Residual connection"</span>)</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  3. Feedforward network (feature transformation)"</span>)</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  4. Residual connection"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Input shape: (1, 6, 8)
Output shape: (1, 6, 8)

Transformer block completed:
  1. Multi-head attention (context mixing)
  2. Residual connection
  3. Feedforward network (feature transformation)
  4. Residual connection</code></pre>
</div>
</div>
<p><strong>What to notice:</strong> The transformer combines two key ideas:</p>
<ol type="1">
<li><strong>Attention</strong>: Mix information across sequence positions (capture context)</li>
<li><strong>Feedforward</strong>: Transform features independently at each position (extract patterns)</li>
<li><strong>Residual connections</strong>: Add the input back to help gradients flow</li>
</ol>
<hr>
</section>
<section id="summary-the-neural-network-hierarchy" class="level2">
<h2 class="anchored" data-anchor-id="summary-the-neural-network-hierarchy">Summary: The Neural Network Hierarchy</h2>
<p>Let’s recap the progressive complexity:</p>
<div class="cell" data-fig-width="12" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph level1["Level 1: Single Neuron"]
        n1["Weighted Sum&lt;br/&gt;+ Activation&lt;br/&gt;────&lt;br/&gt;z = Σ(wᵢxᵢ) + b&lt;br/&gt;output = f(z)"]
    end
    
    subgraph level2["Level 2: Neural Layer"]
        layer["Vectorized Operations&lt;br/&gt;────&lt;br/&gt;Multiple neurons in parallel&lt;br/&gt;Matrix: (n_in, n_out)"]
    end
    
    subgraph level3["Level 3: Deep Network"]
        deep["Stacked Layers&lt;br/&gt;────&lt;br/&gt;Input → Hidden₁ → Hidden₂ → Output&lt;br/&gt;Hierarchical features"]
    end
    
    subgraph level4a["Level 4a: Attention Mechanism"]
        attention["Query-Key-Value&lt;br/&gt;────&lt;br/&gt;Context-aware weighting&lt;br/&gt;Tokens attend to each other"]
    end
    
    subgraph level4b["Level 4b: Multi-Head Attention"]
        multihead["Parallel Attention Heads&lt;br/&gt;────&lt;br/&gt;Multiple relationship types&lt;br/&gt;8 heads × 64 dims = 512 dims"]
    end
    
    subgraph level5["Level 5: Transformer Block"]
        transformer["Complete Architecture&lt;br/&gt;────&lt;br/&gt;Multi-Head Attention&lt;br/&gt;+ Residual Connection&lt;br/&gt;+ Feedforward Network&lt;br/&gt;+ Residual Connection"]
    end
    
    subgraph level6["Level 6: Full Transformer"]
        full["Stack of N Blocks&lt;br/&gt;────&lt;br/&gt;Block₁ → Block₂ → ... → Blockₙ&lt;br/&gt;+ Positional Encoding&lt;br/&gt;+ Output Head"]
    end
    
    level1 -.-&gt;|"Parallelize"| level2
    level2 -.-&gt;|"Stack"| level3
    level3 -.-&gt;|"Add Context&lt;br/&gt;Awareness"| level4a
    level4a -.-&gt;|"Multiple&lt;br/&gt;Heads"| level4b
    level4b -.-&gt;|"+ Feedforward&lt;br/&gt;+ Residuals"| level5
    level5 -.-&gt;|"Stack&lt;br/&gt;Layers"| level6
    
    capability1["Independent&lt;br/&gt;Processing"] -.-&gt; level1
    capability2["Batch&lt;br/&gt;Processing"] -.-&gt; level2
    capability3["Hierarchical&lt;br/&gt;Features"] -.-&gt; level3
    capability4["Sequential&lt;br/&gt;Dependencies"] -.-&gt; level4a
    capability5["Rich&lt;br/&gt;Relationships"] -.-&gt; level4b
    capability6["Stable Deep&lt;br/&gt;Learning"] -.-&gt; level5
    capability7["Complex&lt;br/&gt;Understanding"] -.-&gt; level6
    
    style level1 fill:#e1f5ff
    style level2 fill:#e8f0ff
    style level3 fill:#e8e5ff
    style level4a fill:#f0e1ff
    style level4b fill:#f8e1ff
    style level5 fill:#ffe1f0
    style level6 fill:#ffe1e1
    
    style capability1 fill:#fff9e1
    style capability2 fill:#fff9e1
    style capability3 fill:#fff9e1
    style capability4 fill:#fff9e1
    style capability5 fill:#fff9e1
    style capability6 fill:#fff9e1
    style capability7 fill:#fff9e1
</pre>
</div>
<p></p><figcaption> The Complete Neural Network Hierarchy: From Neurons to Transformers</figcaption> </figure><p></p>
</div>
</div>
</div>
<section id="level-1-single-neuron" class="level3">
<h3 class="anchored" data-anchor-id="level-1-single-neuron">Level 1: Single Neuron</h3>
<ul>
<li>Computes weighted sum of inputs</li>
<li>Applies activation function (e.g., ReLU)</li>
<li>Transforms: scalar inputs → scalar output</li>
<li><strong>Key insight</strong>: Non-linearity enables learning complex patterns</li>
</ul>
</section>
<section id="level-2-layer-of-neurons" class="level3">
<h3 class="anchored" data-anchor-id="level-2-layer-of-neurons">Level 2: Layer of Neurons</h3>
<ul>
<li>Multiple neurons computed in parallel (vectorized)</li>
<li>Matrix multiplication: efficient batch processing</li>
<li>Transforms: vector input → vector output</li>
<li><strong>Key insight</strong>: Multiple features extracted simultaneously</li>
</ul>
</section>
<section id="level-3-multi-layer-network" class="level3">
<h3 class="anchored" data-anchor-id="level-3-multi-layer-network">Level 3: Multi-Layer Network</h3>
<ul>
<li>Stack layers to create deep representations</li>
<li>Each layer builds on previous abstractions</li>
<li>Transforms: input space → hidden spaces → output space</li>
<li><strong>Key insight</strong>: Depth creates hierarchical features</li>
</ul>
</section>
<section id="level-4-attention-transformers" class="level3">
<h3 class="anchored" data-anchor-id="level-4-attention-transformers">Level 4: Attention &amp; Transformers</h3>
<ul>
<li>Attention: dynamically weight inputs based on context</li>
<li>Multi-head: capture multiple relationship types</li>
<li>Transformer: attention + feedforward with residual connections</li>
<li><strong>Key insight</strong>: Context-aware processing for sequential data</li>
</ul>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Key Difference
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Traditional Neural Networks</strong>: Process each input independently</p>
<ul>
<li>Good for: images, tabular data where position doesn’t matter</li>
</ul>
<p><strong>Transformers with Attention</strong>: Process inputs in context of each other</p>
<ul>
<li>Good for: language, time series, any sequential data</li>
<li>Revolution: Enables models like GPT, BERT, and modern GFMs</li>
</ul>
</div>
</div>
<hr>
</section>
</section>
<section id="interactive-exploration" class="level2">
<h2 class="anchored" data-anchor-id="interactive-exploration">Interactive Exploration</h2>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Try This Yourself
</div>
</div>
<div class="callout-body-container callout-body">
<p>Experiment with the code above:</p>
<ol type="1">
<li><strong>Activation functions</strong>: Change the activation in <code>single_neuron()</code> and observe output changes</li>
<li><strong>Layer sizes</strong>: Modify <code>layer_sizes</code> in <code>SimpleNeuralNetwork</code> - what happens with very wide or very deep networks?</li>
<li><strong>Attention heads</strong>: Increase <code>n_heads</code> in <code>MultiHeadAttention</code> - do patterns change?</li>
<li><strong>Sequence length</strong>: Use longer sequences in attention examples - observe attention patterns</li>
</ol>
<p>These experiments will deepen your intuition about how neural networks transform data.</p>
</div>
</div>
<hr>
</section>
<section id="further-resources" class="level2">
<h2 class="anchored" data-anchor-id="further-resources">Further Resources</h2>
<section id="video-explanations-3blue1brown" class="level3">
<h3 class="anchored" data-anchor-id="video-explanations-3blue1brown">Video Explanations (3Blue1Brown)</h3>
<ol type="1">
<li><a href="https://www.youtube.com/watch?v=aircAruvnKk">Neural Networks</a> - Core concepts</li>
<li><a href="https://www.youtube.com/watch?v=IHZwWFHWa-w">Gradient Descent</a> - How networks learn</li>
<li><a href="https://www.youtube.com/watch?v=Ilg3gGewQ5U">Backpropagation</a> - How gradients flow</li>
<li><a href="https://www.youtube.com/watch?v=eMlx5fFNoYc">Attention &amp; Transformers</a> - Modern architecture</li>
</ol>
</section>
<section id="key-papers" class="level3">
<h3 class="anchored" data-anchor-id="key-papers">Key Papers</h3>
<ul>
<li>“Attention Is All You Need” (Vaswani et al., 2017) - The original transformer paper</li>
<li>“Deep Residual Learning” (He et al., 2015) - Residual connections</li>
<li>“Understanding Deep Learning Requires Rethinking Generalization” (Zhang et al., 2017)</li>
</ul>
</section>
<section id="next-steps-in-this-course" class="level3">
<h3 class="anchored" data-anchor-id="next-steps-in-this-course">Next Steps in This Course</h3>
<ul>
<li><strong>Week 2</strong>: Spatial-temporal attention for geospatial data</li>
<li><strong>Week 3</strong>: Vision Transformers adapted for satellite imagery</li>
<li><strong>Week 4</strong>: Pretraining strategies (masked autoencoders)</li>
</ul>
<hr>
<p><em>This explainer is designed to build progressive understanding. Each section assumes you’ve understood the previous ones. Take time to run the code, observe the outputs, and experiment!</em></p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kcaylor\.github\.io\/GEOG-288KC-geospatial-foundation-models");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb21" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Understanding Neural Networks: From Neurons to Transformers"</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "A Progressive Guide to Deep Learning Architecture"</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: false</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 3</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>This guide builds your understanding of neural networks from the ground up, starting with how individual neurons process data, scaling to vectorized layer operations, and culminating in transformer architectures with attention mechanisms.</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 10</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Learning Roadmap: Our Journey Through Neural Networks"</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart LR</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="in">    start["🎯 Start Here"] --&gt; part1["Part 1&lt;br/&gt;Single Neuron&lt;br/&gt;────&lt;br/&gt;Activation&lt;br/&gt;Functions"]</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="in">    part1 --&gt; part2["Part 2&lt;br/&gt;Layers&lt;br/&gt;────&lt;br/&gt;Vectorization&lt;br/&gt;&amp; Depth"]</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="in">    part2 --&gt; part3["Part 3&lt;br/&gt;Attention&lt;br/&gt;────&lt;br/&gt;Context-Aware&lt;br/&gt;Processing"]</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="in">    part3 --&gt; part4["Part 4&lt;br/&gt;Transformers&lt;br/&gt;────&lt;br/&gt;Complete&lt;br/&gt;Architecture"]</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="in">    part4 --&gt; end_goal["🎓 Goal Achieved&lt;br/&gt;────&lt;br/&gt;Understand GPT,&lt;br/&gt;BERT, GFMs"]</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="in">    style start fill:#e1f5ff</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="in">    style part1 fill:#e8f0ff</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="in">    style part2 fill:#f0e1ff</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="in">    style part3 fill:#ffe8e1</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a><span class="in">    style part4 fill:#ffe1e1</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a><span class="in">    style end_goal fill:#e1ffe1</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>**What you'll learn**:</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How neurons transform data with activation functions</span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How vectorization makes processing efficient</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Why attention is revolutionary for sequence modeling</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How transformers combine these ideas into powerful models</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a><span class="fu">## Video Resources</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>For excellent visual explanations of neural networks, check out 3Blue1Brown's Neural Networks series:</span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">But what is a neural network?</span><span class="co">](https://www.youtube.com/watch?v=aircAruvnKk)</span> - Foundation concepts</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Gradient descent, how neural networks learn</span><span class="co">](https://www.youtube.com/watch?v=IHZwWFHWa-w)</span> - Training process</span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1: The Individual Neuron</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a><span class="fu">### What Does a Neuron Do?</span></span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>At its core, a neuron is a simple computational unit that:</span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Takes multiple inputs</span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Combines them with learned weights</span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Adds a bias term</span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Passes the result through an activation function</span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 8</span></span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Single Neuron Computation Flow"</span></span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart LR</span></span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph inputs["Inputs"]</span></span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a><span class="in">        x1["x₁ = 1.5"]</span></span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a><span class="in">        x2["x₂ = 2.0"]</span></span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a><span class="in">        x3["x₃ = -0.5"]</span></span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph weights["× Weights"]</span></span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a><span class="in">        w1["w₁ = 0.5"]</span></span>
<span id="cb21-77"><a href="#cb21-77" aria-hidden="true" tabindex="-1"></a><span class="in">        w2["w₂ = -1.0"]</span></span>
<span id="cb21-78"><a href="#cb21-78" aria-hidden="true" tabindex="-1"></a><span class="in">        w3["w₃ = 0.3"]</span></span>
<span id="cb21-79"><a href="#cb21-79" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-80"><a href="#cb21-80" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-81"><a href="#cb21-81" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph computation["Weighted Sum"]</span></span>
<span id="cb21-82"><a href="#cb21-82" aria-hidden="true" tabindex="-1"></a><span class="in">        sum["Σ(xᵢ × wᵢ) + b"]</span></span>
<span id="cb21-83"><a href="#cb21-83" aria-hidden="true" tabindex="-1"></a><span class="in">        bias["+ bias (0.5)"]</span></span>
<span id="cb21-84"><a href="#cb21-84" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-85"><a href="#cb21-85" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-86"><a href="#cb21-86" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph activation["Activation"]</span></span>
<span id="cb21-87"><a href="#cb21-87" aria-hidden="true" tabindex="-1"></a><span class="in">        z["z = -0.35"]</span></span>
<span id="cb21-88"><a href="#cb21-88" aria-hidden="true" tabindex="-1"></a><span class="in">        act["f(z)"]</span></span>
<span id="cb21-89"><a href="#cb21-89" aria-hidden="true" tabindex="-1"></a><span class="in">        output["Output"]</span></span>
<span id="cb21-90"><a href="#cb21-90" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-91"><a href="#cb21-91" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-92"><a href="#cb21-92" aria-hidden="true" tabindex="-1"></a><span class="in">    x1 --&gt; w1</span></span>
<span id="cb21-93"><a href="#cb21-93" aria-hidden="true" tabindex="-1"></a><span class="in">    x2 --&gt; w2</span></span>
<span id="cb21-94"><a href="#cb21-94" aria-hidden="true" tabindex="-1"></a><span class="in">    x3 --&gt; w3</span></span>
<span id="cb21-95"><a href="#cb21-95" aria-hidden="true" tabindex="-1"></a><span class="in">    w1 --&gt; sum</span></span>
<span id="cb21-96"><a href="#cb21-96" aria-hidden="true" tabindex="-1"></a><span class="in">    w2 --&gt; sum</span></span>
<span id="cb21-97"><a href="#cb21-97" aria-hidden="true" tabindex="-1"></a><span class="in">    w3 --&gt; sum</span></span>
<span id="cb21-98"><a href="#cb21-98" aria-hidden="true" tabindex="-1"></a><span class="in">    bias --&gt; sum</span></span>
<span id="cb21-99"><a href="#cb21-99" aria-hidden="true" tabindex="-1"></a><span class="in">    sum --&gt; z</span></span>
<span id="cb21-100"><a href="#cb21-100" aria-hidden="true" tabindex="-1"></a><span class="in">    z --&gt; act</span></span>
<span id="cb21-101"><a href="#cb21-101" aria-hidden="true" tabindex="-1"></a><span class="in">    act --&gt; output</span></span>
<span id="cb21-102"><a href="#cb21-102" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-103"><a href="#cb21-103" aria-hidden="true" tabindex="-1"></a><span class="in">    style inputs fill:#e1f5ff</span></span>
<span id="cb21-104"><a href="#cb21-104" aria-hidden="true" tabindex="-1"></a><span class="in">    style weights fill:#fff3e1</span></span>
<span id="cb21-105"><a href="#cb21-105" aria-hidden="true" tabindex="-1"></a><span class="in">    style computation fill:#f0e1ff</span></span>
<span id="cb21-106"><a href="#cb21-106" aria-hidden="true" tabindex="-1"></a><span class="in">    style activation fill:#e1ffe1</span></span>
<span id="cb21-107"><a href="#cb21-107" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-108"><a href="#cb21-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-109"><a href="#cb21-109" aria-hidden="true" tabindex="-1"></a>**Key insight**: A neuron is just a weighted sum followed by a non-linear function. That's it!</span>
<span id="cb21-110"><a href="#cb21-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-111"><a href="#cb21-111" aria-hidden="true" tabindex="-1"></a>Let's see this in action with code:</span>
<span id="cb21-112"><a href="#cb21-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-115"><a href="#cb21-115" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-116"><a href="#cb21-116" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb21-117"><a href="#cb21-117" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-118"><a href="#cb21-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-119"><a href="#cb21-119" aria-hidden="true" tabindex="-1"></a><span class="co"># A single neuron processes inputs</span></span>
<span id="cb21-120"><a href="#cb21-120" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> single_neuron(inputs, weights, bias, activation_fn):</span>
<span id="cb21-121"><a href="#cb21-121" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-122"><a href="#cb21-122" aria-hidden="true" tabindex="-1"></a><span class="co">    Simulate a single neuron's computation.</span></span>
<span id="cb21-123"><a href="#cb21-123" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb21-124"><a href="#cb21-124" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb21-125"><a href="#cb21-125" aria-hidden="true" tabindex="-1"></a><span class="co">        inputs: array of input values</span></span>
<span id="cb21-126"><a href="#cb21-126" aria-hidden="true" tabindex="-1"></a><span class="co">        weights: array of weights (same length as inputs)</span></span>
<span id="cb21-127"><a href="#cb21-127" aria-hidden="true" tabindex="-1"></a><span class="co">        bias: single bias value</span></span>
<span id="cb21-128"><a href="#cb21-128" aria-hidden="true" tabindex="-1"></a><span class="co">        activation_fn: function to apply to weighted sum</span></span>
<span id="cb21-129"><a href="#cb21-129" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb21-130"><a href="#cb21-130" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb21-131"><a href="#cb21-131" aria-hidden="true" tabindex="-1"></a><span class="co">        The neuron's output after activation</span></span>
<span id="cb21-132"><a href="#cb21-132" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-133"><a href="#cb21-133" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Weighted sum</span></span>
<span id="cb21-134"><a href="#cb21-134" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.dot(inputs, weights) <span class="op">+</span> bias</span>
<span id="cb21-135"><a href="#cb21-135" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-136"><a href="#cb21-136" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Apply activation function</span></span>
<span id="cb21-137"><a href="#cb21-137" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> activation_fn(z)</span>
<span id="cb21-138"><a href="#cb21-138" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-139"><a href="#cb21-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output, z</span>
<span id="cb21-140"><a href="#cb21-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-141"><a href="#cb21-141" aria-hidden="true" tabindex="-1"></a><span class="co"># Example inputs and parameters</span></span>
<span id="cb21-142"><a href="#cb21-142" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">2.0</span>, <span class="op">-</span><span class="fl">0.5</span>])</span>
<span id="cb21-143"><a href="#cb21-143" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.3</span>])</span>
<span id="cb21-144"><a href="#cb21-144" aria-hidden="true" tabindex="-1"></a>bias <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb21-145"><a href="#cb21-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-146"><a href="#cb21-146" aria-hidden="true" tabindex="-1"></a><span class="co"># Without activation (just linear combination)</span></span>
<span id="cb21-147"><a href="#cb21-147" aria-hidden="true" tabindex="-1"></a>output_linear, z <span class="op">=</span> single_neuron(inputs, weights, bias, <span class="kw">lambda</span> x: x)</span>
<span id="cb21-148"><a href="#cb21-148" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input values: </span><span class="sc">{</span>inputs<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-149"><a href="#cb21-149" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weights: </span><span class="sc">{</span>weights<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-150"><a href="#cb21-150" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Bias: </span><span class="sc">{</span>bias<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-151"><a href="#cb21-151" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Weighted sum (z): </span><span class="sc">{</span>z<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-152"><a href="#cb21-152" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Linear output: </span><span class="sc">{</span>output_linear<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-153"><a href="#cb21-153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-154"><a href="#cb21-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-155"><a href="#cb21-155" aria-hidden="true" tabindex="-1"></a>**What to notice:** The neuron computes a weighted sum of its inputs plus a bias. Without an activation function, this is just a linear transformation—not very powerful for learning complex patterns.</span>
<span id="cb21-156"><a href="#cb21-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-157"><a href="#cb21-157" aria-hidden="true" tabindex="-1"></a><span class="fu">### Activation Functions: Adding Non-Linearity</span></span>
<span id="cb21-158"><a href="#cb21-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-159"><a href="#cb21-159" aria-hidden="true" tabindex="-1"></a>Activation functions introduce **non-linearity**, which is crucial for neural networks to learn complex patterns. Let's explore the most common ones:</span>
<span id="cb21-160"><a href="#cb21-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-163"><a href="#cb21-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-164"><a href="#cb21-164" aria-hidden="true" tabindex="-1"></a><span class="co"># Define common activation functions</span></span>
<span id="cb21-165"><a href="#cb21-165" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> relu(x):</span>
<span id="cb21-166"><a href="#cb21-166" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""ReLU: Rectified Linear Unit"""</span></span>
<span id="cb21-167"><a href="#cb21-167" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.maximum(<span class="dv">0</span>, x)</span>
<span id="cb21-168"><a href="#cb21-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-169"><a href="#cb21-169" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigmoid(x):</span>
<span id="cb21-170"><a href="#cb21-170" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Sigmoid: Squashes values to (0, 1)"""</span></span>
<span id="cb21-171"><a href="#cb21-171" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>x))</span>
<span id="cb21-172"><a href="#cb21-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-173"><a href="#cb21-173" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tanh(x):</span>
<span id="cb21-174"><a href="#cb21-174" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Tanh: Squashes values to (-1, 1)"""</span></span>
<span id="cb21-175"><a href="#cb21-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.tanh(x)</span>
<span id="cb21-176"><a href="#cb21-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-177"><a href="#cb21-177" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> leaky_relu(x, alpha<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb21-178"><a href="#cb21-178" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Leaky ReLU: Like ReLU but allows small negative values"""</span></span>
<span id="cb21-179"><a href="#cb21-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.where(x <span class="op">&gt;</span> <span class="dv">0</span>, x, alpha <span class="op">*</span> x)</span>
<span id="cb21-180"><a href="#cb21-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-181"><a href="#cb21-181" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize these functions</span></span>
<span id="cb21-182"><a href="#cb21-182" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">100</span>)</span>
<span id="cb21-183"><a href="#cb21-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-184"><a href="#cb21-184" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>))</span>
<span id="cb21-185"><a href="#cb21-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-186"><a href="#cb21-186" aria-hidden="true" tabindex="-1"></a><span class="co"># ReLU</span></span>
<span id="cb21-187"><a href="#cb21-187" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].plot(x, relu(x), <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-188"><a href="#cb21-188" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-189"><a href="#cb21-189" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_title(<span class="st">'ReLU: max(0, x)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-190"><a href="#cb21-190" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb21-191"><a href="#cb21-191" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb21-192"><a href="#cb21-192" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-193"><a href="#cb21-193" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">0</span>].axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-194"><a href="#cb21-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-195"><a href="#cb21-195" aria-hidden="true" tabindex="-1"></a><span class="co"># Sigmoid</span></span>
<span id="cb21-196"><a href="#cb21-196" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].plot(x, sigmoid(x), <span class="st">'g-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-197"><a href="#cb21-197" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-198"><a href="#cb21-198" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_title(<span class="st">'Sigmoid: 1/(1+e^(-x))'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-199"><a href="#cb21-199" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb21-200"><a href="#cb21-200" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb21-201"><a href="#cb21-201" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'r'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-202"><a href="#cb21-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-203"><a href="#cb21-203" aria-hidden="true" tabindex="-1"></a><span class="co"># Tanh</span></span>
<span id="cb21-204"><a href="#cb21-204" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].plot(x, tanh(x), <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-205"><a href="#cb21-205" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-206"><a href="#cb21-206" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_title(<span class="st">'Tanh: (e^x - e^(-x))/(e^x + e^(-x))'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-207"><a href="#cb21-207" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb21-208"><a href="#cb21-208" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb21-209"><a href="#cb21-209" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">0</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-210"><a href="#cb21-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-211"><a href="#cb21-211" aria-hidden="true" tabindex="-1"></a><span class="co"># Leaky ReLU</span></span>
<span id="cb21-212"><a href="#cb21-212" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].plot(x, leaky_relu(x), <span class="st">'m-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-213"><a href="#cb21-213" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-214"><a href="#cb21-214" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_title(<span class="st">'Leaky ReLU: max(0.01x, x)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-215"><a href="#cb21-215" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_xlabel(<span class="st">'Input (x)'</span>)</span>
<span id="cb21-216"><a href="#cb21-216" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].set_ylabel(<span class="st">'Output'</span>)</span>
<span id="cb21-217"><a href="#cb21-217" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-218"><a href="#cb21-218" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>, <span class="dv">1</span>].axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'k'</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb21-219"><a href="#cb21-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-220"><a href="#cb21-220" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb21-221"><a href="#cb21-221" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb21-222"><a href="#cb21-222" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-223"><a href="#cb21-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-224"><a href="#cb21-224" aria-hidden="true" tabindex="-1"></a>**What to notice:** </span>
<span id="cb21-225"><a href="#cb21-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-226"><a href="#cb21-226" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**ReLU** is the most popular: simple, fast, and effective. It "turns off" negative values completely.</span>
<span id="cb21-227"><a href="#cb21-227" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Sigmoid** squashes values between 0 and 1, useful for probabilities.</span>
<span id="cb21-228"><a href="#cb21-228" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Tanh** centers outputs around 0, often better than sigmoid for hidden layers.</span>
<span id="cb21-229"><a href="#cb21-229" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Leaky ReLU** prevents "dead neurons" by allowing small negative values.</span>
<span id="cb21-230"><a href="#cb21-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-231"><a href="#cb21-231" aria-hidden="true" tabindex="-1"></a><span class="fu">### Seeing the Effect of Activation Functions</span></span>
<span id="cb21-232"><a href="#cb21-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-233"><a href="#cb21-233" aria-hidden="true" tabindex="-1"></a>Let's see how different activation functions transform our neuron's output:</span>
<span id="cb21-234"><a href="#cb21-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-237"><a href="#cb21-237" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-238"><a href="#cb21-238" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the same inputs from before</span></span>
<span id="cb21-239"><a href="#cb21-239" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.array([<span class="fl">1.5</span>, <span class="fl">2.0</span>, <span class="op">-</span><span class="fl">0.5</span>])</span>
<span id="cb21-240"><a href="#cb21-240" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="op">-</span><span class="fl">1.0</span>, <span class="fl">0.3</span>])</span>
<span id="cb21-241"><a href="#cb21-241" aria-hidden="true" tabindex="-1"></a>bias <span class="op">=</span> <span class="fl">0.5</span></span>
<span id="cb21-242"><a href="#cb21-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-243"><a href="#cb21-243" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute weighted sum</span></span>
<span id="cb21-244"><a href="#cb21-244" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> np.dot(inputs, weights) <span class="op">+</span> bias</span>
<span id="cb21-245"><a href="#cb21-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-246"><a href="#cb21-246" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weighted sum (z): </span><span class="sc">{</span>z<span class="sc">:.3f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb21-247"><a href="#cb21-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-248"><a href="#cb21-248" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply different activations</span></span>
<span id="cb21-249"><a href="#cb21-249" aria-hidden="true" tabindex="-1"></a>activations <span class="op">=</span> {</span>
<span id="cb21-250"><a href="#cb21-250" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Linear (no activation)'</span>: <span class="kw">lambda</span> x: x,</span>
<span id="cb21-251"><a href="#cb21-251" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ReLU'</span>: relu,</span>
<span id="cb21-252"><a href="#cb21-252" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Sigmoid'</span>: sigmoid,</span>
<span id="cb21-253"><a href="#cb21-253" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Tanh'</span>: tanh,</span>
<span id="cb21-254"><a href="#cb21-254" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Leaky ReLU'</span>: leaky_relu</span>
<span id="cb21-255"><a href="#cb21-255" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-256"><a href="#cb21-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-257"><a href="#cb21-257" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, fn <span class="kw">in</span> activations.items():</span>
<span id="cb21-258"><a href="#cb21-258" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> fn(z)</span>
<span id="cb21-259"><a href="#cb21-259" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:25s}</span><span class="ss">: </span><span class="sc">{</span>output<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-260"><a href="#cb21-260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-261"><a href="#cb21-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-262"><a href="#cb21-262" aria-hidden="true" tabindex="-1"></a>**Why this matters:** The activation function dramatically changes the neuron's output. This non-linear transformation is what allows neural networks to learn complex, non-linear patterns in data.</span>
<span id="cb21-263"><a href="#cb21-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-264"><a href="#cb21-264" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-265"><a href="#cb21-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-266"><a href="#cb21-266" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2: From Single Neurons to Layers</span></span>
<span id="cb21-267"><a href="#cb21-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-268"><a href="#cb21-268" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Power of Vectorization</span></span>
<span id="cb21-269"><a href="#cb21-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-270"><a href="#cb21-270" aria-hidden="true" tabindex="-1"></a>Rather than computing neurons one at a time, we can process an entire layer simultaneously using matrix operations. This is both computationally efficient and conceptually elegant.</span>
<span id="cb21-271"><a href="#cb21-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-274"><a href="#cb21-274" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-275"><a href="#cb21-275" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 10</span></span>
<span id="cb21-276"><a href="#cb21-276" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "From Single Neuron to Layer of Neurons"</span></span>
<span id="cb21-277"><a href="#cb21-277" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TB</span></span>
<span id="cb21-278"><a href="#cb21-278" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph single["Single Neuron (Sequential)"]</span></span>
<span id="cb21-279"><a href="#cb21-279" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-280"><a href="#cb21-280" aria-hidden="true" tabindex="-1"></a><span class="in">        i1["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n1["Neuron 1"]</span></span>
<span id="cb21-281"><a href="#cb21-281" aria-hidden="true" tabindex="-1"></a><span class="in">        i2["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n2["Neuron 2"]</span></span>
<span id="cb21-282"><a href="#cb21-282" aria-hidden="true" tabindex="-1"></a><span class="in">        i3["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; n3["Neuron 3"]</span></span>
<span id="cb21-283"><a href="#cb21-283" aria-hidden="true" tabindex="-1"></a><span class="in">        n1 --&gt; o1["Output 1"]</span></span>
<span id="cb21-284"><a href="#cb21-284" aria-hidden="true" tabindex="-1"></a><span class="in">        n2 --&gt; o2["Output 2"]</span></span>
<span id="cb21-285"><a href="#cb21-285" aria-hidden="true" tabindex="-1"></a><span class="in">        n3 --&gt; o3["Output 3"]</span></span>
<span id="cb21-286"><a href="#cb21-286" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-287"><a href="#cb21-287" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-288"><a href="#cb21-288" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph vectorized["Vectorized Layer (Parallel)"]</span></span>
<span id="cb21-289"><a href="#cb21-289" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-290"><a href="#cb21-290" aria-hidden="true" tabindex="-1"></a><span class="in">        iv["Input&lt;br/&gt;Vector&lt;br/&gt;(3 dims)"] --&gt; matrix["Weight Matrix&lt;br/&gt;(3 × 5)&lt;br/&gt;+ Bias&lt;br/&gt;+ Activation"]</span></span>
<span id="cb21-291"><a href="#cb21-291" aria-hidden="true" tabindex="-1"></a><span class="in">        matrix --&gt; ov["Output&lt;br/&gt;Vector&lt;br/&gt;(5 dims)"]</span></span>
<span id="cb21-292"><a href="#cb21-292" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-293"><a href="#cb21-293" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-294"><a href="#cb21-294" aria-hidden="true" tabindex="-1"></a><span class="in">    single -.-&gt;|"Matrix Operation"| vectorized</span></span>
<span id="cb21-295"><a href="#cb21-295" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-296"><a href="#cb21-296" aria-hidden="true" tabindex="-1"></a><span class="in">    style single fill:#ffe1e1</span></span>
<span id="cb21-297"><a href="#cb21-297" aria-hidden="true" tabindex="-1"></a><span class="in">    style vectorized fill:#e1ffe1</span></span>
<span id="cb21-298"><a href="#cb21-298" aria-hidden="true" tabindex="-1"></a><span class="in">    style matrix fill:#fff3e1</span></span>
<span id="cb21-299"><a href="#cb21-299" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-300"><a href="#cb21-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-301"><a href="#cb21-301" aria-hidden="true" tabindex="-1"></a>**Key insight**: Instead of looping through neurons, one matrix multiplication processes all neurons simultaneously!</span>
<span id="cb21-302"><a href="#cb21-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-303"><a href="#cb21-303" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb21-304"><a href="#cb21-304" aria-hidden="true" tabindex="-1"></a><span class="fu">## Video Resource</span></span>
<span id="cb21-305"><a href="#cb21-305" aria-hidden="true" tabindex="-1"></a>For understanding how layers work together, see 3Blue1Brown's <span class="co">[</span><span class="ot">Neural network intuitions</span><span class="co">](https://www.youtube.com/watch?v=aircAruvnKk&amp;t=420s)</span> (timestamp 7:00 onwards).</span>
<span id="cb21-306"><a href="#cb21-306" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-307"><a href="#cb21-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-310"><a href="#cb21-310" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-311"><a href="#cb21-311" aria-hidden="true" tabindex="-1"></a><span class="co"># A layer is just multiple neurons working in parallel</span></span>
<span id="cb21-312"><a href="#cb21-312" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NeuralLayer:</span>
<span id="cb21-313"><a href="#cb21-313" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A single layer of neurons with vectorized operations."""</span></span>
<span id="cb21-314"><a href="#cb21-314" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-315"><a href="#cb21-315" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n_inputs, n_neurons):</span>
<span id="cb21-316"><a href="#cb21-316" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-317"><a href="#cb21-317" aria-hidden="true" tabindex="-1"></a><span class="co">        Initialize a layer.</span></span>
<span id="cb21-318"><a href="#cb21-318" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-319"><a href="#cb21-319" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-320"><a href="#cb21-320" aria-hidden="true" tabindex="-1"></a><span class="co">            n_inputs: number of input features</span></span>
<span id="cb21-321"><a href="#cb21-321" aria-hidden="true" tabindex="-1"></a><span class="co">            n_neurons: number of neurons in this layer</span></span>
<span id="cb21-322"><a href="#cb21-322" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-323"><a href="#cb21-323" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Each neuron has n_inputs weights</span></span>
<span id="cb21-324"><a href="#cb21-324" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shape: (n_inputs, n_neurons)</span></span>
<span id="cb21-325"><a href="#cb21-325" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> np.random.randn(n_inputs, n_neurons) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb21-326"><a href="#cb21-326" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-327"><a href="#cb21-327" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Each neuron has one bias</span></span>
<span id="cb21-328"><a href="#cb21-328" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Shape: (n_neurons,)</span></span>
<span id="cb21-329"><a href="#cb21-329" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.biases <span class="op">=</span> np.zeros(n_neurons)</span>
<span id="cb21-330"><a href="#cb21-330" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-331"><a href="#cb21-331" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs, activation_fn<span class="op">=</span>relu):</span>
<span id="cb21-332"><a href="#cb21-332" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-333"><a href="#cb21-333" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass through the layer.</span></span>
<span id="cb21-334"><a href="#cb21-334" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-335"><a href="#cb21-335" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-336"><a href="#cb21-336" aria-hidden="true" tabindex="-1"></a><span class="co">            inputs: input array of shape (n_samples, n_inputs)</span></span>
<span id="cb21-337"><a href="#cb21-337" aria-hidden="true" tabindex="-1"></a><span class="co">            activation_fn: activation function to apply</span></span>
<span id="cb21-338"><a href="#cb21-338" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-339"><a href="#cb21-339" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb21-340"><a href="#cb21-340" aria-hidden="true" tabindex="-1"></a><span class="co">            outputs after activation, shape (n_samples, n_neurons)</span></span>
<span id="cb21-341"><a href="#cb21-341" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-342"><a href="#cb21-342" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Matrix multiplication: (n_samples, n_inputs) @ (n_inputs, n_neurons)</span></span>
<span id="cb21-343"><a href="#cb21-343" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Result: (n_samples, n_neurons)</span></span>
<span id="cb21-344"><a href="#cb21-344" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> np.dot(inputs, <span class="va">self</span>.weights) <span class="op">+</span> <span class="va">self</span>.biases</span>
<span id="cb21-345"><a href="#cb21-345" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-346"><a href="#cb21-346" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply activation function element-wise</span></span>
<span id="cb21-347"><a href="#cb21-347" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> activation_fn(z)</span>
<span id="cb21-348"><a href="#cb21-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-349"><a href="#cb21-349" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a layer with 3 inputs and 5 neurons</span></span>
<span id="cb21-350"><a href="#cb21-350" aria-hidden="true" tabindex="-1"></a>layer <span class="op">=</span> NeuralLayer(n_inputs<span class="op">=</span><span class="dv">3</span>, n_neurons<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb21-351"><a href="#cb21-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-352"><a href="#cb21-352" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a batch of 4 samples</span></span>
<span id="cb21-353"><a href="#cb21-353" aria-hidden="true" tabindex="-1"></a>batch_inputs <span class="op">=</span> np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb21-354"><a href="#cb21-354" aria-hidden="true" tabindex="-1"></a>outputs <span class="op">=</span> layer.forward(batch_inputs, activation_fn<span class="op">=</span>relu)</span>
<span id="cb21-355"><a href="#cb21-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-356"><a href="#cb21-356" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>batch_inputs<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-357"><a href="#cb21-357" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Weight matrix shape: </span><span class="sc">{</span>layer<span class="sc">.</span>weights<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-358"><a href="#cb21-358" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>outputs<span class="sc">.</span>shape<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb21-359"><a href="#cb21-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-360"><a href="#cb21-360" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Sample input:"</span>)</span>
<span id="cb21-361"><a href="#cb21-361" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(batch_inputs[<span class="dv">0</span>])</span>
<span id="cb21-362"><a href="#cb21-362" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Corresponding output:"</span>)</span>
<span id="cb21-363"><a href="#cb21-363" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(outputs[<span class="dv">0</span>])</span>
<span id="cb21-364"><a href="#cb21-364" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-365"><a href="#cb21-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-366"><a href="#cb21-366" aria-hidden="true" tabindex="-1"></a>**What to notice:** </span>
<span id="cb21-367"><a href="#cb21-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-368"><a href="#cb21-368" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The weight matrix has shape <span class="in">`(n_inputs, n_neurons)`</span> - each column represents one neuron's weights.</span>
<span id="cb21-369"><a href="#cb21-369" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>One matrix multiplication processes all neurons and all samples simultaneously.</span>
<span id="cb21-370"><a href="#cb21-370" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Output shape is <span class="in">`(n_samples, n_neurons)`</span> - each sample gets transformed into a vector of neuron activations.</span>
<span id="cb21-371"><a href="#cb21-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-372"><a href="#cb21-372" aria-hidden="true" tabindex="-1"></a><span class="fu">### Building a Multi-Layer Network</span></span>
<span id="cb21-373"><a href="#cb21-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-374"><a href="#cb21-374" aria-hidden="true" tabindex="-1"></a>Now let's stack multiple layers to create a deep neural network:</span>
<span id="cb21-375"><a href="#cb21-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-378"><a href="#cb21-378" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-379"><a href="#cb21-379" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 10</span></span>
<span id="cb21-380"><a href="#cb21-380" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Multi-Layer Neural Network Architecture"</span></span>
<span id="cb21-381"><a href="#cb21-381" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart LR</span></span>
<span id="cb21-382"><a href="#cb21-382" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph input["Input Layer"]</span></span>
<span id="cb21-383"><a href="#cb21-383" aria-hidden="true" tabindex="-1"></a><span class="in">        i1["x₁"]</span></span>
<span id="cb21-384"><a href="#cb21-384" aria-hidden="true" tabindex="-1"></a><span class="in">        i2["x₂"]</span></span>
<span id="cb21-385"><a href="#cb21-385" aria-hidden="true" tabindex="-1"></a><span class="in">        i3["x₃"]</span></span>
<span id="cb21-386"><a href="#cb21-386" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-387"><a href="#cb21-387" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-388"><a href="#cb21-388" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph hidden1["Hidden Layer 1&lt;br/&gt;(8 neurons)"]</span></span>
<span id="cb21-389"><a href="#cb21-389" aria-hidden="true" tabindex="-1"></a><span class="in">        h11["🔵"]</span></span>
<span id="cb21-390"><a href="#cb21-390" aria-hidden="true" tabindex="-1"></a><span class="in">        h12["🔵"]</span></span>
<span id="cb21-391"><a href="#cb21-391" aria-hidden="true" tabindex="-1"></a><span class="in">        h13["🔵"]</span></span>
<span id="cb21-392"><a href="#cb21-392" aria-hidden="true" tabindex="-1"></a><span class="in">        h14["🔵"]</span></span>
<span id="cb21-393"><a href="#cb21-393" aria-hidden="true" tabindex="-1"></a><span class="in">        h15["🔵"]</span></span>
<span id="cb21-394"><a href="#cb21-394" aria-hidden="true" tabindex="-1"></a><span class="in">        h16["🔵"]</span></span>
<span id="cb21-395"><a href="#cb21-395" aria-hidden="true" tabindex="-1"></a><span class="in">        h17["🔵"]</span></span>
<span id="cb21-396"><a href="#cb21-396" aria-hidden="true" tabindex="-1"></a><span class="in">        h18["🔵"]</span></span>
<span id="cb21-397"><a href="#cb21-397" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-398"><a href="#cb21-398" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-399"><a href="#cb21-399" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph hidden2["Hidden Layer 2&lt;br/&gt;(5 neurons)"]</span></span>
<span id="cb21-400"><a href="#cb21-400" aria-hidden="true" tabindex="-1"></a><span class="in">        h21["🟢"]</span></span>
<span id="cb21-401"><a href="#cb21-401" aria-hidden="true" tabindex="-1"></a><span class="in">        h22["🟢"]</span></span>
<span id="cb21-402"><a href="#cb21-402" aria-hidden="true" tabindex="-1"></a><span class="in">        h23["🟢"]</span></span>
<span id="cb21-403"><a href="#cb21-403" aria-hidden="true" tabindex="-1"></a><span class="in">        h24["🟢"]</span></span>
<span id="cb21-404"><a href="#cb21-404" aria-hidden="true" tabindex="-1"></a><span class="in">        h25["🟢"]</span></span>
<span id="cb21-405"><a href="#cb21-405" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-406"><a href="#cb21-406" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-407"><a href="#cb21-407" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph output["Output Layer&lt;br/&gt;(2 neurons)"]</span></span>
<span id="cb21-408"><a href="#cb21-408" aria-hidden="true" tabindex="-1"></a><span class="in">        o1["🔴"]</span></span>
<span id="cb21-409"><a href="#cb21-409" aria-hidden="true" tabindex="-1"></a><span class="in">        o2["🔴"]</span></span>
<span id="cb21-410"><a href="#cb21-410" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-411"><a href="#cb21-411" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-412"><a href="#cb21-412" aria-hidden="true" tabindex="-1"></a><span class="in">    i1 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18</span></span>
<span id="cb21-413"><a href="#cb21-413" aria-hidden="true" tabindex="-1"></a><span class="in">    i2 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18</span></span>
<span id="cb21-414"><a href="#cb21-414" aria-hidden="true" tabindex="-1"></a><span class="in">    i3 --&gt; h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18</span></span>
<span id="cb21-415"><a href="#cb21-415" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-416"><a href="#cb21-416" aria-hidden="true" tabindex="-1"></a><span class="in">    h11 &amp; h12 &amp; h13 &amp; h14 &amp; h15 &amp; h16 &amp; h17 &amp; h18 --&gt; h21 &amp; h22 &amp; h23 &amp; h24 &amp; h25</span></span>
<span id="cb21-417"><a href="#cb21-417" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-418"><a href="#cb21-418" aria-hidden="true" tabindex="-1"></a><span class="in">    h21 &amp; h22 &amp; h23 &amp; h24 &amp; h25 --&gt; o1 &amp; o2</span></span>
<span id="cb21-419"><a href="#cb21-419" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-420"><a href="#cb21-420" aria-hidden="true" tabindex="-1"></a><span class="in">    style input fill:#e1f5ff</span></span>
<span id="cb21-421"><a href="#cb21-421" aria-hidden="true" tabindex="-1"></a><span class="in">    style hidden1 fill:#e8e1ff</span></span>
<span id="cb21-422"><a href="#cb21-422" aria-hidden="true" tabindex="-1"></a><span class="in">    style hidden2 fill:#e1ffe8</span></span>
<span id="cb21-423"><a href="#cb21-423" aria-hidden="true" tabindex="-1"></a><span class="in">    style output fill:#ffe1e1</span></span>
<span id="cb21-424"><a href="#cb21-424" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-425"><a href="#cb21-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-426"><a href="#cb21-426" aria-hidden="true" tabindex="-1"></a>**Key insight**: Data flows forward through the network, with each layer creating progressively more abstract representations.</span>
<span id="cb21-427"><a href="#cb21-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-428"><a href="#cb21-428" aria-hidden="true" tabindex="-1"></a>Now let's implement this:</span>
<span id="cb21-429"><a href="#cb21-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-432"><a href="#cb21-432" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-433"><a href="#cb21-433" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SimpleNeuralNetwork:</span>
<span id="cb21-434"><a href="#cb21-434" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A simple feedforward neural network."""</span></span>
<span id="cb21-435"><a href="#cb21-435" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-436"><a href="#cb21-436" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, layer_sizes):</span>
<span id="cb21-437"><a href="#cb21-437" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-438"><a href="#cb21-438" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-439"><a href="#cb21-439" aria-hidden="true" tabindex="-1"></a><span class="co">            layer_sizes: list of layer sizes, e.g., [3, 8, 5, 2]</span></span>
<span id="cb21-440"><a href="#cb21-440" aria-hidden="true" tabindex="-1"></a><span class="co">                        means 3 inputs, two hidden layers (8 and 5 neurons),</span></span>
<span id="cb21-441"><a href="#cb21-441" aria-hidden="true" tabindex="-1"></a><span class="co">                        and 2 output neurons</span></span>
<span id="cb21-442"><a href="#cb21-442" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-443"><a href="#cb21-443" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.layers <span class="op">=</span> []</span>
<span id="cb21-444"><a href="#cb21-444" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(layer_sizes) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb21-445"><a href="#cb21-445" aria-hidden="true" tabindex="-1"></a>            layer <span class="op">=</span> NeuralLayer(layer_sizes[i], layer_sizes[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb21-446"><a href="#cb21-446" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.layers.append(layer)</span>
<span id="cb21-447"><a href="#cb21-447" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-448"><a href="#cb21-448" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, inputs):</span>
<span id="cb21-449"><a href="#cb21-449" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Forward pass through all layers."""</span></span>
<span id="cb21-450"><a href="#cb21-450" aria-hidden="true" tabindex="-1"></a>        activation <span class="op">=</span> inputs</span>
<span id="cb21-451"><a href="#cb21-451" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-452"><a href="#cb21-452" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Forward pass through network:"</span>)</span>
<span id="cb21-453"><a href="#cb21-453" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>activation<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-454"><a href="#cb21-454" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-455"><a href="#cb21-455" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.layers):</span>
<span id="cb21-456"><a href="#cb21-456" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use ReLU for hidden layers, linear for output</span></span>
<span id="cb21-457"><a href="#cb21-457" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.layers) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb21-458"><a href="#cb21-458" aria-hidden="true" tabindex="-1"></a>                activation <span class="op">=</span> layer.forward(activation, activation_fn<span class="op">=</span>relu)</span>
<span id="cb21-459"><a href="#cb21-459" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb21-460"><a href="#cb21-460" aria-hidden="true" tabindex="-1"></a>                activation <span class="op">=</span> layer.forward(activation, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb21-461"><a href="#cb21-461" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb21-462"><a href="#cb21-462" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"After layer </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>activation<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-463"><a href="#cb21-463" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-464"><a href="#cb21-464" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> activation</span>
<span id="cb21-465"><a href="#cb21-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-466"><a href="#cb21-466" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a network: 3 inputs -&gt; 8 hidden -&gt; 5 hidden -&gt; 2 outputs</span></span>
<span id="cb21-467"><a href="#cb21-467" aria-hidden="true" tabindex="-1"></a>network <span class="op">=</span> SimpleNeuralNetwork([<span class="dv">3</span>, <span class="dv">8</span>, <span class="dv">5</span>, <span class="dv">2</span>])</span>
<span id="cb21-468"><a href="#cb21-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-469"><a href="#cb21-469" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a batch of data</span></span>
<span id="cb21-470"><a href="#cb21-470" aria-hidden="true" tabindex="-1"></a>batch <span class="op">=</span> np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>)</span>
<span id="cb21-471"><a href="#cb21-471" aria-hidden="true" tabindex="-1"></a>output <span class="op">=</span> network.forward(batch)</span>
<span id="cb21-472"><a href="#cb21-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-473"><a href="#cb21-473" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Final output:</span><span class="ch">\n</span><span class="sc">{</span>output<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-474"><a href="#cb21-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-475"><a href="#cb21-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-476"><a href="#cb21-476" aria-hidden="true" tabindex="-1"></a>**What to notice:** </span>
<span id="cb21-477"><a href="#cb21-477" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Each layer transforms the data: <span class="in">`(batch, n_in) -&gt; (batch, n_out)`</span></span>
<span id="cb21-478"><a href="#cb21-478" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The output of one layer becomes the input to the next</span>
<span id="cb21-479"><a href="#cb21-479" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This creates a series of increasingly abstract representations</span>
<span id="cb21-480"><a href="#cb21-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-481"><a href="#cb21-481" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing the Transformation</span></span>
<span id="cb21-482"><a href="#cb21-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-483"><a href="#cb21-483" aria-hidden="true" tabindex="-1"></a>Let's see how data is transformed as it flows through the network:</span>
<span id="cb21-484"><a href="#cb21-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-487"><a href="#cb21-487" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-488"><a href="#cb21-488" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a simpler network for visualization</span></span>
<span id="cb21-489"><a href="#cb21-489" aria-hidden="true" tabindex="-1"></a>viz_network <span class="op">=</span> SimpleNeuralNetwork([<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb21-490"><a href="#cb21-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-491"><a href="#cb21-491" aria-hidden="true" tabindex="-1"></a><span class="co"># Create some structured input data</span></span>
<span id="cb21-492"><a href="#cb21-492" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>np.pi, <span class="dv">100</span>)</span>
<span id="cb21-493"><a href="#cb21-493" aria-hidden="true" tabindex="-1"></a>inputs <span class="op">=</span> np.column_stack([np.cos(theta), np.sin(theta)])</span>
<span id="cb21-494"><a href="#cb21-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-495"><a href="#cb21-495" aria-hidden="true" tabindex="-1"></a><span class="co"># Track activations at each layer</span></span>
<span id="cb21-496"><a href="#cb21-496" aria-hidden="true" tabindex="-1"></a>activations <span class="op">=</span> [inputs]</span>
<span id="cb21-497"><a href="#cb21-497" aria-hidden="true" tabindex="-1"></a>current <span class="op">=</span> inputs</span>
<span id="cb21-498"><a href="#cb21-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-499"><a href="#cb21-499" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(viz_network.layers):</span>
<span id="cb21-500"><a href="#cb21-500" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="bu">len</span>(viz_network.layers) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb21-501"><a href="#cb21-501" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> layer.forward(current, activation_fn<span class="op">=</span>relu)</span>
<span id="cb21-502"><a href="#cb21-502" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-503"><a href="#cb21-503" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> layer.forward(current, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb21-504"><a href="#cb21-504" aria-hidden="true" tabindex="-1"></a>    activations.append(current)</span>
<span id="cb21-505"><a href="#cb21-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-506"><a href="#cb21-506" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the transformations</span></span>
<span id="cb21-507"><a href="#cb21-507" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb21-508"><a href="#cb21-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-509"><a href="#cb21-509" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (ax, act) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(axes, activations)):</span>
<span id="cb21-510"><a href="#cb21-510" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-511"><a href="#cb21-511" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Input Space"</span></span>
<span id="cb21-512"><a href="#cb21-512" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> i <span class="op">==</span> <span class="bu">len</span>(activations) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb21-513"><a href="#cb21-513" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="st">"Output Space"</span></span>
<span id="cb21-514"><a href="#cb21-514" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb21-515"><a href="#cb21-515" aria-hidden="true" tabindex="-1"></a>        title <span class="op">=</span> <span class="ss">f"Hidden Layer </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb21-516"><a href="#cb21-516" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-517"><a href="#cb21-517" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot first two dimensions</span></span>
<span id="cb21-518"><a href="#cb21-518" aria-hidden="true" tabindex="-1"></a>    ax.scatter(act[:, <span class="dv">0</span>], act[:, <span class="dv">1</span>], c<span class="op">=</span>theta, cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb21-519"><a href="#cb21-519" aria-hidden="true" tabindex="-1"></a>    ax.set_title(title, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-520"><a href="#cb21-520" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">'Dimension 1'</span>)</span>
<span id="cb21-521"><a href="#cb21-521" aria-hidden="true" tabindex="-1"></a>    ax.set_ylabel(<span class="st">'Dimension 2'</span>)</span>
<span id="cb21-522"><a href="#cb21-522" aria-hidden="true" tabindex="-1"></a>    ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-523"><a href="#cb21-523" aria-hidden="true" tabindex="-1"></a>    ax.axis(<span class="st">'equal'</span>)</span>
<span id="cb21-524"><a href="#cb21-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-525"><a href="#cb21-525" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb21-526"><a href="#cb21-526" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb21-527"><a href="#cb21-527" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-528"><a href="#cb21-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-529"><a href="#cb21-529" aria-hidden="true" tabindex="-1"></a>**What to notice:** Each layer progressively transforms the data, creating new representations. The network learns to map inputs to outputs through these transformations.</span>
<span id="cb21-530"><a href="#cb21-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-531"><a href="#cb21-531" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-532"><a href="#cb21-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-533"><a href="#cb21-533" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 3: Attention Mechanisms and Transformers</span></span>
<span id="cb21-534"><a href="#cb21-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-535"><a href="#cb21-535" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Limitation of Basic Neural Networks</span></span>
<span id="cb21-536"><a href="#cb21-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-537"><a href="#cb21-537" aria-hidden="true" tabindex="-1"></a>Traditional feedforward networks process each input independently. But what if relationships *between* inputs matter? This is where **attention mechanisms** come in.</span>
<span id="cb21-538"><a href="#cb21-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-539"><a href="#cb21-539" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb21-540"><a href="#cb21-540" aria-hidden="true" tabindex="-1"></a><span class="fu">## Video Resource</span></span>
<span id="cb21-541"><a href="#cb21-541" aria-hidden="true" tabindex="-1"></a>For an excellent visual explanation of attention and transformers, watch:</span>
<span id="cb21-542"><a href="#cb21-542" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Attention in transformers, visually explained</span><span class="co">](https://www.youtube.com/watch?v=eMlx5fFNoYc)</span> by 3Blue1Brown</span>
<span id="cb21-543"><a href="#cb21-543" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">[</span><span class="ot">Visualizing Attention, a Transformer's Heart</span><span class="co">](https://www.youtube.com/watch?v=eMlx5fFNoYc&amp;t=0s)</span> (full explanation)</span>
<span id="cb21-544"><a href="#cb21-544" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-545"><a href="#cb21-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-546"><a href="#cb21-546" aria-hidden="true" tabindex="-1"></a><span class="fu">### What is Attention?</span></span>
<span id="cb21-547"><a href="#cb21-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-548"><a href="#cb21-548" aria-hidden="true" tabindex="-1"></a>Attention allows the network to **focus on relevant parts of the input** when processing each element. Think of reading a sentence: to understand "it," you need to look back and find what "it" refers to.</span>
<span id="cb21-549"><a href="#cb21-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-552"><a href="#cb21-552" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-553"><a href="#cb21-553" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 10</span></span>
<span id="cb21-554"><a href="#cb21-554" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Attention Mechanism: Query-Key-Value"</span></span>
<span id="cb21-555"><a href="#cb21-555" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TB</span></span>
<span id="cb21-556"><a href="#cb21-556" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph input["Input Sequence"]</span></span>
<span id="cb21-557"><a href="#cb21-557" aria-hidden="true" tabindex="-1"></a><span class="in">        t1["Token 1"]</span></span>
<span id="cb21-558"><a href="#cb21-558" aria-hidden="true" tabindex="-1"></a><span class="in">        t2["Token 2"]</span></span>
<span id="cb21-559"><a href="#cb21-559" aria-hidden="true" tabindex="-1"></a><span class="in">        t3["Token 3"]</span></span>
<span id="cb21-560"><a href="#cb21-560" aria-hidden="true" tabindex="-1"></a><span class="in">        t4["Token 4"]</span></span>
<span id="cb21-561"><a href="#cb21-561" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-562"><a href="#cb21-562" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-563"><a href="#cb21-563" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph qkv["Linear Projections"]</span></span>
<span id="cb21-564"><a href="#cb21-564" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-565"><a href="#cb21-565" aria-hidden="true" tabindex="-1"></a><span class="in">        q["Query (Q)&lt;br/&gt;What I'm looking for"]</span></span>
<span id="cb21-566"><a href="#cb21-566" aria-hidden="true" tabindex="-1"></a><span class="in">        k["Key (K)&lt;br/&gt;What I offer"]</span></span>
<span id="cb21-567"><a href="#cb21-567" aria-hidden="true" tabindex="-1"></a><span class="in">        v["Value (V)&lt;br/&gt;What I return"]</span></span>
<span id="cb21-568"><a href="#cb21-568" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-569"><a href="#cb21-569" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-570"><a href="#cb21-570" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph attention["Attention Computation"]</span></span>
<span id="cb21-571"><a href="#cb21-571" aria-hidden="true" tabindex="-1"></a><span class="in">        similarity["Compute Similarity&lt;br/&gt;Q · Kᵀ"]</span></span>
<span id="cb21-572"><a href="#cb21-572" aria-hidden="true" tabindex="-1"></a><span class="in">        weights["Softmax&lt;br/&gt;(Attention Weights)"]</span></span>
<span id="cb21-573"><a href="#cb21-573" aria-hidden="true" tabindex="-1"></a><span class="in">        output["Weighted Sum&lt;br/&gt;Σ(weights × V)"]</span></span>
<span id="cb21-574"><a href="#cb21-574" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-575"><a href="#cb21-575" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-576"><a href="#cb21-576" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph result["Context-Aware Output"]</span></span>
<span id="cb21-577"><a href="#cb21-577" aria-hidden="true" tabindex="-1"></a><span class="in">        o1["Output 1&lt;br/&gt;(informed by all tokens)"]</span></span>
<span id="cb21-578"><a href="#cb21-578" aria-hidden="true" tabindex="-1"></a><span class="in">        o2["Output 2&lt;br/&gt;(informed by all tokens)"]</span></span>
<span id="cb21-579"><a href="#cb21-579" aria-hidden="true" tabindex="-1"></a><span class="in">        o3["Output 3&lt;br/&gt;(informed by all tokens)"]</span></span>
<span id="cb21-580"><a href="#cb21-580" aria-hidden="true" tabindex="-1"></a><span class="in">        o4["Output 4&lt;br/&gt;(informed by all tokens)"]</span></span>
<span id="cb21-581"><a href="#cb21-581" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-582"><a href="#cb21-582" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-583"><a href="#cb21-583" aria-hidden="true" tabindex="-1"></a><span class="in">    t1 &amp; t2 &amp; t3 &amp; t4 --&gt; qkv</span></span>
<span id="cb21-584"><a href="#cb21-584" aria-hidden="true" tabindex="-1"></a><span class="in">    qkv --&gt; similarity</span></span>
<span id="cb21-585"><a href="#cb21-585" aria-hidden="true" tabindex="-1"></a><span class="in">    similarity --&gt; weights</span></span>
<span id="cb21-586"><a href="#cb21-586" aria-hidden="true" tabindex="-1"></a><span class="in">    weights --&gt; output</span></span>
<span id="cb21-587"><a href="#cb21-587" aria-hidden="true" tabindex="-1"></a><span class="in">    output --&gt; o1 &amp; o2 &amp; o3 &amp; o4</span></span>
<span id="cb21-588"><a href="#cb21-588" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-589"><a href="#cb21-589" aria-hidden="true" tabindex="-1"></a><span class="in">    style input fill:#e1f5ff</span></span>
<span id="cb21-590"><a href="#cb21-590" aria-hidden="true" tabindex="-1"></a><span class="in">    style qkv fill:#fff3e1</span></span>
<span id="cb21-591"><a href="#cb21-591" aria-hidden="true" tabindex="-1"></a><span class="in">    style attention fill:#f0e1ff</span></span>
<span id="cb21-592"><a href="#cb21-592" aria-hidden="true" tabindex="-1"></a><span class="in">    style result fill:#e1ffe1</span></span>
<span id="cb21-593"><a href="#cb21-593" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-594"><a href="#cb21-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-595"><a href="#cb21-595" aria-hidden="true" tabindex="-1"></a>**Key insight**: Each token can "attend to" (look at) all other tokens, deciding which are most relevant for its own representation.</span>
<span id="cb21-596"><a href="#cb21-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-599"><a href="#cb21-599" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-600"><a href="#cb21-600" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_attention(query, keys, values):</span>
<span id="cb21-601"><a href="#cb21-601" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-602"><a href="#cb21-602" aria-hidden="true" tabindex="-1"></a><span class="co">    Simplified attention mechanism.</span></span>
<span id="cb21-603"><a href="#cb21-603" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb21-604"><a href="#cb21-604" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb21-605"><a href="#cb21-605" aria-hidden="true" tabindex="-1"></a><span class="co">        query: what we're looking for (n_queries, d_k)</span></span>
<span id="cb21-606"><a href="#cb21-606" aria-hidden="true" tabindex="-1"></a><span class="co">        keys: what we're comparing against (n_keys, d_k)</span></span>
<span id="cb21-607"><a href="#cb21-607" aria-hidden="true" tabindex="-1"></a><span class="co">        values: what we return (n_keys, d_v)</span></span>
<span id="cb21-608"><a href="#cb21-608" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb21-609"><a href="#cb21-609" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb21-610"><a href="#cb21-610" aria-hidden="true" tabindex="-1"></a><span class="co">        weighted combination of values</span></span>
<span id="cb21-611"><a href="#cb21-611" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-612"><a href="#cb21-612" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Compute similarity scores</span></span>
<span id="cb21-613"><a href="#cb21-613" aria-hidden="true" tabindex="-1"></a>    <span class="co"># How much does each key match the query?</span></span>
<span id="cb21-614"><a href="#cb21-614" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> np.dot(query, keys.T)  <span class="co"># (n_queries, n_keys)</span></span>
<span id="cb21-615"><a href="#cb21-615" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-616"><a href="#cb21-616" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Convert to attention weights (softmax)</span></span>
<span id="cb21-617"><a href="#cb21-617" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale by sqrt of dimension for stability</span></span>
<span id="cb21-618"><a href="#cb21-618" aria-hidden="true" tabindex="-1"></a>    d_k <span class="op">=</span> keys.shape[<span class="dv">1</span>]</span>
<span id="cb21-619"><a href="#cb21-619" aria-hidden="true" tabindex="-1"></a>    scores <span class="op">=</span> scores <span class="op">/</span> np.sqrt(d_k)</span>
<span id="cb21-620"><a href="#cb21-620" aria-hidden="true" tabindex="-1"></a>    attention_weights <span class="op">=</span> np.exp(scores) <span class="op">/</span> np.exp(scores).<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-621"><a href="#cb21-621" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-622"><a href="#cb21-622" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Weighted sum of values</span></span>
<span id="cb21-623"><a href="#cb21-623" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> np.dot(attention_weights, values)  <span class="co"># (n_queries, d_v)</span></span>
<span id="cb21-624"><a href="#cb21-624" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-625"><a href="#cb21-625" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output, attention_weights</span>
<span id="cb21-626"><a href="#cb21-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-627"><a href="#cb21-627" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: A simple sequence</span></span>
<span id="cb21-628"><a href="#cb21-628" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's say we have 4 tokens (words), each represented by a 3D vector</span></span>
<span id="cb21-629"><a href="#cb21-629" aria-hidden="true" tabindex="-1"></a>sequence <span class="op">=</span> np.array([</span>
<span id="cb21-630"><a href="#cb21-630" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.0</span>, <span class="fl">0.5</span>],  <span class="co"># Token 0</span></span>
<span id="cb21-631"><a href="#cb21-631" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.5</span>, <span class="fl">1.0</span>, <span class="fl">0.2</span>],  <span class="co"># Token 1</span></span>
<span id="cb21-632"><a href="#cb21-632" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">1.0</span>],  <span class="co"># Token 2</span></span>
<span id="cb21-633"><a href="#cb21-633" aria-hidden="true" tabindex="-1"></a>    [<span class="fl">1.0</span>, <span class="fl">0.5</span>, <span class="fl">0.3</span>],  <span class="co"># Token 3</span></span>
<span id="cb21-634"><a href="#cb21-634" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb21-635"><a href="#cb21-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-636"><a href="#cb21-636" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's see what Token 2 attends to</span></span>
<span id="cb21-637"><a href="#cb21-637" aria-hidden="true" tabindex="-1"></a>query <span class="op">=</span> sequence[<span class="dv">2</span>:<span class="dv">3</span>]  <span class="co"># Query is Token 2</span></span>
<span id="cb21-638"><a href="#cb21-638" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> sequence        <span class="co"># Keys are all tokens</span></span>
<span id="cb21-639"><a href="#cb21-639" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> sequence      <span class="co"># Values are all tokens (simplified)</span></span>
<span id="cb21-640"><a href="#cb21-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-641"><a href="#cb21-641" aria-hidden="true" tabindex="-1"></a>output, attention_weights <span class="op">=</span> simple_attention(query, keys, values)</span>
<span id="cb21-642"><a href="#cb21-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-643"><a href="#cb21-643" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Attention weights for Token 2:"</span>)</span>
<span id="cb21-644"><a href="#cb21-644" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, weight <span class="kw">in</span> <span class="bu">enumerate</span>(attention_weights[<span class="dv">0</span>]):</span>
<span id="cb21-645"><a href="#cb21-645" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Token </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>weight<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-646"><a href="#cb21-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-647"><a href="#cb21-647" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Original Token 2: </span><span class="sc">{</span>sequence[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-648"><a href="#cb21-648" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"After attention:  </span><span class="sc">{</span>output[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-649"><a href="#cb21-649" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-650"><a href="#cb21-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-651"><a href="#cb21-651" aria-hidden="true" tabindex="-1"></a>**What to notice:** </span>
<span id="cb21-652"><a href="#cb21-652" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The attention weights sum to 1.0</span>
<span id="cb21-653"><a href="#cb21-653" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Token 2 attends most to itself, but also considers other tokens</span>
<span id="cb21-654"><a href="#cb21-654" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The output is a weighted combination - it's been "informed" by the context</span>
<span id="cb21-655"><a href="#cb21-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-656"><a href="#cb21-656" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Attention Patterns</span></span>
<span id="cb21-657"><a href="#cb21-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-660"><a href="#cb21-660" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-661"><a href="#cb21-661" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute full attention matrix (all tokens attending to all tokens)</span></span>
<span id="cb21-662"><a href="#cb21-662" aria-hidden="true" tabindex="-1"></a>all_queries <span class="op">=</span> sequence</span>
<span id="cb21-663"><a href="#cb21-663" aria-hidden="true" tabindex="-1"></a>all_keys <span class="op">=</span> sequence</span>
<span id="cb21-664"><a href="#cb21-664" aria-hidden="true" tabindex="-1"></a>all_values <span class="op">=</span> sequence</span>
<span id="cb21-665"><a href="#cb21-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-666"><a href="#cb21-666" aria-hidden="true" tabindex="-1"></a>outputs, full_attention <span class="op">=</span> simple_attention(all_queries, all_keys, all_values)</span>
<span id="cb21-667"><a href="#cb21-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-668"><a href="#cb21-668" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the attention matrix</span></span>
<span id="cb21-669"><a href="#cb21-669" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">5</span>))</span>
<span id="cb21-670"><a href="#cb21-670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-671"><a href="#cb21-671" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention matrix</span></span>
<span id="cb21-672"><a href="#cb21-672" aria-hidden="true" tabindex="-1"></a>im <span class="op">=</span> ax1.imshow(full_attention, cmap<span class="op">=</span><span class="st">'viridis'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>)</span>
<span id="cb21-673"><a href="#cb21-673" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Attention Matrix</span><span class="ch">\n</span><span class="st">(Which tokens attend to which)'</span>, </span>
<span id="cb21-674"><a href="#cb21-674" aria-hidden="true" tabindex="-1"></a>              fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-675"><a href="#cb21-675" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Key Token'</span>)</span>
<span id="cb21-676"><a href="#cb21-676" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Query Token'</span>)</span>
<span id="cb21-677"><a href="#cb21-677" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks(<span class="bu">range</span>(<span class="dv">4</span>))</span>
<span id="cb21-678"><a href="#cb21-678" aria-hidden="true" tabindex="-1"></a>ax1.set_yticks(<span class="bu">range</span>(<span class="dv">4</span>))</span>
<span id="cb21-679"><a href="#cb21-679" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im, ax<span class="op">=</span>ax1, label<span class="op">=</span><span class="st">'Attention Weight'</span>)</span>
<span id="cb21-680"><a href="#cb21-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-681"><a href="#cb21-681" aria-hidden="true" tabindex="-1"></a><span class="co"># Add values to cells</span></span>
<span id="cb21-682"><a href="#cb21-682" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb21-683"><a href="#cb21-683" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>):</span>
<span id="cb21-684"><a href="#cb21-684" aria-hidden="true" tabindex="-1"></a>        text <span class="op">=</span> ax1.text(j, i, <span class="ss">f'</span><span class="sc">{</span>full_attention[i, j]<span class="sc">:.2f}</span><span class="ss">'</span>,</span>
<span id="cb21-685"><a href="#cb21-685" aria-hidden="true" tabindex="-1"></a>                       ha<span class="op">=</span><span class="st">"center"</span>, va<span class="op">=</span><span class="st">"center"</span>, color<span class="op">=</span><span class="st">"white"</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-686"><a href="#cb21-686" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-687"><a href="#cb21-687" aria-hidden="true" tabindex="-1"></a><span class="co"># Show transformation</span></span>
<span id="cb21-688"><a href="#cb21-688" aria-hidden="true" tabindex="-1"></a>ax2.bar(<span class="bu">range</span>(<span class="dv">4</span>), sequence[:, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'Original (dim 0)'</span>)</span>
<span id="cb21-689"><a href="#cb21-689" aria-hidden="true" tabindex="-1"></a>ax2.bar(<span class="bu">range</span>(<span class="dv">4</span>), outputs[:, <span class="dv">0</span>], alpha<span class="op">=</span><span class="fl">0.5</span>, label<span class="op">=</span><span class="st">'After attention (dim 0)'</span>)</span>
<span id="cb21-690"><a href="#cb21-690" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Token Representations</span><span class="ch">\n</span><span class="st">(First dimension)'</span>, </span>
<span id="cb21-691"><a href="#cb21-691" aria-hidden="true" tabindex="-1"></a>              fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-692"><a href="#cb21-692" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Token'</span>)</span>
<span id="cb21-693"><a href="#cb21-693" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Value'</span>)</span>
<span id="cb21-694"><a href="#cb21-694" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb21-695"><a href="#cb21-695" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb21-696"><a href="#cb21-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-697"><a href="#cb21-697" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb21-698"><a href="#cb21-698" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb21-699"><a href="#cb21-699" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-700"><a href="#cb21-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-701"><a href="#cb21-701" aria-hidden="true" tabindex="-1"></a>**What to notice:** The attention matrix shows which tokens influence each other. Diagonal values are often high (tokens attend to themselves), but off-diagonal values capture contextual relationships.</span>
<span id="cb21-702"><a href="#cb21-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-703"><a href="#cb21-703" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multi-Head Attention</span></span>
<span id="cb21-704"><a href="#cb21-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-705"><a href="#cb21-705" aria-hidden="true" tabindex="-1"></a>Transformers use **multiple attention heads** to capture different types of relationships simultaneously.</span>
<span id="cb21-706"><a href="#cb21-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-709"><a href="#cb21-709" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-710"><a href="#cb21-710" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 10</span></span>
<span id="cb21-711"><a href="#cb21-711" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Multi-Head Attention Architecture"</span></span>
<span id="cb21-712"><a href="#cb21-712" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TB</span></span>
<span id="cb21-713"><a href="#cb21-713" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph input_seq["Input Sequence (d_model = 512)"]</span></span>
<span id="cb21-714"><a href="#cb21-714" aria-hidden="true" tabindex="-1"></a><span class="in">        seq["Token 1, Token 2, ..., Token n"]</span></span>
<span id="cb21-715"><a href="#cb21-715" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-716"><a href="#cb21-716" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-717"><a href="#cb21-717" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph linear_proj["Linear Projections"]</span></span>
<span id="cb21-718"><a href="#cb21-718" aria-hidden="true" tabindex="-1"></a><span class="in">        wq["W_Q"]</span></span>
<span id="cb21-719"><a href="#cb21-719" aria-hidden="true" tabindex="-1"></a><span class="in">        wk["W_K"]</span></span>
<span id="cb21-720"><a href="#cb21-720" aria-hidden="true" tabindex="-1"></a><span class="in">        wv["W_V"]</span></span>
<span id="cb21-721"><a href="#cb21-721" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-722"><a href="#cb21-722" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-723"><a href="#cb21-723" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph heads["Split into Multiple Heads (e.g., 8 heads × 64 dims)"]</span></span>
<span id="cb21-724"><a href="#cb21-724" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-725"><a href="#cb21-725" aria-hidden="true" tabindex="-1"></a><span class="in">        head1["Head 1&lt;br/&gt;🔵&lt;br/&gt;Attends to&lt;br/&gt;Syntax"]</span></span>
<span id="cb21-726"><a href="#cb21-726" aria-hidden="true" tabindex="-1"></a><span class="in">        head2["Head 2&lt;br/&gt;🟢&lt;br/&gt;Attends to&lt;br/&gt;Semantics"]</span></span>
<span id="cb21-727"><a href="#cb21-727" aria-hidden="true" tabindex="-1"></a><span class="in">        head3["Head 3&lt;br/&gt;🟡&lt;br/&gt;Attends to&lt;br/&gt;Position"]</span></span>
<span id="cb21-728"><a href="#cb21-728" aria-hidden="true" tabindex="-1"></a><span class="in">        dots["..."]</span></span>
<span id="cb21-729"><a href="#cb21-729" aria-hidden="true" tabindex="-1"></a><span class="in">        head8["Head 8&lt;br/&gt;🔴&lt;br/&gt;Attends to&lt;br/&gt;Context"]</span></span>
<span id="cb21-730"><a href="#cb21-730" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-731"><a href="#cb21-731" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-732"><a href="#cb21-732" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph attention_ops["Parallel Attention Operations"]</span></span>
<span id="cb21-733"><a href="#cb21-733" aria-hidden="true" tabindex="-1"></a><span class="in">        att1["Attention&lt;br/&gt;Computation"]</span></span>
<span id="cb21-734"><a href="#cb21-734" aria-hidden="true" tabindex="-1"></a><span class="in">        att2["Attention&lt;br/&gt;Computation"]</span></span>
<span id="cb21-735"><a href="#cb21-735" aria-hidden="true" tabindex="-1"></a><span class="in">        att3["Attention&lt;br/&gt;Computation"]</span></span>
<span id="cb21-736"><a href="#cb21-736" aria-hidden="true" tabindex="-1"></a><span class="in">        att4["Attention&lt;br/&gt;Computation"]</span></span>
<span id="cb21-737"><a href="#cb21-737" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-738"><a href="#cb21-738" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-739"><a href="#cb21-739" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph concat["Concatenate Heads"]</span></span>
<span id="cb21-740"><a href="#cb21-740" aria-hidden="true" tabindex="-1"></a><span class="in">        combined["Combined Output&lt;br/&gt;(8 heads × 64 = 512 dims)"]</span></span>
<span id="cb21-741"><a href="#cb21-741" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-742"><a href="#cb21-742" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-743"><a href="#cb21-743" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph final["Final Projection"]</span></span>
<span id="cb21-744"><a href="#cb21-744" aria-hidden="true" tabindex="-1"></a><span class="in">        wo["W_O&lt;br/&gt;(512 × 512)"]</span></span>
<span id="cb21-745"><a href="#cb21-745" aria-hidden="true" tabindex="-1"></a><span class="in">        output["Context-Aware&lt;br/&gt;Representations"]</span></span>
<span id="cb21-746"><a href="#cb21-746" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-747"><a href="#cb21-747" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-748"><a href="#cb21-748" aria-hidden="true" tabindex="-1"></a><span class="in">    seq --&gt; linear_proj</span></span>
<span id="cb21-749"><a href="#cb21-749" aria-hidden="true" tabindex="-1"></a><span class="in">    linear_proj --&gt; heads</span></span>
<span id="cb21-750"><a href="#cb21-750" aria-hidden="true" tabindex="-1"></a><span class="in">    head1 --&gt; att1</span></span>
<span id="cb21-751"><a href="#cb21-751" aria-hidden="true" tabindex="-1"></a><span class="in">    head2 --&gt; att2</span></span>
<span id="cb21-752"><a href="#cb21-752" aria-hidden="true" tabindex="-1"></a><span class="in">    head3 --&gt; att3</span></span>
<span id="cb21-753"><a href="#cb21-753" aria-hidden="true" tabindex="-1"></a><span class="in">    head8 --&gt; att4</span></span>
<span id="cb21-754"><a href="#cb21-754" aria-hidden="true" tabindex="-1"></a><span class="in">    att1 &amp; att2 &amp; att3 &amp; att4 --&gt; combined</span></span>
<span id="cb21-755"><a href="#cb21-755" aria-hidden="true" tabindex="-1"></a><span class="in">    combined --&gt; wo</span></span>
<span id="cb21-756"><a href="#cb21-756" aria-hidden="true" tabindex="-1"></a><span class="in">    wo --&gt; output</span></span>
<span id="cb21-757"><a href="#cb21-757" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-758"><a href="#cb21-758" aria-hidden="true" tabindex="-1"></a><span class="in">    style input_seq fill:#e1f5ff</span></span>
<span id="cb21-759"><a href="#cb21-759" aria-hidden="true" tabindex="-1"></a><span class="in">    style linear_proj fill:#fff3e1</span></span>
<span id="cb21-760"><a href="#cb21-760" aria-hidden="true" tabindex="-1"></a><span class="in">    style heads fill:#f0e1ff</span></span>
<span id="cb21-761"><a href="#cb21-761" aria-hidden="true" tabindex="-1"></a><span class="in">    style attention_ops fill:#ffe1f0</span></span>
<span id="cb21-762"><a href="#cb21-762" aria-hidden="true" tabindex="-1"></a><span class="in">    style concat fill:#e1ffe8</span></span>
<span id="cb21-763"><a href="#cb21-763" aria-hidden="true" tabindex="-1"></a><span class="in">    style final fill:#e1ffe1</span></span>
<span id="cb21-764"><a href="#cb21-764" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-765"><a href="#cb21-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-766"><a href="#cb21-766" aria-hidden="true" tabindex="-1"></a>**Key insight**: Multiple heads can learn different attention patterns - some might focus on nearby words, others on distant relationships, enabling richer representations.</span>
<span id="cb21-767"><a href="#cb21-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-770"><a href="#cb21-770" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-771"><a href="#cb21-771" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MultiHeadAttention:</span>
<span id="cb21-772"><a href="#cb21-772" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Multi-head attention mechanism."""</span></span>
<span id="cb21-773"><a href="#cb21-773" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-774"><a href="#cb21-774" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d_model, n_heads):</span>
<span id="cb21-775"><a href="#cb21-775" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-776"><a href="#cb21-776" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-777"><a href="#cb21-777" aria-hidden="true" tabindex="-1"></a><span class="co">            d_model: dimension of the model (e.g., 512)</span></span>
<span id="cb21-778"><a href="#cb21-778" aria-hidden="true" tabindex="-1"></a><span class="co">            n_heads: number of attention heads (e.g., 8)</span></span>
<span id="cb21-779"><a href="#cb21-779" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-780"><a href="#cb21-780" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.n_heads <span class="op">=</span> n_heads</span>
<span id="cb21-781"><a href="#cb21-781" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.d_model <span class="op">=</span> d_model</span>
<span id="cb21-782"><a href="#cb21-782" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.d_k <span class="op">=</span> d_model <span class="op">//</span> n_heads  <span class="co"># dimension per head</span></span>
<span id="cb21-783"><a href="#cb21-783" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-784"><a href="#cb21-784" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Linear projections for Q, K, V</span></span>
<span id="cb21-785"><a href="#cb21-785" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_q <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb21-786"><a href="#cb21-786" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_k <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb21-787"><a href="#cb21-787" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_v <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb21-788"><a href="#cb21-788" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W_o <span class="op">=</span> np.random.randn(d_model, d_model) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb21-789"><a href="#cb21-789" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-790"><a href="#cb21-790" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> split_heads(<span class="va">self</span>, x):</span>
<span id="cb21-791"><a href="#cb21-791" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Split the last dimension into (n_heads, d_k)."""</span></span>
<span id="cb21-792"><a href="#cb21-792" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, d_model <span class="op">=</span> x.shape</span>
<span id="cb21-793"><a href="#cb21-793" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reshape to (batch_size, seq_len, n_heads, d_k)</span></span>
<span id="cb21-794"><a href="#cb21-794" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x.reshape(batch_size, seq_len, <span class="va">self</span>.n_heads, <span class="va">self</span>.d_k)</span>
<span id="cb21-795"><a href="#cb21-795" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Transpose to (batch_size, n_heads, seq_len, d_k)</span></span>
<span id="cb21-796"><a href="#cb21-796" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x.transpose(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb21-797"><a href="#cb21-797" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-798"><a href="#cb21-798" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> attention(<span class="va">self</span>, q, k, v):</span>
<span id="cb21-799"><a href="#cb21-799" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Scaled dot-product attention."""</span></span>
<span id="cb21-800"><a href="#cb21-800" aria-hidden="true" tabindex="-1"></a>        d_k <span class="op">=</span> q.shape[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb21-801"><a href="#cb21-801" aria-hidden="true" tabindex="-1"></a>        scores <span class="op">=</span> np.matmul(q, k.transpose(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)) <span class="op">/</span> np.sqrt(d_k)</span>
<span id="cb21-802"><a href="#cb21-802" aria-hidden="true" tabindex="-1"></a>        attention_weights <span class="op">=</span> np.exp(scores) <span class="op">/</span> np.exp(scores).<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-803"><a href="#cb21-803" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> np.matmul(attention_weights, v)</span>
<span id="cb21-804"><a href="#cb21-804" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attention_weights</span>
<span id="cb21-805"><a href="#cb21-805" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-806"><a href="#cb21-806" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb21-807"><a href="#cb21-807" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-808"><a href="#cb21-808" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass.</span></span>
<span id="cb21-809"><a href="#cb21-809" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-810"><a href="#cb21-810" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-811"><a href="#cb21-811" aria-hidden="true" tabindex="-1"></a><span class="co">            x: input tensor of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb21-812"><a href="#cb21-812" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-813"><a href="#cb21-813" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb21-814"><a href="#cb21-814" aria-hidden="true" tabindex="-1"></a><span class="co">            output of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb21-815"><a href="#cb21-815" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-816"><a href="#cb21-816" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, _ <span class="op">=</span> x.shape</span>
<span id="cb21-817"><a href="#cb21-817" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-818"><a href="#cb21-818" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Linear projections</span></span>
<span id="cb21-819"><a href="#cb21-819" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_q)</span>
<span id="cb21-820"><a href="#cb21-820" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_k)</span>
<span id="cb21-821"><a href="#cb21-821" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> np.dot(x, <span class="va">self</span>.W_v)</span>
<span id="cb21-822"><a href="#cb21-822" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-823"><a href="#cb21-823" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Split into multiple heads</span></span>
<span id="cb21-824"><a href="#cb21-824" aria-hidden="true" tabindex="-1"></a>        q <span class="op">=</span> <span class="va">self</span>.split_heads(q.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb21-825"><a href="#cb21-825" aria-hidden="true" tabindex="-1"></a>        k <span class="op">=</span> <span class="va">self</span>.split_heads(k.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb21-826"><a href="#cb21-826" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="va">self</span>.split_heads(v.reshape(batch_size, seq_len, <span class="va">self</span>.d_model))</span>
<span id="cb21-827"><a href="#cb21-827" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-828"><a href="#cb21-828" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply attention</span></span>
<span id="cb21-829"><a href="#cb21-829" aria-hidden="true" tabindex="-1"></a>        attended, attention_weights <span class="op">=</span> <span class="va">self</span>.attention(q, k, v)</span>
<span id="cb21-830"><a href="#cb21-830" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-831"><a href="#cb21-831" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Concatenate heads</span></span>
<span id="cb21-832"><a href="#cb21-832" aria-hidden="true" tabindex="-1"></a>        attended <span class="op">=</span> attended.transpose(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>)</span>
<span id="cb21-833"><a href="#cb21-833" aria-hidden="true" tabindex="-1"></a>        concatenated <span class="op">=</span> attended.reshape(batch_size, seq_len, <span class="va">self</span>.d_model)</span>
<span id="cb21-834"><a href="#cb21-834" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-835"><a href="#cb21-835" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Final linear projection</span></span>
<span id="cb21-836"><a href="#cb21-836" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> np.dot(concatenated, <span class="va">self</span>.W_o)</span>
<span id="cb21-837"><a href="#cb21-837" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-838"><a href="#cb21-838" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attention_weights</span>
<span id="cb21-839"><a href="#cb21-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-840"><a href="#cb21-840" aria-hidden="true" tabindex="-1"></a><span class="co"># Create multi-head attention</span></span>
<span id="cb21-841"><a href="#cb21-841" aria-hidden="true" tabindex="-1"></a>d_model <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb21-842"><a href="#cb21-842" aria-hidden="true" tabindex="-1"></a>n_heads <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb21-843"><a href="#cb21-843" aria-hidden="true" tabindex="-1"></a>mha <span class="op">=</span> MultiHeadAttention(d_model, n_heads)</span>
<span id="cb21-844"><a href="#cb21-844" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-845"><a href="#cb21-845" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a sequence</span></span>
<span id="cb21-846"><a href="#cb21-846" aria-hidden="true" tabindex="-1"></a>batch_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb21-847"><a href="#cb21-847" aria-hidden="true" tabindex="-1"></a>seq_len <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb21-848"><a href="#cb21-848" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.random.randn(batch_size, seq_len, d_model)</span>
<span id="cb21-849"><a href="#cb21-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-850"><a href="#cb21-850" aria-hidden="true" tabindex="-1"></a>output, attention_weights <span class="op">=</span> mha.forward(x)</span>
<span id="cb21-851"><a href="#cb21-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-852"><a href="#cb21-852" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>x<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-853"><a href="#cb21-853" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-854"><a href="#cb21-854" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Attention weights shape: </span><span class="sc">{</span>attention_weights<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-855"><a href="#cb21-855" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Number of heads: </span><span class="sc">{</span>n_heads<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-856"><a href="#cb21-856" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Each head attends to sequence of length: </span><span class="sc">{</span>seq_len<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-857"><a href="#cb21-857" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-858"><a href="#cb21-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-859"><a href="#cb21-859" aria-hidden="true" tabindex="-1"></a>**What to notice:** </span>
<span id="cb21-860"><a href="#cb21-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-861"><a href="#cb21-861" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Each head learns different attention patterns</span>
<span id="cb21-862"><a href="#cb21-862" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiple heads capture multiple types of relationships simultaneously</span>
<span id="cb21-863"><a href="#cb21-863" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This is much more powerful than single-head attention</span>
<span id="cb21-864"><a href="#cb21-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-865"><a href="#cb21-865" aria-hidden="true" tabindex="-1"></a><span class="fu">### How Attention Changes Encodings</span></span>
<span id="cb21-866"><a href="#cb21-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-867"><a href="#cb21-867" aria-hidden="true" tabindex="-1"></a>Let's see how attention modifies representations compared to a simple feedforward layer:</span>
<span id="cb21-868"><a href="#cb21-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-871"><a href="#cb21-871" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-872"><a href="#cb21-872" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 12</span></span>
<span id="cb21-873"><a href="#cb21-873" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Feedforward vs Attention: The Key Difference"</span></span>
<span id="cb21-874"><a href="#cb21-874" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TB</span></span>
<span id="cb21-875"><a href="#cb21-875" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph comparison["Processing Paradigms"]</span></span>
<span id="cb21-876"><a href="#cb21-876" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-877"><a href="#cb21-877" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb21-878"><a href="#cb21-878" aria-hidden="true" tabindex="-1"></a><span class="in">        subgraph ff["Feedforward Network"]</span></span>
<span id="cb21-879"><a href="#cb21-879" aria-hidden="true" tabindex="-1"></a><span class="in">            direction TB</span></span>
<span id="cb21-880"><a href="#cb21-880" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_input["Token 1 | Token 2 | Token 3 | Token 4"]</span></span>
<span id="cb21-881"><a href="#cb21-881" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_process["↓ Independent Processing ↓"]</span></span>
<span id="cb21-882"><a href="#cb21-882" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_layer["Layer applies SAME transformation&lt;br/&gt;to each position separately"]</span></span>
<span id="cb21-883"><a href="#cb21-883" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_output["Output 1 | Output 2 | Output 3 | Output 4"]</span></span>
<span id="cb21-884"><a href="#cb21-884" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_note["❌ No communication between positions"]</span></span>
<span id="cb21-885"><a href="#cb21-885" aria-hidden="true" tabindex="-1"></a><span class="in">            </span></span>
<span id="cb21-886"><a href="#cb21-886" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_input --&gt; ff_process</span></span>
<span id="cb21-887"><a href="#cb21-887" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_process --&gt; ff_layer</span></span>
<span id="cb21-888"><a href="#cb21-888" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_layer --&gt; ff_output</span></span>
<span id="cb21-889"><a href="#cb21-889" aria-hidden="true" tabindex="-1"></a><span class="in">            ff_output --&gt; ff_note</span></span>
<span id="cb21-890"><a href="#cb21-890" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb21-891"><a href="#cb21-891" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb21-892"><a href="#cb21-892" aria-hidden="true" tabindex="-1"></a><span class="in">        subgraph attn["Attention Network"]</span></span>
<span id="cb21-893"><a href="#cb21-893" aria-hidden="true" tabindex="-1"></a><span class="in">            direction TB</span></span>
<span id="cb21-894"><a href="#cb21-894" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_input["Token 1 | Token 2 | Token 3 | Token 4"]</span></span>
<span id="cb21-895"><a href="#cb21-895" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_process["↓ Context-Aware Processing ↓"]</span></span>
<span id="cb21-896"><a href="#cb21-896" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_layer["Each position looks at ALL positions&lt;br/&gt;Weighted combination based on relevance"]</span></span>
<span id="cb21-897"><a href="#cb21-897" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_output["Output 1 | Output 2 | Output 3 | Output 4"]</span></span>
<span id="cb21-898"><a href="#cb21-898" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_note["✅ Each output informed by full context"]</span></span>
<span id="cb21-899"><a href="#cb21-899" aria-hidden="true" tabindex="-1"></a><span class="in">            </span></span>
<span id="cb21-900"><a href="#cb21-900" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_input --&gt; attn_process</span></span>
<span id="cb21-901"><a href="#cb21-901" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_process --&gt; attn_layer</span></span>
<span id="cb21-902"><a href="#cb21-902" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_layer --&gt; attn_output</span></span>
<span id="cb21-903"><a href="#cb21-903" aria-hidden="true" tabindex="-1"></a><span class="in">            attn_output --&gt; attn_note</span></span>
<span id="cb21-904"><a href="#cb21-904" aria-hidden="true" tabindex="-1"></a><span class="in">        end</span></span>
<span id="cb21-905"><a href="#cb21-905" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-906"><a href="#cb21-906" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-907"><a href="#cb21-907" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph examples["Real-World Example"]</span></span>
<span id="cb21-908"><a href="#cb21-908" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb21-909"><a href="#cb21-909" aria-hidden="true" tabindex="-1"></a><span class="in">        sentence["'The animal didn't cross the street because it was too tired'"]</span></span>
<span id="cb21-910"><a href="#cb21-910" aria-hidden="true" tabindex="-1"></a><span class="in">        ff_ex["Feedforward: 'it' processed in isolation&lt;br/&gt;❌ Can't determine if 'it' = animal or street"]</span></span>
<span id="cb21-911"><a href="#cb21-911" aria-hidden="true" tabindex="-1"></a><span class="in">        attn_ex["Attention: 'it' attends to all words&lt;br/&gt;✅ Learns 'it' → 'animal' (via context)"]</span></span>
<span id="cb21-912"><a href="#cb21-912" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb21-913"><a href="#cb21-913" aria-hidden="true" tabindex="-1"></a><span class="in">        sentence --&gt; ff_ex</span></span>
<span id="cb21-914"><a href="#cb21-914" aria-hidden="true" tabindex="-1"></a><span class="in">        sentence --&gt; attn_ex</span></span>
<span id="cb21-915"><a href="#cb21-915" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-916"><a href="#cb21-916" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-917"><a href="#cb21-917" aria-hidden="true" tabindex="-1"></a><span class="in">    style ff fill:#ffe1e1</span></span>
<span id="cb21-918"><a href="#cb21-918" aria-hidden="true" tabindex="-1"></a><span class="in">    style attn fill:#e1ffe1</span></span>
<span id="cb21-919"><a href="#cb21-919" aria-hidden="true" tabindex="-1"></a><span class="in">    style ff_note fill:#ffcccc</span></span>
<span id="cb21-920"><a href="#cb21-920" aria-hidden="true" tabindex="-1"></a><span class="in">    style attn_note fill:#ccffcc</span></span>
<span id="cb21-921"><a href="#cb21-921" aria-hidden="true" tabindex="-1"></a><span class="in">    style examples fill:#fff9e1</span></span>
<span id="cb21-922"><a href="#cb21-922" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-923"><a href="#cb21-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-924"><a href="#cb21-924" aria-hidden="true" tabindex="-1"></a>**Why this is revolutionary**: Attention allows the network to dynamically route information based on context, rather than applying fixed transformations. This is essential for understanding language, time series, and sequential data where relationships between elements matter.</span>
<span id="cb21-925"><a href="#cb21-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-928"><a href="#cb21-928" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-929"><a href="#cb21-929" aria-hidden="true" tabindex="-1"></a><span class="co"># Create sample sequence data</span></span>
<span id="cb21-930"><a href="#cb21-930" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb21-931"><a href="#cb21-931" aria-hidden="true" tabindex="-1"></a>seq_length <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb21-932"><a href="#cb21-932" aria-hidden="true" tabindex="-1"></a>d_model <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb21-933"><a href="#cb21-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-934"><a href="#cb21-934" aria-hidden="true" tabindex="-1"></a><span class="co"># Input sequence</span></span>
<span id="cb21-935"><a href="#cb21-935" aria-hidden="true" tabindex="-1"></a>input_seq <span class="op">=</span> np.random.randn(<span class="dv">1</span>, seq_length, d_model)</span>
<span id="cb21-936"><a href="#cb21-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-937"><a href="#cb21-937" aria-hidden="true" tabindex="-1"></a><span class="co"># Option 1: Process with feedforward layer (no attention)</span></span>
<span id="cb21-938"><a href="#cb21-938" aria-hidden="true" tabindex="-1"></a>ff_layer <span class="op">=</span> NeuralLayer(d_model, d_model)</span>
<span id="cb21-939"><a href="#cb21-939" aria-hidden="true" tabindex="-1"></a>ff_output <span class="op">=</span> ff_layer.forward(input_seq.reshape(<span class="op">-</span><span class="dv">1</span>, d_model), activation_fn<span class="op">=</span>relu)</span>
<span id="cb21-940"><a href="#cb21-940" aria-hidden="true" tabindex="-1"></a>ff_output <span class="op">=</span> ff_output.reshape(<span class="dv">1</span>, seq_length, d_model)</span>
<span id="cb21-941"><a href="#cb21-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-942"><a href="#cb21-942" aria-hidden="true" tabindex="-1"></a><span class="co"># Option 2: Process with attention</span></span>
<span id="cb21-943"><a href="#cb21-943" aria-hidden="true" tabindex="-1"></a>mha <span class="op">=</span> MultiHeadAttention(d_model, n_heads<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-944"><a href="#cb21-944" aria-hidden="true" tabindex="-1"></a>attn_output, attn_weights <span class="op">=</span> mha.forward(input_seq)</span>
<span id="cb21-945"><a href="#cb21-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-946"><a href="#cb21-946" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the difference</span></span>
<span id="cb21-947"><a href="#cb21-947" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb21-948"><a href="#cb21-948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-949"><a href="#cb21-949" aria-hidden="true" tabindex="-1"></a><span class="co"># Input</span></span>
<span id="cb21-950"><a href="#cb21-950" aria-hidden="true" tabindex="-1"></a>im0 <span class="op">=</span> axes[<span class="dv">0</span>].imshow(input_seq[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-951"><a href="#cb21-951" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_title(<span class="st">'Input Sequence'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-952"><a href="#cb21-952" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb21-953"><a href="#cb21-953" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">0</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb21-954"><a href="#cb21-954" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im0, ax<span class="op">=</span>axes[<span class="dv">0</span>])</span>
<span id="cb21-955"><a href="#cb21-955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-956"><a href="#cb21-956" aria-hidden="true" tabindex="-1"></a><span class="co"># Feedforward output</span></span>
<span id="cb21-957"><a href="#cb21-957" aria-hidden="true" tabindex="-1"></a>im1 <span class="op">=</span> axes[<span class="dv">1</span>].imshow(ff_output[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-958"><a href="#cb21-958" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_title(<span class="st">'After Feedforward Layer</span><span class="ch">\n</span><span class="st">(No attention)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-959"><a href="#cb21-959" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb21-960"><a href="#cb21-960" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">1</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb21-961"><a href="#cb21-961" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im1, ax<span class="op">=</span>axes[<span class="dv">1</span>])</span>
<span id="cb21-962"><a href="#cb21-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-963"><a href="#cb21-963" aria-hidden="true" tabindex="-1"></a><span class="co"># Attention output</span></span>
<span id="cb21-964"><a href="#cb21-964" aria-hidden="true" tabindex="-1"></a>im2 <span class="op">=</span> axes[<span class="dv">2</span>].imshow(attn_output[<span class="dv">0</span>].T, cmap<span class="op">=</span><span class="st">'RdBu'</span>, aspect<span class="op">=</span><span class="st">'auto'</span>, vmin<span class="op">=-</span><span class="dv">2</span>, vmax<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-965"><a href="#cb21-965" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_title(<span class="st">'After Multi-Head Attention</span><span class="ch">\n</span><span class="st">(Context-aware)'</span>, fontsize<span class="op">=</span><span class="dv">12</span>, fontweight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb21-966"><a href="#cb21-966" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_xlabel(<span class="st">'Position in Sequence'</span>)</span>
<span id="cb21-967"><a href="#cb21-967" aria-hidden="true" tabindex="-1"></a>axes[<span class="dv">2</span>].set_ylabel(<span class="st">'Feature Dimension'</span>)</span>
<span id="cb21-968"><a href="#cb21-968" aria-hidden="true" tabindex="-1"></a>plt.colorbar(im2, ax<span class="op">=</span>axes[<span class="dv">2</span>])</span>
<span id="cb21-969"><a href="#cb21-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-970"><a href="#cb21-970" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb21-971"><a href="#cb21-971" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb21-972"><a href="#cb21-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-973"><a href="#cb21-973" aria-hidden="true" tabindex="-1"></a><span class="co"># Show how representations relate to each other</span></span>
<span id="cb21-974"><a href="#cb21-974" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Cosine similarity between position encodings:</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb21-975"><a href="#cb21-975" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Feedforward (independent processing):"</span>)</span>
<span id="cb21-976"><a href="#cb21-976" aria-hidden="true" tabindex="-1"></a>ff_norm <span class="op">=</span> ff_output[<span class="dv">0</span>] <span class="op">/</span> np.linalg.norm(ff_output[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-977"><a href="#cb21-977" aria-hidden="true" tabindex="-1"></a>ff_similarity <span class="op">=</span> np.dot(ff_norm, ff_norm.T)</span>
<span id="cb21-978"><a href="#cb21-978" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average off-diagonal similarity: </span><span class="sc">{</span>(ff_similarity.<span class="bu">sum</span>() <span class="op">-</span> seq_length) <span class="op">/</span> (seq_length <span class="op">*</span> (seq_length <span class="op">-</span> <span class="dv">1</span>))<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-979"><a href="#cb21-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-980"><a href="#cb21-980" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Attention (context-aware processing):"</span>)</span>
<span id="cb21-981"><a href="#cb21-981" aria-hidden="true" tabindex="-1"></a>attn_norm <span class="op">=</span> attn_output[<span class="dv">0</span>] <span class="op">/</span> np.linalg.norm(attn_output[<span class="dv">0</span>], axis<span class="op">=</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb21-982"><a href="#cb21-982" aria-hidden="true" tabindex="-1"></a>attn_similarity <span class="op">=</span> np.dot(attn_norm, attn_norm.T)</span>
<span id="cb21-983"><a href="#cb21-983" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Average off-diagonal similarity: </span><span class="sc">{</span>(attn_similarity.<span class="bu">sum</span>() <span class="op">-</span> seq_length) <span class="op">/</span> (seq_length <span class="op">*</span> (seq_length <span class="op">-</span> <span class="dv">1</span>))<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb21-984"><a href="#cb21-984" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-985"><a href="#cb21-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-986"><a href="#cb21-986" aria-hidden="true" tabindex="-1"></a>**Why this matters:** </span>
<span id="cb21-987"><a href="#cb21-987" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-988"><a href="#cb21-988" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Feedforward layers** process each position independently - no position "knows" about others</span>
<span id="cb21-989"><a href="#cb21-989" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Attention layers** mix information across positions - each position is informed by context</span>
<span id="cb21-990"><a href="#cb21-990" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This context-awareness is crucial for sequential data like language, time series, or video</span>
<span id="cb21-991"><a href="#cb21-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-992"><a href="#cb21-992" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-993"><a href="#cb21-993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-994"><a href="#cb21-994" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 4: Putting It All Together - The Transformer Block</span></span>
<span id="cb21-995"><a href="#cb21-995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-996"><a href="#cb21-996" aria-hidden="true" tabindex="-1"></a>A complete transformer block combines attention with feedforward layers:</span>
<span id="cb21-997"><a href="#cb21-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1000"><a href="#cb21-1000" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-1001"><a href="#cb21-1001" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 8</span></span>
<span id="cb21-1002"><a href="#cb21-1002" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "Complete Transformer Block Architecture"</span></span>
<span id="cb21-1003"><a href="#cb21-1003" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TB</span></span>
<span id="cb21-1004"><a href="#cb21-1004" aria-hidden="true" tabindex="-1"></a><span class="in">    input["Input&lt;br/&gt;(Sequence of Embeddings)"]</span></span>
<span id="cb21-1005"><a href="#cb21-1005" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1006"><a href="#cb21-1006" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph mha_block["Multi-Head Attention Block"]</span></span>
<span id="cb21-1007"><a href="#cb21-1007" aria-hidden="true" tabindex="-1"></a><span class="in">        mha["Multi-Head&lt;br/&gt;Attention"]</span></span>
<span id="cb21-1008"><a href="#cb21-1008" aria-hidden="true" tabindex="-1"></a><span class="in">        add1["Add"]</span></span>
<span id="cb21-1009"><a href="#cb21-1009" aria-hidden="true" tabindex="-1"></a><span class="in">        norm1["Layer Norm"]</span></span>
<span id="cb21-1010"><a href="#cb21-1010" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1011"><a href="#cb21-1011" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1012"><a href="#cb21-1012" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph ff_block["Feedforward Block"]</span></span>
<span id="cb21-1013"><a href="#cb21-1013" aria-hidden="true" tabindex="-1"></a><span class="in">        ff1["Linear&lt;br/&gt;(expand)"]</span></span>
<span id="cb21-1014"><a href="#cb21-1014" aria-hidden="true" tabindex="-1"></a><span class="in">        relu["ReLU"]</span></span>
<span id="cb21-1015"><a href="#cb21-1015" aria-hidden="true" tabindex="-1"></a><span class="in">        ff2["Linear&lt;br/&gt;(project)"]</span></span>
<span id="cb21-1016"><a href="#cb21-1016" aria-hidden="true" tabindex="-1"></a><span class="in">        add2["Add"]</span></span>
<span id="cb21-1017"><a href="#cb21-1017" aria-hidden="true" tabindex="-1"></a><span class="in">        norm2["Layer Norm"]</span></span>
<span id="cb21-1018"><a href="#cb21-1018" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1019"><a href="#cb21-1019" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1020"><a href="#cb21-1020" aria-hidden="true" tabindex="-1"></a><span class="in">    output["Output&lt;br/&gt;(Enriched Representations)"]</span></span>
<span id="cb21-1021"><a href="#cb21-1021" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1022"><a href="#cb21-1022" aria-hidden="true" tabindex="-1"></a><span class="in">    input --&gt; mha</span></span>
<span id="cb21-1023"><a href="#cb21-1023" aria-hidden="true" tabindex="-1"></a><span class="in">    input -.-&gt;|"Residual&lt;br/&gt;Connection"| add1</span></span>
<span id="cb21-1024"><a href="#cb21-1024" aria-hidden="true" tabindex="-1"></a><span class="in">    mha --&gt; add1</span></span>
<span id="cb21-1025"><a href="#cb21-1025" aria-hidden="true" tabindex="-1"></a><span class="in">    add1 --&gt; norm1</span></span>
<span id="cb21-1026"><a href="#cb21-1026" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1027"><a href="#cb21-1027" aria-hidden="true" tabindex="-1"></a><span class="in">    norm1 --&gt; ff1</span></span>
<span id="cb21-1028"><a href="#cb21-1028" aria-hidden="true" tabindex="-1"></a><span class="in">    ff1 --&gt; relu</span></span>
<span id="cb21-1029"><a href="#cb21-1029" aria-hidden="true" tabindex="-1"></a><span class="in">    relu --&gt; ff2</span></span>
<span id="cb21-1030"><a href="#cb21-1030" aria-hidden="true" tabindex="-1"></a><span class="in">    norm1 -.-&gt;|"Residual&lt;br/&gt;Connection"| add2</span></span>
<span id="cb21-1031"><a href="#cb21-1031" aria-hidden="true" tabindex="-1"></a><span class="in">    ff2 --&gt; add2</span></span>
<span id="cb21-1032"><a href="#cb21-1032" aria-hidden="true" tabindex="-1"></a><span class="in">    add2 --&gt; norm2</span></span>
<span id="cb21-1033"><a href="#cb21-1033" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1034"><a href="#cb21-1034" aria-hidden="true" tabindex="-1"></a><span class="in">    norm2 --&gt; output</span></span>
<span id="cb21-1035"><a href="#cb21-1035" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1036"><a href="#cb21-1036" aria-hidden="true" tabindex="-1"></a><span class="in">    style input fill:#e1f5ff</span></span>
<span id="cb21-1037"><a href="#cb21-1037" aria-hidden="true" tabindex="-1"></a><span class="in">    style mha_block fill:#f0e1ff</span></span>
<span id="cb21-1038"><a href="#cb21-1038" aria-hidden="true" tabindex="-1"></a><span class="in">    style ff_block fill:#ffe8e1</span></span>
<span id="cb21-1039"><a href="#cb21-1039" aria-hidden="true" tabindex="-1"></a><span class="in">    style output fill:#e1ffe1</span></span>
<span id="cb21-1040"><a href="#cb21-1040" aria-hidden="true" tabindex="-1"></a><span class="in">    style mha fill:#d8b3ff</span></span>
<span id="cb21-1041"><a href="#cb21-1041" aria-hidden="true" tabindex="-1"></a><span class="in">    style add1 fill:#ffd8b3</span></span>
<span id="cb21-1042"><a href="#cb21-1042" aria-hidden="true" tabindex="-1"></a><span class="in">    style add2 fill:#ffd8b3</span></span>
<span id="cb21-1043"><a href="#cb21-1043" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-1044"><a href="#cb21-1044" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1045"><a href="#cb21-1045" aria-hidden="true" tabindex="-1"></a>**Key components**:</span>
<span id="cb21-1046"><a href="#cb21-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1047"><a href="#cb21-1047" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Multi-Head Attention**: Mix information across positions (context)</span>
<span id="cb21-1048"><a href="#cb21-1048" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Residual Connection**: Add input back to help gradient flow</span>
<span id="cb21-1049"><a href="#cb21-1049" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Layer Normalization**: Stabilize training</span>
<span id="cb21-1050"><a href="#cb21-1050" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Feedforward Network**: Transform features independently</span>
<span id="cb21-1051"><a href="#cb21-1051" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Another Residual Connection**: More gradient flow</span>
<span id="cb21-1052"><a href="#cb21-1052" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1053"><a href="#cb21-1053" aria-hidden="true" tabindex="-1"></a>This pattern repeats for each transformer layer in a model!</span>
<span id="cb21-1054"><a href="#cb21-1054" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1057"><a href="#cb21-1057" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb21-1058"><a href="#cb21-1058" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TransformerBlock:</span>
<span id="cb21-1059"><a href="#cb21-1059" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A single transformer block with attention and feedforward."""</span></span>
<span id="cb21-1060"><a href="#cb21-1060" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-1061"><a href="#cb21-1061" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, d_model, n_heads, d_ff):</span>
<span id="cb21-1062"><a href="#cb21-1062" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-1063"><a href="#cb21-1063" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-1064"><a href="#cb21-1064" aria-hidden="true" tabindex="-1"></a><span class="co">            d_model: model dimension</span></span>
<span id="cb21-1065"><a href="#cb21-1065" aria-hidden="true" tabindex="-1"></a><span class="co">            n_heads: number of attention heads</span></span>
<span id="cb21-1066"><a href="#cb21-1066" aria-hidden="true" tabindex="-1"></a><span class="co">            d_ff: feedforward network dimension</span></span>
<span id="cb21-1067"><a href="#cb21-1067" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-1068"><a href="#cb21-1068" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.attention <span class="op">=</span> MultiHeadAttention(d_model, n_heads)</span>
<span id="cb21-1069"><a href="#cb21-1069" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff1 <span class="op">=</span> NeuralLayer(d_model, d_ff)</span>
<span id="cb21-1070"><a href="#cb21-1070" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ff2 <span class="op">=</span> NeuralLayer(d_ff, d_model)</span>
<span id="cb21-1071"><a href="#cb21-1071" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1072"><a href="#cb21-1072" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward(<span class="va">self</span>, x):</span>
<span id="cb21-1073"><a href="#cb21-1073" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-1074"><a href="#cb21-1074" aria-hidden="true" tabindex="-1"></a><span class="co">        Forward pass through transformer block.</span></span>
<span id="cb21-1075"><a href="#cb21-1075" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-1076"><a href="#cb21-1076" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-1077"><a href="#cb21-1077" aria-hidden="true" tabindex="-1"></a><span class="co">            x: input of shape (batch_size, seq_len, d_model)</span></span>
<span id="cb21-1078"><a href="#cb21-1078" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb21-1079"><a href="#cb21-1079" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb21-1080"><a href="#cb21-1080" aria-hidden="true" tabindex="-1"></a><span class="co">            output of same shape as input</span></span>
<span id="cb21-1081"><a href="#cb21-1081" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-1082"><a href="#cb21-1082" aria-hidden="true" tabindex="-1"></a>        batch_size, seq_len, d_model <span class="op">=</span> x.shape</span>
<span id="cb21-1083"><a href="#cb21-1083" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1084"><a href="#cb21-1084" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 1: Multi-head attention</span></span>
<span id="cb21-1085"><a href="#cb21-1085" aria-hidden="true" tabindex="-1"></a>        attn_out, attn_weights <span class="op">=</span> <span class="va">self</span>.attention.forward(x)</span>
<span id="cb21-1086"><a href="#cb21-1086" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1087"><a href="#cb21-1087" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 2: Add &amp; Norm (simplified - just add)</span></span>
<span id="cb21-1088"><a href="#cb21-1088" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> x <span class="op">+</span> attn_out</span>
<span id="cb21-1089"><a href="#cb21-1089" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1090"><a href="#cb21-1090" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 3: Feedforward network</span></span>
<span id="cb21-1091"><a href="#cb21-1091" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Reshape for layer processing</span></span>
<span id="cb21-1092"><a href="#cb21-1092" aria-hidden="true" tabindex="-1"></a>        x_flat <span class="op">=</span> x.reshape(<span class="op">-</span><span class="dv">1</span>, d_model)</span>
<span id="cb21-1093"><a href="#cb21-1093" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> <span class="va">self</span>.ff1.forward(x_flat, activation_fn<span class="op">=</span>relu)</span>
<span id="cb21-1094"><a href="#cb21-1094" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> <span class="va">self</span>.ff2.forward(ff_out, activation_fn<span class="op">=</span><span class="kw">lambda</span> x: x)</span>
<span id="cb21-1095"><a href="#cb21-1095" aria-hidden="true" tabindex="-1"></a>        ff_out <span class="op">=</span> ff_out.reshape(batch_size, seq_len, d_model)</span>
<span id="cb21-1096"><a href="#cb21-1096" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1097"><a href="#cb21-1097" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 4: Add &amp; Norm (simplified - just add)</span></span>
<span id="cb21-1098"><a href="#cb21-1098" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> x <span class="op">+</span> ff_out</span>
<span id="cb21-1099"><a href="#cb21-1099" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-1100"><a href="#cb21-1100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output, attn_weights</span>
<span id="cb21-1101"><a href="#cb21-1101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1102"><a href="#cb21-1102" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and test a transformer block</span></span>
<span id="cb21-1103"><a href="#cb21-1103" aria-hidden="true" tabindex="-1"></a>transformer <span class="op">=</span> TransformerBlock(d_model<span class="op">=</span><span class="dv">8</span>, n_heads<span class="op">=</span><span class="dv">2</span>, d_ff<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb21-1104"><a href="#cb21-1104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1105"><a href="#cb21-1105" aria-hidden="true" tabindex="-1"></a><span class="co"># Process a sequence</span></span>
<span id="cb21-1106"><a href="#cb21-1106" aria-hidden="true" tabindex="-1"></a>input_seq <span class="op">=</span> np.random.randn(<span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">8</span>)</span>
<span id="cb21-1107"><a href="#cb21-1107" aria-hidden="true" tabindex="-1"></a>output, attention <span class="op">=</span> transformer.forward(input_seq)</span>
<span id="cb21-1108"><a href="#cb21-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1109"><a href="#cb21-1109" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input shape: </span><span class="sc">{</span>input_seq<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-1110"><a href="#cb21-1110" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Output shape: </span><span class="sc">{</span>output<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-1111"><a href="#cb21-1111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Transformer block completed:"</span>)</span>
<span id="cb21-1112"><a href="#cb21-1112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  1. Multi-head attention (context mixing)"</span>)</span>
<span id="cb21-1113"><a href="#cb21-1113" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  2. Residual connection"</span>)</span>
<span id="cb21-1114"><a href="#cb21-1114" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  3. Feedforward network (feature transformation)"</span>)</span>
<span id="cb21-1115"><a href="#cb21-1115" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"  4. Residual connection"</span>)</span>
<span id="cb21-1116"><a href="#cb21-1116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-1117"><a href="#cb21-1117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1118"><a href="#cb21-1118" aria-hidden="true" tabindex="-1"></a>**What to notice:** The transformer combines two key ideas:</span>
<span id="cb21-1119"><a href="#cb21-1119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1120"><a href="#cb21-1120" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Attention**: Mix information across sequence positions (capture context)</span>
<span id="cb21-1121"><a href="#cb21-1121" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Feedforward**: Transform features independently at each position (extract patterns)</span>
<span id="cb21-1122"><a href="#cb21-1122" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Residual connections**: Add the input back to help gradients flow</span>
<span id="cb21-1123"><a href="#cb21-1123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1124"><a href="#cb21-1124" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-1125"><a href="#cb21-1125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1126"><a href="#cb21-1126" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary: The Neural Network Hierarchy</span></span>
<span id="cb21-1127"><a href="#cb21-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1128"><a href="#cb21-1128" aria-hidden="true" tabindex="-1"></a>Let's recap the progressive complexity:</span>
<span id="cb21-1129"><a href="#cb21-1129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1132"><a href="#cb21-1132" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb21-1133"><a href="#cb21-1133" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-width: 12</span></span>
<span id="cb21-1134"><a href="#cb21-1134" aria-hidden="true" tabindex="-1"></a><span class="in">%%| fig-cap: "The Complete Neural Network Hierarchy: From Neurons to Transformers"</span></span>
<span id="cb21-1135"><a href="#cb21-1135" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TD</span></span>
<span id="cb21-1136"><a href="#cb21-1136" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level1["Level 1: Single Neuron"]</span></span>
<span id="cb21-1137"><a href="#cb21-1137" aria-hidden="true" tabindex="-1"></a><span class="in">        n1["Weighted Sum&lt;br/&gt;+ Activation&lt;br/&gt;────&lt;br/&gt;z = Σ(wᵢxᵢ) + b&lt;br/&gt;output = f(z)"]</span></span>
<span id="cb21-1138"><a href="#cb21-1138" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1139"><a href="#cb21-1139" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1140"><a href="#cb21-1140" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level2["Level 2: Neural Layer"]</span></span>
<span id="cb21-1141"><a href="#cb21-1141" aria-hidden="true" tabindex="-1"></a><span class="in">        layer["Vectorized Operations&lt;br/&gt;────&lt;br/&gt;Multiple neurons in parallel&lt;br/&gt;Matrix: (n_in, n_out)"]</span></span>
<span id="cb21-1142"><a href="#cb21-1142" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1143"><a href="#cb21-1143" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1144"><a href="#cb21-1144" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level3["Level 3: Deep Network"]</span></span>
<span id="cb21-1145"><a href="#cb21-1145" aria-hidden="true" tabindex="-1"></a><span class="in">        deep["Stacked Layers&lt;br/&gt;────&lt;br/&gt;Input → Hidden₁ → Hidden₂ → Output&lt;br/&gt;Hierarchical features"]</span></span>
<span id="cb21-1146"><a href="#cb21-1146" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1147"><a href="#cb21-1147" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1148"><a href="#cb21-1148" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level4a["Level 4a: Attention Mechanism"]</span></span>
<span id="cb21-1149"><a href="#cb21-1149" aria-hidden="true" tabindex="-1"></a><span class="in">        attention["Query-Key-Value&lt;br/&gt;────&lt;br/&gt;Context-aware weighting&lt;br/&gt;Tokens attend to each other"]</span></span>
<span id="cb21-1150"><a href="#cb21-1150" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1151"><a href="#cb21-1151" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1152"><a href="#cb21-1152" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level4b["Level 4b: Multi-Head Attention"]</span></span>
<span id="cb21-1153"><a href="#cb21-1153" aria-hidden="true" tabindex="-1"></a><span class="in">        multihead["Parallel Attention Heads&lt;br/&gt;────&lt;br/&gt;Multiple relationship types&lt;br/&gt;8 heads × 64 dims = 512 dims"]</span></span>
<span id="cb21-1154"><a href="#cb21-1154" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1155"><a href="#cb21-1155" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1156"><a href="#cb21-1156" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level5["Level 5: Transformer Block"]</span></span>
<span id="cb21-1157"><a href="#cb21-1157" aria-hidden="true" tabindex="-1"></a><span class="in">        transformer["Complete Architecture&lt;br/&gt;────&lt;br/&gt;Multi-Head Attention&lt;br/&gt;+ Residual Connection&lt;br/&gt;+ Feedforward Network&lt;br/&gt;+ Residual Connection"]</span></span>
<span id="cb21-1158"><a href="#cb21-1158" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1159"><a href="#cb21-1159" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1160"><a href="#cb21-1160" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph level6["Level 6: Full Transformer"]</span></span>
<span id="cb21-1161"><a href="#cb21-1161" aria-hidden="true" tabindex="-1"></a><span class="in">        full["Stack of N Blocks&lt;br/&gt;────&lt;br/&gt;Block₁ → Block₂ → ... → Blockₙ&lt;br/&gt;+ Positional Encoding&lt;br/&gt;+ Output Head"]</span></span>
<span id="cb21-1162"><a href="#cb21-1162" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb21-1163"><a href="#cb21-1163" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1164"><a href="#cb21-1164" aria-hidden="true" tabindex="-1"></a><span class="in">    level1 -.-&gt;|"Parallelize"| level2</span></span>
<span id="cb21-1165"><a href="#cb21-1165" aria-hidden="true" tabindex="-1"></a><span class="in">    level2 -.-&gt;|"Stack"| level3</span></span>
<span id="cb21-1166"><a href="#cb21-1166" aria-hidden="true" tabindex="-1"></a><span class="in">    level3 -.-&gt;|"Add Context&lt;br/&gt;Awareness"| level4a</span></span>
<span id="cb21-1167"><a href="#cb21-1167" aria-hidden="true" tabindex="-1"></a><span class="in">    level4a -.-&gt;|"Multiple&lt;br/&gt;Heads"| level4b</span></span>
<span id="cb21-1168"><a href="#cb21-1168" aria-hidden="true" tabindex="-1"></a><span class="in">    level4b -.-&gt;|"+ Feedforward&lt;br/&gt;+ Residuals"| level5</span></span>
<span id="cb21-1169"><a href="#cb21-1169" aria-hidden="true" tabindex="-1"></a><span class="in">    level5 -.-&gt;|"Stack&lt;br/&gt;Layers"| level6</span></span>
<span id="cb21-1170"><a href="#cb21-1170" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1171"><a href="#cb21-1171" aria-hidden="true" tabindex="-1"></a><span class="in">    capability1["Independent&lt;br/&gt;Processing"] -.-&gt; level1</span></span>
<span id="cb21-1172"><a href="#cb21-1172" aria-hidden="true" tabindex="-1"></a><span class="in">    capability2["Batch&lt;br/&gt;Processing"] -.-&gt; level2</span></span>
<span id="cb21-1173"><a href="#cb21-1173" aria-hidden="true" tabindex="-1"></a><span class="in">    capability3["Hierarchical&lt;br/&gt;Features"] -.-&gt; level3</span></span>
<span id="cb21-1174"><a href="#cb21-1174" aria-hidden="true" tabindex="-1"></a><span class="in">    capability4["Sequential&lt;br/&gt;Dependencies"] -.-&gt; level4a</span></span>
<span id="cb21-1175"><a href="#cb21-1175" aria-hidden="true" tabindex="-1"></a><span class="in">    capability5["Rich&lt;br/&gt;Relationships"] -.-&gt; level4b</span></span>
<span id="cb21-1176"><a href="#cb21-1176" aria-hidden="true" tabindex="-1"></a><span class="in">    capability6["Stable Deep&lt;br/&gt;Learning"] -.-&gt; level5</span></span>
<span id="cb21-1177"><a href="#cb21-1177" aria-hidden="true" tabindex="-1"></a><span class="in">    capability7["Complex&lt;br/&gt;Understanding"] -.-&gt; level6</span></span>
<span id="cb21-1178"><a href="#cb21-1178" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1179"><a href="#cb21-1179" aria-hidden="true" tabindex="-1"></a><span class="in">    style level1 fill:#e1f5ff</span></span>
<span id="cb21-1180"><a href="#cb21-1180" aria-hidden="true" tabindex="-1"></a><span class="in">    style level2 fill:#e8f0ff</span></span>
<span id="cb21-1181"><a href="#cb21-1181" aria-hidden="true" tabindex="-1"></a><span class="in">    style level3 fill:#e8e5ff</span></span>
<span id="cb21-1182"><a href="#cb21-1182" aria-hidden="true" tabindex="-1"></a><span class="in">    style level4a fill:#f0e1ff</span></span>
<span id="cb21-1183"><a href="#cb21-1183" aria-hidden="true" tabindex="-1"></a><span class="in">    style level4b fill:#f8e1ff</span></span>
<span id="cb21-1184"><a href="#cb21-1184" aria-hidden="true" tabindex="-1"></a><span class="in">    style level5 fill:#ffe1f0</span></span>
<span id="cb21-1185"><a href="#cb21-1185" aria-hidden="true" tabindex="-1"></a><span class="in">    style level6 fill:#ffe1e1</span></span>
<span id="cb21-1186"><a href="#cb21-1186" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb21-1187"><a href="#cb21-1187" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability1 fill:#fff9e1</span></span>
<span id="cb21-1188"><a href="#cb21-1188" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability2 fill:#fff9e1</span></span>
<span id="cb21-1189"><a href="#cb21-1189" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability3 fill:#fff9e1</span></span>
<span id="cb21-1190"><a href="#cb21-1190" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability4 fill:#fff9e1</span></span>
<span id="cb21-1191"><a href="#cb21-1191" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability5 fill:#fff9e1</span></span>
<span id="cb21-1192"><a href="#cb21-1192" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability6 fill:#fff9e1</span></span>
<span id="cb21-1193"><a href="#cb21-1193" aria-hidden="true" tabindex="-1"></a><span class="in">    style capability7 fill:#fff9e1</span></span>
<span id="cb21-1194"><a href="#cb21-1194" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb21-1195"><a href="#cb21-1195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1196"><a href="#cb21-1196" aria-hidden="true" tabindex="-1"></a><span class="fu">### Level 1: Single Neuron</span></span>
<span id="cb21-1197"><a href="#cb21-1197" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Computes weighted sum of inputs</span>
<span id="cb21-1198"><a href="#cb21-1198" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Applies activation function (e.g., ReLU)</span>
<span id="cb21-1199"><a href="#cb21-1199" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Transforms: scalar inputs → scalar output</span>
<span id="cb21-1200"><a href="#cb21-1200" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Key insight**: Non-linearity enables learning complex patterns</span>
<span id="cb21-1201"><a href="#cb21-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1202"><a href="#cb21-1202" aria-hidden="true" tabindex="-1"></a><span class="fu">### Level 2: Layer of Neurons</span></span>
<span id="cb21-1203"><a href="#cb21-1203" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiple neurons computed in parallel (vectorized)</span>
<span id="cb21-1204"><a href="#cb21-1204" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Matrix multiplication: efficient batch processing</span>
<span id="cb21-1205"><a href="#cb21-1205" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Transforms: vector input → vector output</span>
<span id="cb21-1206"><a href="#cb21-1206" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Key insight**: Multiple features extracted simultaneously</span>
<span id="cb21-1207"><a href="#cb21-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1208"><a href="#cb21-1208" aria-hidden="true" tabindex="-1"></a><span class="fu">### Level 3: Multi-Layer Network</span></span>
<span id="cb21-1209"><a href="#cb21-1209" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Stack layers to create deep representations</span>
<span id="cb21-1210"><a href="#cb21-1210" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Each layer builds on previous abstractions</span>
<span id="cb21-1211"><a href="#cb21-1211" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Transforms: input space → hidden spaces → output space</span>
<span id="cb21-1212"><a href="#cb21-1212" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Key insight**: Depth creates hierarchical features</span>
<span id="cb21-1213"><a href="#cb21-1213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1214"><a href="#cb21-1214" aria-hidden="true" tabindex="-1"></a><span class="fu">### Level 4: Attention &amp; Transformers</span></span>
<span id="cb21-1215"><a href="#cb21-1215" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Attention: dynamically weight inputs based on context</span>
<span id="cb21-1216"><a href="#cb21-1216" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multi-head: capture multiple relationship types</span>
<span id="cb21-1217"><a href="#cb21-1217" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Transformer: attention + feedforward with residual connections</span>
<span id="cb21-1218"><a href="#cb21-1218" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Key insight**: Context-aware processing for sequential data</span>
<span id="cb21-1219"><a href="#cb21-1219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1220"><a href="#cb21-1220" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb21-1221"><a href="#cb21-1221" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Key Difference</span></span>
<span id="cb21-1222"><a href="#cb21-1222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1223"><a href="#cb21-1223" aria-hidden="true" tabindex="-1"></a>**Traditional Neural Networks**: Process each input independently</span>
<span id="cb21-1224"><a href="#cb21-1224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1225"><a href="#cb21-1225" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Good for: images, tabular data where position doesn't matter</span>
<span id="cb21-1226"><a href="#cb21-1226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1227"><a href="#cb21-1227" aria-hidden="true" tabindex="-1"></a>**Transformers with Attention**: Process inputs in context of each other</span>
<span id="cb21-1228"><a href="#cb21-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1229"><a href="#cb21-1229" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Good for: language, time series, any sequential data</span>
<span id="cb21-1230"><a href="#cb21-1230" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Revolution: Enables models like GPT, BERT, and modern GFMs</span>
<span id="cb21-1231"><a href="#cb21-1231" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-1232"><a href="#cb21-1232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1233"><a href="#cb21-1233" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-1234"><a href="#cb21-1234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1235"><a href="#cb21-1235" aria-hidden="true" tabindex="-1"></a><span class="fu">## Interactive Exploration</span></span>
<span id="cb21-1236"><a href="#cb21-1236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1237"><a href="#cb21-1237" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb21-1238"><a href="#cb21-1238" aria-hidden="true" tabindex="-1"></a><span class="fu">## Try This Yourself</span></span>
<span id="cb21-1239"><a href="#cb21-1239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1240"><a href="#cb21-1240" aria-hidden="true" tabindex="-1"></a>Experiment with the code above:</span>
<span id="cb21-1241"><a href="#cb21-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1242"><a href="#cb21-1242" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Activation functions**: Change the activation in <span class="in">`single_neuron()`</span> and observe output changes</span>
<span id="cb21-1243"><a href="#cb21-1243" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Layer sizes**: Modify <span class="in">`layer_sizes`</span> in <span class="in">`SimpleNeuralNetwork`</span> - what happens with very wide or very deep networks?</span>
<span id="cb21-1244"><a href="#cb21-1244" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Attention heads**: Increase <span class="in">`n_heads`</span> in <span class="in">`MultiHeadAttention`</span> - do patterns change?</span>
<span id="cb21-1245"><a href="#cb21-1245" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Sequence length**: Use longer sequences in attention examples - observe attention patterns</span>
<span id="cb21-1246"><a href="#cb21-1246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1247"><a href="#cb21-1247" aria-hidden="true" tabindex="-1"></a>These experiments will deepen your intuition about how neural networks transform data.</span>
<span id="cb21-1248"><a href="#cb21-1248" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb21-1249"><a href="#cb21-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1250"><a href="#cb21-1250" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-1251"><a href="#cb21-1251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1252"><a href="#cb21-1252" aria-hidden="true" tabindex="-1"></a><span class="fu">## Further Resources</span></span>
<span id="cb21-1253"><a href="#cb21-1253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1254"><a href="#cb21-1254" aria-hidden="true" tabindex="-1"></a><span class="fu">### Video Explanations (3Blue1Brown)</span></span>
<span id="cb21-1255"><a href="#cb21-1255" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span><span class="co">[</span><span class="ot">Neural Networks</span><span class="co">](https://www.youtube.com/watch?v=aircAruvnKk)</span> - Core concepts</span>
<span id="cb21-1256"><a href="#cb21-1256" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span><span class="co">[</span><span class="ot">Gradient Descent</span><span class="co">](https://www.youtube.com/watch?v=IHZwWFHWa-w)</span> - How networks learn</span>
<span id="cb21-1257"><a href="#cb21-1257" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span><span class="co">[</span><span class="ot">Backpropagation</span><span class="co">](https://www.youtube.com/watch?v=Ilg3gGewQ5U)</span> - How gradients flow</span>
<span id="cb21-1258"><a href="#cb21-1258" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span><span class="co">[</span><span class="ot">Attention &amp; Transformers</span><span class="co">](https://www.youtube.com/watch?v=eMlx5fFNoYc)</span> - Modern architecture</span>
<span id="cb21-1259"><a href="#cb21-1259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1260"><a href="#cb21-1260" aria-hidden="true" tabindex="-1"></a><span class="fu">### Key Papers</span></span>
<span id="cb21-1261"><a href="#cb21-1261" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>"Attention Is All You Need" (Vaswani et al., 2017) - The original transformer paper</span>
<span id="cb21-1262"><a href="#cb21-1262" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>"Deep Residual Learning" (He et al., 2015) - Residual connections</span>
<span id="cb21-1263"><a href="#cb21-1263" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>"Understanding Deep Learning Requires Rethinking Generalization" (Zhang et al., 2017)</span>
<span id="cb21-1264"><a href="#cb21-1264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1265"><a href="#cb21-1265" aria-hidden="true" tabindex="-1"></a><span class="fu">### Next Steps in This Course</span></span>
<span id="cb21-1266"><a href="#cb21-1266" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Week 2**: Spatial-temporal attention for geospatial data</span>
<span id="cb21-1267"><a href="#cb21-1267" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Week 3**: Vision Transformers adapted for satellite imagery</span>
<span id="cb21-1268"><a href="#cb21-1268" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Week 4**: Pretraining strategies (masked autoencoders)</span>
<span id="cb21-1269"><a href="#cb21-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1270"><a href="#cb21-1270" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb21-1271"><a href="#cb21-1271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-1272"><a href="#cb21-1272" aria-hidden="true" tabindex="-1"></a>*This explainer is designed to build progressive understanding. Each section assumes you've understood the previous ones. Take time to run the code, observe the outputs, and experiment!*</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/geog-logo.png" class="img-fluid figure-img" width="250"></p>
<figcaption>Department of Geography logo</figcaption>
</figure>
</div>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <a href="https://github.com/kcaylor/GEOG-288KC-geospatial-foundation-models"><i class="fa-brands fa-github" title="the github octocat logo" aria-label="github"></i></a> and <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>