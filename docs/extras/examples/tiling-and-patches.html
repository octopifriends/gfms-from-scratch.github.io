<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Geospatial Patch Extraction for Foundation Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">GEOG 288KC</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">🏠 home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Syllabus.html"> 
<span class="menu-text">📋 syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-weekly-sessions" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">💻 weekly sessions</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-weekly-sessions">    
        <li>
    <a class="dropdown-item" href="../../chapters/c01-geospatial-data-foundations.html">
 <span class="dropdown-text">Week 1 - 🚀 Core Tools and Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c02-spatial-temporal-attention-mechanisms.html">
 <span class="dropdown-text">Week 2 - ⚡ Rapid Remote Sensing Preprocessing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c03-complete-gfm-architecture.html">
 <span class="dropdown-text">Week 3 - 🤖 Machine Learning on Remote Sensing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c04-pretraining-implementation.html">
 <span class="dropdown-text">Week 4 - 🏗️ Foundation Models in Practice</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c05-training-loop-optimization.html">
 <span class="dropdown-text">Week 5 - 🔧 Fine-Tuning &amp; Transfer Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c06-model-evaluation-analysis.html">
 <span class="dropdown-text">Week 6 - ⏰ Spatiotemporal Modeling &amp; Projects</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cheatsheets" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">👀 cheatsheets</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-cheatsheets">    
        <li>
    <a class="dropdown-item" href="../../cheatsheets.html">
 <span class="dropdown-text">📋 All Cheatsheets</span></a>
  </li>  
        <li><hr class="dropdown-divider"></li>
        <li class="dropdown-header">⚡ Quick Starts</li>
        <li>
    <a class="dropdown-item" href="../../extras/cheatsheets/week01_imports.html">
 <span class="dropdown-text">Week 01: Import Guide</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-explainers" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">🧩 explainers</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-explainers">    
        <li class="dropdown-header">1️⃣ Week 1</li>
        <li>
    <a class="dropdown-item" href="../../extras/ai-ml-dl-fm-hierarchy.html">
 <span class="dropdown-text">🤖 AI/ML/DL/FM Hierarchy</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/geospatial-foundation-model-predictions-standalone.html">
 <span class="dropdown-text">🎯 GFM Predictions (Standalone)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/geospatial-prediction-hierarchy.html">
 <span class="dropdown-text">✅ Geospatial Task/Prediction Types</span></a>
  </li>  
        <li class="dropdown-header">2️⃣ Week 2</li>
        <li>
    <a class="dropdown-item" href="../../chapters/c00a-foundation_model_architectures.html">
 <span class="dropdown-text">🏗️ Foundation Model Architectures</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../chapters/c00b-introduction-to-deeplearning-architecture.html">
 <span class="dropdown-text">🎓 Introduction to Deep Learning Architecture</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-extras" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📖 extras</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-extras">    
        <li class="dropdown-header">🎯 Practical Examples</li>
        <li>
    <a class="dropdown-item" href="../../extras/examples/normalization_comparison.html">
 <span class="dropdown-text">Normalization Comparison</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/resnet.html">
 <span class="dropdown-text">ResNet Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/text_encoder.html">
 <span class="dropdown-text">Text Encoder</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/tiling-and-patches.html">
 <span class="dropdown-text">Tiling and Patches</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/examples/terratorch_workflows.html">
 <span class="dropdown-text">TerraTorch Workflows</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/resources/course_resources.html">
 <span class="dropdown-text">📚 Reference Materials</span></a>
  </li>  
        <li class="dropdown-header">📁 Project Templates</li>
        <li>
    <a class="dropdown-item" href="../../extras/projects/project-proposal-template.html">
 <span class="dropdown-text">Project Proposal Template</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../extras/projects/mvp-template.html">
 <span class="dropdown-text">Project Results Template</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/gfms-from-scratch/gfms-from-scratch.github.io" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <div class="quarto-title-block"><div><h1 class="title">Geospatial Patch Extraction for Foundation Models</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
            <p class="subtitle lead">From Satellite Imagery to Vision Transformer Inputs</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-why-patches-matter-in-geospatial-ai" id="toc-introduction-why-patches-matter-in-geospatial-ai" class="nav-link active" data-scroll-target="#introduction-why-patches-matter-in-geospatial-ai">Introduction: Why Patches Matter in Geospatial AI</a>
  <ul class="collapse">
  <li><a href="#the-scale-challenge-in-remote-sensing" id="toc-the-scale-challenge-in-remote-sensing" class="nav-link" data-scroll-target="#the-scale-challenge-in-remote-sensing">The Scale Challenge in Remote Sensing</a></li>
  <li><a href="#how-vision-transformers-process-images" id="toc-how-vision-transformers-process-images" class="nav-link" data-scroll-target="#how-vision-transformers-process-images">How Vision Transformers Process Images</a></li>
  </ul></li>
  <li><a href="#fundamental-concepts-from-images-to-tokens" id="toc-fundamental-concepts-from-images-to-tokens" class="nav-link" data-scroll-target="#fundamental-concepts-from-images-to-tokens">Fundamental Concepts: From Images to Tokens</a>
  <ul class="collapse">
  <li><a href="#the-patch-extraction-pipeline" id="toc-the-patch-extraction-pipeline" class="nav-link" data-scroll-target="#the-patch-extraction-pipeline">The Patch Extraction Pipeline</a></li>
  <li><a href="#step-1-understanding-image-dimensions-and-memory" id="toc-step-1-understanding-image-dimensions-and-memory" class="nav-link" data-scroll-target="#step-1-understanding-image-dimensions-and-memory">Step 1: Understanding Image Dimensions and Memory</a></li>
  <li><a href="#step-2-basic-patch-extraction-mechanics" id="toc-step-2-basic-patch-extraction-mechanics" class="nav-link" data-scroll-target="#step-2-basic-patch-extraction-mechanics">Step 2: Basic Patch Extraction Mechanics</a></li>
  <li><a href="#visualizing-the-patch-grid" id="toc-visualizing-the-patch-grid" class="nav-link" data-scroll-target="#visualizing-the-patch-grid">Visualizing the Patch Grid</a></li>
  <li><a href="#step-3-from-patches-to-tokens" id="toc-step-3-from-patches-to-tokens" class="nav-link" data-scroll-target="#step-3-from-patches-to-tokens">Step 3: From Patches to Tokens</a></li>
  </ul></li>
  <li><a href="#real-world-considerations-memory-computation-and-scale" id="toc-real-world-considerations-memory-computation-and-scale" class="nav-link" data-scroll-target="#real-world-considerations-memory-computation-and-scale">Real-World Considerations: Memory, Computation, and Scale</a>
  <ul class="collapse">
  <li><a href="#computational-requirements-analysis" id="toc-computational-requirements-analysis" class="nav-link" data-scroll-target="#computational-requirements-analysis">Computational Requirements Analysis</a></li>
  <li><a href="#overlapping-patches-information-vs.-computation-trade-offs" id="toc-overlapping-patches-information-vs.-computation-trade-offs" class="nav-link" data-scroll-target="#overlapping-patches-information-vs.-computation-trade-offs">Overlapping Patches: Information vs.&nbsp;Computation Trade-offs</a></li>
  </ul></li>
  <li><a href="#handling-edge-cases-padding-strategies-for-real-world-data" id="toc-handling-edge-cases-padding-strategies-for-real-world-data" class="nav-link" data-scroll-target="#handling-edge-cases-padding-strategies-for-real-world-data">Handling Edge Cases: Padding Strategies for Real-World Data</a>
  <ul class="collapse">
  <li><a href="#the-edge-problem" id="toc-the-edge-problem" class="nav-link" data-scroll-target="#the-edge-problem">The Edge Problem</a></li>
  <li><a href="#strategy-1-crop-discard-incomplete-patches" id="toc-strategy-1-crop-discard-incomplete-patches" class="nav-link" data-scroll-target="#strategy-1-crop-discard-incomplete-patches">Strategy 1: Crop (Discard Incomplete Patches)</a></li>
  <li><a href="#strategy-2-zero-padding" id="toc-strategy-2-zero-padding" class="nav-link" data-scroll-target="#strategy-2-zero-padding">Strategy 2: Zero Padding</a></li>
  <li><a href="#strategy-3-reflect-padding" id="toc-strategy-3-reflect-padding" class="nav-link" data-scroll-target="#strategy-3-reflect-padding">Strategy 3: Reflect Padding</a></li>
  <li><a href="#comparing-padding-strategies" id="toc-comparing-padding-strategies" class="nav-link" data-scroll-target="#comparing-padding-strategies">Comparing Padding Strategies</a></li>
  </ul></li>
  <li><a href="#advanced-topics-multi-scale-and-multi-temporal-processing" id="toc-advanced-topics-multi-scale-and-multi-temporal-processing" class="nav-link" data-scroll-target="#advanced-topics-multi-scale-and-multi-temporal-processing">Advanced Topics: Multi-Scale and Multi-Temporal Processing</a>
  <ul class="collapse">
  <li><a href="#multi-scale-patch-extraction" id="toc-multi-scale-patch-extraction" class="nav-link" data-scroll-target="#multi-scale-patch-extraction">Multi-Scale Patch Extraction</a></li>
  <li><a href="#multi-temporal-patch-processing" id="toc-multi-temporal-patch-processing" class="nav-link" data-scroll-target="#multi-temporal-patch-processing">Multi-Temporal Patch Processing</a></li>
  </ul></li>
  <li><a href="#connection-to-foundation-model-architectures" id="toc-connection-to-foundation-model-architectures" class="nav-link" data-scroll-target="#connection-to-foundation-model-architectures">Connection to Foundation Model Architectures</a>
  <ul class="collapse">
  <li><a href="#how-different-gfms-handle-patches" id="toc-how-different-gfms-handle-patches" class="nav-link" data-scroll-target="#how-different-gfms-handle-patches">How Different GFMs Handle Patches</a></li>
  <li><a href="#masked-autoencoder-training" id="toc-masked-autoencoder-training" class="nav-link" data-scroll-target="#masked-autoencoder-training">Masked Autoencoder Training</a></li>
  </ul></li>
  <li><a href="#performance-optimization-and-practical-considerations" id="toc-performance-optimization-and-practical-considerations" class="nav-link" data-scroll-target="#performance-optimization-and-practical-considerations">Performance Optimization and Practical Considerations</a>
  <ul class="collapse">
  <li><a href="#memory-efficient-batch-processing" id="toc-memory-efficient-batch-processing" class="nav-link" data-scroll-target="#memory-efficient-batch-processing">Memory-Efficient Batch Processing</a></li>
  <li><a href="#real-world-pipeline-implementation" id="toc-real-world-pipeline-implementation" class="nav-link" data-scroll-target="#real-world-pipeline-implementation">Real-World Pipeline Implementation</a></li>
  </ul></li>
  <li><a href="#key-takeaways-and-best-practices" id="toc-key-takeaways-and-best-practices" class="nav-link" data-scroll-target="#key-takeaways-and-best-practices">Key Takeaways and Best Practices</a>
  <ul class="collapse">
  <li><a href="#understand-your-memory-constraints" id="toc-understand-your-memory-constraints" class="nav-link" data-scroll-target="#understand-your-memory-constraints">1. <strong>Understand Your Memory Constraints</strong></a></li>
  <li><a href="#choose-patch-size-strategically" id="toc-choose-patch-size-strategically" class="nav-link" data-scroll-target="#choose-patch-size-strategically">2. <strong>Choose Patch Size Strategically</strong></a></li>
  <li><a href="#select-padding-strategy-based-on-your-use-case" id="toc-select-padding-strategy-based-on-your-use-case" class="nav-link" data-scroll-target="#select-padding-strategy-based-on-your-use-case">3. <strong>Select Padding Strategy Based on Your Use Case</strong></a></li>
  <li><a href="#consider-overlap-for-better-performance" id="toc-consider-overlap-for-better-performance" class="nav-link" data-scroll-target="#consider-overlap-for-better-performance">4. <strong>Consider Overlap for Better Performance</strong></a></li>
  <li><a href="#plan-for-multi-scale-and-multi-temporal-processing" id="toc-plan-for-multi-scale-and-multi-temporal-processing" class="nav-link" data-scroll-target="#plan-for-multi-scale-and-multi-temporal-processing">5. <strong>Plan for Multi-Scale and Multi-Temporal Processing</strong></a></li>
  <li><a href="#optimize-for-your-specific-gfm-architecture" id="toc-optimize-for-your-specific-gfm-architecture" class="nav-link" data-scroll-target="#optimize-for-your-specific-gfm-architecture">6. <strong>Optimize for Your Specific GFM Architecture</strong></a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="introduction-why-patches-matter-in-geospatial-ai" class="level2">
<h2 class="anchored" data-anchor-id="introduction-why-patches-matter-in-geospatial-ai">Introduction: Why Patches Matter in Geospatial AI</h2>
<p>When working with satellite imagery and geospatial foundation models (GFMs), one of the most critical preprocessing steps is <strong>patch extraction</strong> — the process of dividing large satellite images into smaller, manageable pieces that can be fed into neural networks. This isn’t just a technical necessity; it’s a fundamental design choice that affects everything from computational efficiency to model performance.</p>
<section id="the-scale-challenge-in-remote-sensing" class="level3">
<h3 class="anchored" data-anchor-id="the-scale-challenge-in-remote-sensing">The Scale Challenge in Remote Sensing</h3>
<p>Satellite images present unique challenges compared to natural images used in computer vision:</p>
<ul>
<li><strong>Massive dimensions</strong>: A single Landsat scene covers 185×185 kilometers at 30m resolution, resulting in images with dimensions of approximately 6,000×6,000 pixels per band</li>
<li><strong>Multi-spectral complexity</strong>: Satellite imagery often contains 7-13 spectral bands (compared to 3 RGB channels in natural images)<br>
</li>
<li><strong>Memory constraints</strong>: Loading a full Sentinel-2 scene (10,980×10,980 pixels × 13 bands) would require over 6GB of RAM as float32 arrays</li>
<li><strong>Computational limits</strong>: Most GPUs cannot process such large images in a single forward pass</li>
</ul>
</section>
<section id="how-vision-transformers-process-images" class="level3">
<h3 class="anchored" data-anchor-id="how-vision-transformers-process-images">How Vision Transformers Process Images</h3>
<p>Vision Transformers (ViTs), the architecture underlying most geospatial foundation models, don’t process images as continuous arrays like Convolutional Neural Networks (CNNs). Instead, they:</p>
<ol type="1">
<li><strong>Divide images into fixed-size patches</strong> (typically 8×8, 16×16, or 32×32 pixels)</li>
<li><strong>Flatten each patch</strong> into a 1D vector (e.g., a 16×16×3 patch becomes a 768-element vector)</li>
<li><strong>Apply linear projection</strong> to transform patch vectors into embedding space</li>
<li><strong>Add positional encodings</strong> so the model knows where each patch came from spatially</li>
<li><strong>Process patches as a sequence</strong> using self-attention mechanisms</li>
</ol>
<p>This patch-based approach is why understanding patch extraction is crucial for working with GFMs — the quality of your patches directly impacts model performance.</p>
<hr>
</section>
</section>
<section id="fundamental-concepts-from-images-to-tokens" class="level2">
<h2 class="anchored" data-anchor-id="fundamental-concepts-from-images-to-tokens">Fundamental Concepts: From Images to Tokens</h2>
<section id="the-patch-extraction-pipeline" class="level3">
<h3 class="anchored" data-anchor-id="the-patch-extraction-pipeline">The Patch Extraction Pipeline</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">%%{init: { 'logLevel': 'debug' } }%%
graph TD
    A[Satellite Image&lt;br/&gt;H x W x C] --&gt; B[Spatial Tiling&lt;br/&gt;Divide into regions]
    B --&gt; C[Patch Extraction&lt;br/&gt;Fixed-size windows]
    C --&gt; D[Patch Flattening&lt;br/&gt;3D to 1D vectors]
    D --&gt; E[Linear Projection&lt;br/&gt;To embedding space]
    E --&gt; F[Add Positional Encoding&lt;br/&gt;Spatial awareness]
    F --&gt; G[Token Sequence&lt;br/&gt;Ready for Transformer]
    
    style A fill:#e1f5fe
    style G fill:#f3e5f5
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Let’s work through this pipeline step by step using real examples.</p>
</section>
<section id="step-1-understanding-image-dimensions-and-memory" class="level3">
<h3 class="anchored" data-anchor-id="step-1-understanding-image-dimensions-and-memory">Step 1: Understanding Image Dimensions and Memory</h3>
<p>First, let’s examine what we’re working with when we load satellite imagery and why patches are necessary.</p>
<div id="0a848441" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate dimensions of common satellite image types</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>satellite_scenarios <span class="op">=</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Landsat-8 Scene'</span>: {<span class="st">'height'</span>: <span class="dv">7611</span>, <span class="st">'width'</span>: <span class="dv">7791</span>, <span class="st">'bands'</span>: <span class="dv">11</span>, <span class="st">'pixel_size'</span>: <span class="dv">30</span>},</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Sentinel-2 Tile'</span>: {<span class="st">'height'</span>: <span class="dv">10980</span>, <span class="st">'width'</span>: <span class="dv">10980</span>, <span class="st">'bands'</span>: <span class="dv">13</span>, <span class="st">'pixel_size'</span>: <span class="dv">10</span>}, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">'MODIS Daily'</span>: {<span class="st">'height'</span>: <span class="dv">1200</span>, <span class="st">'width'</span>: <span class="dv">1200</span>, <span class="st">'bands'</span>: <span class="dv">36</span>, <span class="st">'pixel_size'</span>: <span class="dv">500</span>},</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">'High-res Drone'</span>: {<span class="st">'height'</span>: <span class="dv">20000</span>, <span class="st">'width'</span>: <span class="dv">20000</span>, <span class="st">'bands'</span>: <span class="dv">3</span>, <span class="st">'pixel_size'</span>: <span class="fl">0.1</span>}</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Memory Requirements for Full Images (as float32):"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, specs <span class="kw">in</span> satellite_scenarios.items():</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate total pixels</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    total_pixels <span class="op">=</span> specs[<span class="st">'height'</span>] <span class="op">*</span> specs[<span class="st">'width'</span>] <span class="op">*</span> specs[<span class="st">'bands'</span>]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Memory in bytes (float32 = 4 bytes per value)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    memory_bytes <span class="op">=</span> total_pixels <span class="op">*</span> <span class="dv">4</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    memory_gb <span class="op">=</span> memory_bytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Coverage area</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    area_m2 <span class="op">=</span> (specs[<span class="st">'height'</span>] <span class="op">*</span> specs[<span class="st">'pixel_size'</span>]) <span class="op">*</span> (specs[<span class="st">'width'</span>] <span class="op">*</span> specs[<span class="st">'pixel_size'</span>])</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    area_km2 <span class="op">=</span> area_m2 <span class="op">/</span> (<span class="dv">1000</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:20}</span><span class="ss"> | </span><span class="sc">{</span>specs[<span class="st">'height'</span>]<span class="sc">:5}</span><span class="ss">×</span><span class="sc">{</span>specs[<span class="st">'width'</span>]<span class="sc">:5}</span><span class="ss">×</span><span class="sc">{</span>specs[<span class="st">'bands'</span>]<span class="sc">:2}</span><span class="ss"> | </span><span class="sc">{</span>memory_gb<span class="sc">:5.2f}</span><span class="ss"> GB | </span><span class="sc">{</span>area_km2<span class="sc">:8.1f}</span><span class="ss"> km²"</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Key Insight: Even 'small' satellite images require gigabytes of memory!"</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   Most GPUs have 8-24GB VRAM, so we must process images in smaller pieces."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Memory Requirements for Full Images (as float32):
============================================================
Landsat-8 Scene      |  7611× 7791×11 |  2.43 GB |  53367.6 km²
Sentinel-2 Tile      | 10980×10980×13 |  5.84 GB |  12056.0 km²
MODIS Daily          |  1200× 1200×36 |  0.19 GB | 360000.0 km²
High-res Drone       | 20000×20000× 3 |  4.47 GB |      4.0 km²

💡 Key Insight: Even 'small' satellite images require gigabytes of memory!
   Most GPUs have 8-24GB VRAM, so we must process images in smaller pieces.</code></pre>
</div>
</div>
<p>This memory constraint is the primary <strong>practical</strong> reason for patch extraction, but there are also <strong>theoretical</strong> advantages:</p>
<ul>
<li><strong>Spatial attention</strong>: Transformers can learn relationships between different spatial regions</li>
<li><strong>Scale invariance</strong>: Models trained on patches can potentially handle images of any size<br>
</li>
<li><strong>Data augmentation</strong>: Each patch can be augmented independently, increasing training diversity</li>
</ul>
</section>
<section id="step-2-basic-patch-extraction-mechanics" class="level3">
<h3 class="anchored" data-anchor-id="step-2-basic-patch-extraction-mechanics">Step 2: Basic Patch Extraction Mechanics</h3>
<p>Let’s start with a simple example to understand the mechanics. We’ll create a synthetic satellite-like image and show how patches are extracted:</p>
<div id="2bf6d904" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a synthetic multi-spectral "satellite" image with realistic structure</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate different land cover types with distinct spectral signatures</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>height, width <span class="op">=</span> <span class="dv">120</span>, <span class="dv">180</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>bands <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Red, Green, Blue, NIR (Near-Infrared)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize image array</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">=</span> np.zeros((height, width, bands))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create realistic land cover patterns</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Forest areas (low red, moderate green, low blue, high NIR)</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>forest_mask <span class="op">=</span> np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.3</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>satellite_img[forest_mask] <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, <span class="fl">0.8</span>]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Agricultural fields (moderate red, high green, low blue, very high NIR) </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>ag_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.4</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>satellite_img[ag_mask] <span class="op">=</span> [<span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="fl">0.2</span>, <span class="fl">0.9</span>]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Urban areas (moderate all visible, low NIR)</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>urban_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (<span class="op">~</span>ag_mask) <span class="op">&amp;</span> (np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.5</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>satellite_img[urban_mask] <span class="op">=</span> [<span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>]</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Water bodies (low red, low green, moderate blue, very low NIR)</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>water_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (<span class="op">~</span>ag_mask) <span class="op">&amp;</span> (<span class="op">~</span>urban_mask)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>satellite_img[water_mask] <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Add some noise to make it more realistic</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">+=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.02</span>, satellite_img.shape)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">=</span> np.clip(satellite_img, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize using false color composite (NIR-Red-Green)</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="co"># True color (RGB)</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>ax1.imshow(satellite_img[:, :, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]])  <span class="co"># Red, Green, Blue</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'True Color Composite (RGB)'</span>)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks([])</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>ax1.set_yticks([])</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a><span class="co"># False color (NIR-Red-Green) - vegetation appears red</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>false_color <span class="op">=</span> satellite_img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]]  <span class="co"># NIR, Red, Green</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>ax2.imshow(false_color)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'False Color Composite (NIR-R-G)'</span>)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>ax2.set_xticks([])</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>ax2.set_yticks([])</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="ss">f'Synthetic Satellite Image: </span><span class="sc">{</span>height<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>width<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>bands<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>, y<span class="op">=</span><span class="fl">1.02</span>)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Image shape: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Memory usage: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)<span class="sc">:.2f}</span><span class="ss"> MB"</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Spectral bands: Red, Green, Blue, Near-Infrared"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Image shape: (120, 180, 4)
Memory usage: 0.66 MB
Spectral bands: Red, Green, Blue, Near-Infrared</code></pre>
</div>
</div>
<p>Now let’s extract patches from this image and understand what happens at each step:</p>
<div id="5536cfac" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_patches_with_visualization(image, patch_size, stride<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Extract patches from a multi-spectral image and visualize the process.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">        image: numpy array of shape (H, W, C)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">        patch_size: int, size of square patches</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">        stride: int, step size between patches (defaults to patch_size for non-overlapping)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        patches: array of shape (n_patches, patch_size, patch_size, C)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">        patch_positions: list of (x, y) coordinates for each patch</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> stride <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        stride <span class="op">=</span> patch_size</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    patches <span class="op">=</span> []</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    patch_positions <span class="op">=</span> []</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate how many patches fit</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    n_patches_y <span class="op">=</span> (H <span class="op">-</span> patch_size) <span class="op">//</span> stride <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    n_patches_x <span class="op">=</span> (W <span class="op">-</span> patch_size) <span class="op">//</span> stride <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches_y):</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_patches_x):</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> i <span class="op">*</span> stride</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> j <span class="op">*</span> stride</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ensure patch doesn't exceed image boundaries</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> y <span class="op">+</span> patch_size <span class="op">&lt;=</span> H <span class="kw">and</span> x <span class="op">+</span> patch_size <span class="op">&lt;=</span> W:</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>                patch <span class="op">=</span> image[y:y<span class="op">+</span>patch_size, x:x<span class="op">+</span>patch_size, :]</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>                patches.append(patch)</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>                patch_positions.append((x, y))</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(patches), patch_positions</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract patches</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>patch_size <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>stride <span class="op">=</span> <span class="dv">30</span>  <span class="co"># Non-overlapping patches</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>patches, positions <span class="op">=</span> extract_patches_with_visualization(satellite_img, patch_size, stride)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original image: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Stride: </span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss"> (overlap: </span><span class="sc">{</span>patch_size<span class="op">-</span>stride<span class="sc">}</span><span class="ss"> pixels)"</span>)</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patches extracted: </span><span class="sc">{</span>patches<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch array shape: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Memory per patch: </span><span class="sc">{</span>patches[<span class="dv">0</span>]<span class="sc">.</span>nbytes <span class="op">/</span> <span class="dv">1024</span><span class="sc">:.2f}</span><span class="ss"> KB"</span>)</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total patch memory: </span><span class="sc">{</span>patches<span class="sc">.</span>nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)<span class="sc">:.2f}</span><span class="ss"> MB"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original image: (120, 180, 4)
Patch size: 30×30
Stride: 30 (overlap: 0 pixels)
Patches extracted: 24
Patch array shape: (24, 30, 30, 4)
Memory per patch: 28.12 KB
Total patch memory: 0.66 MB</code></pre>
</div>
</div>
</section>
<section id="visualizing-the-patch-grid" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-the-patch-grid">Visualizing the Patch Grid</h3>
<p>Understanding where patches come from spatially is crucial for interpreting model outputs later:</p>
<div id="edfd3d77" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize patch extraction grid on the original image</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the false color composite as background</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ax.imshow(satellite_img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># NIR-Red-Green</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw patch boundaries</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(positions):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Draw patch boundary</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                        linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(rect)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Label first few patches to show indexing</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">9</span>:  <span class="co"># Only label first 9 patches to avoid clutter</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        center_x, center_y <span class="op">=</span> x <span class="op">+</span> patch_size<span class="op">//</span><span class="dv">2</span>, y <span class="op">+</span> patch_size<span class="op">//</span><span class="dv">2</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        ax.text(center_x, center_y, <span class="bu">str</span>(i), ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'yellow'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'black'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>))</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, satellite_img.shape[<span class="dv">1</span>])</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(satellite_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="ss">f'Patch Extraction Grid: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches, stride=</span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="step-3-from-patches-to-tokens" class="level3">
<h3 class="anchored" data-anchor-id="step-3-from-patches-to-tokens">Step 3: From Patches to Tokens</h3>
<p>Now let’s demonstrate how these patches become the input tokens that Vision Transformers process:</p>
<div id="2b91c107" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> patches_to_tokens_demo(patches, embed_dim<span class="op">=</span><span class="dv">256</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate the conversion from image patches to transformer tokens.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This simulates what happens inside a Vision Transformer.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    n_patches, patch_h, patch_w, channels <span class="op">=</span> patches.shape</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Flatten each patch into a 1D vector</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is what ViTs do: treat each patch as a "word" in a sequence</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    flattened_patches <span class="op">=</span> patches.reshape(n_patches, patch_h <span class="op">*</span> patch_w <span class="op">*</span> channels)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Token Creation Process:"</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"1. Input patches shape: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss"> patches"</span>)  </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each patch: </span><span class="sc">{</span>patch_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_w<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>channels<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>patch_h<span class="op">*</span>patch_w<span class="op">*</span>channels<span class="sc">}</span><span class="ss"> values"</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"2. Flattened patches: </span><span class="sc">{</span>flattened_patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each patch becomes a </span><span class="sc">{</span>flattened_patches<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">-dimensional vector"</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Linear projection to embedding space (simplified simulation)</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In real ViTs, this is a learnable linear layer: nn.Linear(patch_dim, embed_dim)</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)  <span class="co"># For reproducible "projection"</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    projection_matrix <span class="op">=</span> np.random.randn(flattened_patches.shape[<span class="dv">1</span>], embed_dim) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    token_embeddings <span class="op">=</span> flattened_patches <span class="op">@</span> projection_matrix</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"3. Linear projection to embeddings: </span><span class="sc">{</span>token_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each token now has </span><span class="sc">{</span>embed_dim<span class="sc">}</span><span class="ss"> dimensions"</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - These embeddings will be processed by transformer layers"</span>)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Add positional encodings (simplified)</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This tells the model where each patch came from spatially</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    positions_2d <span class="op">=</span> np.array([(i <span class="op">%</span> <span class="bu">int</span>(np.sqrt(n_patches)), i <span class="op">//</span> <span class="bu">int</span>(np.sqrt(n_patches))) </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches)])</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"4. Spatial positions: </span><span class="sc">{</span>positions_2d<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each token gets x,y coordinates of its source patch"</span>)</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - This preserves spatial relationships"</span>)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> token_embeddings, positions_2d</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert our extracted patches to tokens</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>token_embeddings, spatial_positions <span class="op">=</span> patches_to_tokens_demo(patches)</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize token statistics</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution of token embedding values</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>ax1.hist(token_embeddings.flatten(), bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'skyblue'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Embedding Value'</span>)</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Distribution of Token Embedding Values'</span>)</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="co"># Show spatial positions</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>ax2.scatter(spatial_positions[:, <span class="dv">0</span>], spatial_positions[:, <span class="dv">1</span>], </span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>           c<span class="op">=</span><span class="bu">range</span>(<span class="bu">len</span>(spatial_positions)), cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Patch X Position'</span>)</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Patch Y Position'</span>)</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Spatial Positions of Tokens'</span>)</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(spatial_positions[:<span class="dv">9</span>]):  <span class="co"># Label first 9</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    ax2.annotate(<span class="bu">str</span>(i), (x, y), xytext<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>, fontsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Token Creation Process:
========================================
1. Input patches shape: (24, 30, 30, 4)
   - 24 patches
   - Each patch: 30×30×4 = 3600 values
2. Flattened patches: (24, 3600)
   - Each patch becomes a 3600-dimensional vector
3. Linear projection to embeddings: (24, 256)
   - Each token now has 256 dimensions
   - These embeddings will be processed by transformer layers
4. Spatial positions: (24, 2)
   - Each token gets x,y coordinates of its source patch
   - This preserves spatial relationships</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-6-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
</section>
</section>
<section id="real-world-considerations-memory-computation-and-scale" class="level2">
<h2 class="anchored" data-anchor-id="real-world-considerations-memory-computation-and-scale">Real-World Considerations: Memory, Computation, and Scale</h2>
<section id="computational-requirements-analysis" class="level3">
<h3 class="anchored" data-anchor-id="computational-requirements-analysis">Computational Requirements Analysis</h3>
<p>Before diving into advanced techniques, let’s understand the computational trade-offs involved in different patch extraction strategies:</p>
<div id="b1aa905a" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_computational_requirements():</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Analyze memory and computational requirements for different patch strategies</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    with real satellite imagery scenarios.</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Common GFM patch sizes used in literature</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    patch_sizes <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Realistic satellite image scenarios</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    scenarios <span class="op">=</span> {</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Sentinel-2 10m'</span>: {<span class="st">'height'</span>: <span class="dv">10980</span>, <span class="st">'width'</span>: <span class="dv">10980</span>, <span class="st">'bands'</span>: <span class="dv">4</span>},  <span class="co"># RGB + NIR</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Landsat-8'</span>: {<span class="st">'height'</span>: <span class="dv">7791</span>, <span class="st">'width'</span>: <span class="dv">7611</span>, <span class="st">'bands'</span>: <span class="dv">7</span>},  <span class="co"># Selected bands</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'MODIS 250m'</span>: {<span class="st">'height'</span>: <span class="dv">4800</span>, <span class="st">'width'</span>: <span class="dv">4800</span>, <span class="st">'bands'</span>: <span class="dv">2</span>},  <span class="co"># Red + NIR</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Drone RGB'</span>: {<span class="st">'height'</span>: <span class="dv">8000</span>, <span class="st">'width'</span>: <span class="dv">8000</span>, <span class="st">'bands'</span>: <span class="dv">3</span>}   <span class="co"># High-res RGB</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Computational Analysis: Patches per Image"</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Scenario'</span><span class="sc">:15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Image Size'</span><span class="sc">:12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patch'</span><span class="sc">:5}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patches'</span><span class="sc">:8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory/Batch'</span><span class="sc">:12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'GPU Batches'</span><span class="sc">:10}</span><span class="ss">"</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> scenario_name, specs <span class="kw">in</span> scenarios.items():</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        h, w, c <span class="op">=</span> specs[<span class="st">'height'</span>], specs[<span class="st">'width'</span>], specs[<span class="st">'bands'</span>]</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> patch_size <span class="kw">in</span> patch_sizes:</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate non-overlapping patches</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>            patches_y <span class="op">=</span> h <span class="op">//</span> patch_size</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>            patches_x <span class="op">=</span> w <span class="op">//</span> patch_size  </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>            total_patches <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Memory per patch in MB (float32)</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>            patch_memory_mb <span class="op">=</span> (patch_size <span class="op">*</span> patch_size <span class="op">*</span> c <span class="op">*</span> <span class="dv">4</span>) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Typical GPU memory limit (assume 16GB for analysis)</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>            gpu_memory_gb <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reserve 4GB for model weights and intermediate activations</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>            available_memory_gb <span class="op">=</span> gpu_memory_gb <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>            available_memory_mb <span class="op">=</span> available_memory_gb <span class="op">*</span> <span class="dv">1024</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Maximum patches per batch</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>            max_batch_size <span class="op">=</span> <span class="bu">int</span>(available_memory_mb <span class="op">/</span> patch_memory_mb)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># How many GPU batches needed to process full image</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>            batches_needed <span class="op">=</span> (total_patches <span class="op">+</span> max_batch_size <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> max_batch_size</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>scenario_name<span class="sc">:15}</span><span class="ss"> </span><span class="sc">{</span>h<span class="sc">:4}</span><span class="ss">×</span><span class="sc">{</span>w<span class="sc">:4}</span><span class="ss"> </span><span class="sc">{</span>patch_size<span class="sc">:3}</span><span class="ss"> </span><span class="sc">{</span>total_patches<span class="sc">:8,}</span><span class="ss"> "</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"</span><span class="sc">{</span>patch_memory_mb<span class="sc">:7.2f}</span><span class="ss"> MB </span><span class="sc">{</span>batches_needed<span class="sc">:8}</span><span class="ss">"</span>)</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>analyze_computational_requirements()</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Key Insights:"</span>)</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Smaller patches = more patches = more GPU batches needed"</span>)</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Larger patches = fewer patches but higher memory per patch"</span>)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Most real scenarios require multiple GPU batches for inference"</span>)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Memory-compute trade-off is crucial for deployment planning"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Computational Analysis: Patches per Image
================================================================================
Scenario        Image Size   Patch Patches  Memory/Batch GPU Batches
--------------------------------------------------------------------------------
Sentinel-2 10m  10980×10980   8 1,882,384    0.00 MB        1
Sentinel-2 10m  10980×10980  16  470,596    0.00 MB        1
Sentinel-2 10m  10980×10980  32  117,649    0.02 MB        1
Sentinel-2 10m  10980×10980  64   29,241    0.06 MB        1
Landsat-8       7791×7611   8  925,323    0.00 MB        1
Landsat-8       7791×7611  16  230,850    0.01 MB        1
Landsat-8       7791×7611  32   57,591    0.03 MB        1
Landsat-8       7791×7611  64   14,278    0.11 MB        1
MODIS 250m      4800×4800   8  360,000    0.00 MB        1
MODIS 250m      4800×4800  16   90,000    0.00 MB        1
MODIS 250m      4800×4800  32   22,500    0.01 MB        1
MODIS 250m      4800×4800  64    5,625    0.03 MB        1
Drone RGB       8000×8000   8 1,000,000    0.00 MB        1
Drone RGB       8000×8000  16  250,000    0.00 MB        1
Drone RGB       8000×8000  32   62,500    0.01 MB        1
Drone RGB       8000×8000  64   15,625    0.05 MB        1

💡 Key Insights:
   • Smaller patches = more patches = more GPU batches needed
   • Larger patches = fewer patches but higher memory per patch
   • Most real scenarios require multiple GPU batches for inference
   • Memory-compute trade-off is crucial for deployment planning</code></pre>
</div>
</div>
</section>
<section id="overlapping-patches-information-vs.-computation-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="overlapping-patches-information-vs.-computation-trade-offs">Overlapping Patches: Information vs.&nbsp;Computation Trade-offs</h3>
<p>Many GFMs use overlapping patches to capture more spatial context and improve boundary handling. Let’s explore this trade-off:</p>
<div id="60df561c" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_overlap_effects(image, patch_size<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how different stride values affect patch overlap and information coverage.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    stride_values <span class="op">=</span> [<span class="dv">32</span>, <span class="dv">16</span>, <span class="dv">8</span>]  <span class="co"># 0%, 50%, 75% overlap</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    overlap_percentages <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">75</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, (stride, overlap_pct) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(stride_values, overlap_percentages)):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract patches with this stride</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(image, patch_size, stride)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show image background</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        ax.imshow(image[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Draw patch boundaries with different colors to show overlap</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        colors <span class="op">=</span> [<span class="st">'red'</span>, <span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>, <span class="st">'purple'</span>, <span class="st">'cyan'</span>]</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(positions[:<span class="dv">18</span>]):  <span class="co"># Show first 18 patches</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            color <span class="op">=</span> colors[i <span class="op">%</span> <span class="bu">len</span>(colors)]</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>                               linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span>color, facecolor<span class="op">=</span>color, </span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>                               alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            ax.add_patch(rect)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, image.shape[<span class="dv">1</span>])</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(image.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>overlap_pct<span class="sc">}</span><span class="ss">% Overlap</span><span class="ch">\n</span><span class="ss">Stride=</span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span><span class="bu">len</span>(positions)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="ss">f'Effect of Patch Overlap (patch size = </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Quantitative analysis</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Overlap Analysis:"</span>)</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stride, overlap_pct <span class="kw">in</span> <span class="bu">zip</span>(stride_values, overlap_percentages):</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        patches, _ <span class="op">=</span> extract_patches_with_visualization(image, patch_size, stride)</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>        memory_mb <span class="op">=</span> patches.nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Overlap </span><span class="sc">{</span>overlap_pct<span class="sc">:2}</span><span class="ss">%: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">:3}</span><span class="ss"> patches, </span><span class="sc">{</span>memory_mb<span class="sc">:5.1f}</span><span class="ss"> MB"</span>)</span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>demonstrate_overlap_effects(satellite_img)</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Overlap Trade-offs:"</span>)</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • More overlap = better spatial context + boundary handling"</span>)</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • More overlap = more patches = higher computational cost"</span>) </span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Optimal overlap depends on your specific task requirements"</span>)</span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Change detection often benefits from overlap"</span>)</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Classification tasks may not need much overlap"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Overlap Analysis:
==================================================
Overlap  0%:  15 patches,   0.5 MB
Overlap 50%:  60 patches,   1.9 MB
Overlap 75%: 228 patches,   7.1 MB

💡 Overlap Trade-offs:
   • More overlap = better spatial context + boundary handling
   • More overlap = more patches = higher computational cost
   • Optimal overlap depends on your specific task requirements
   • Change detection often benefits from overlap
   • Classification tasks may not need much overlap</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="handling-edge-cases-padding-strategies-for-real-world-data" class="level2">
<h2 class="anchored" data-anchor-id="handling-edge-cases-padding-strategies-for-real-world-data">Handling Edge Cases: Padding Strategies for Real-World Data</h2>
<p>When working with satellite imagery, images rarely divide evenly into patches. Different padding strategies offer different trade-offs between information preservation, computational efficiency, and model performance.</p>
<section id="the-edge-problem" class="level3">
<h3 class="anchored" data-anchor-id="the-edge-problem">The Edge Problem</h3>
<p>Let’s create a realistic scenario where image dimensions don’t divide evenly by patch size:</p>
<div id="0872d165" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a satellite image with dimensions that don't divide evenly</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>irregular_img <span class="op">=</span> np.random.rand(<span class="dv">155</span>, <span class="dv">237</span>, <span class="dv">4</span>)  <span class="co"># Irregular dimensions</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>irregular_img <span class="op">=</span> irregular_img <span class="op">*</span> <span class="fl">0.3</span> <span class="op">+</span> <span class="fl">0.4</span>  <span class="co"># Moderate intensity values</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>patch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the mismatch</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>patches_y <span class="op">=</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">//</span> patch_size</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>patches_x <span class="op">=</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">//</span> patch_size</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>leftover_y <span class="op">=</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">%</span> patch_size  </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>leftover_x <span class="op">=</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">%</span> patch_size</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edge Problem Analysis:"</span>)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Image dimensions: </span><span class="sc">{</span>irregular_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>irregular_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Complete patches fit: </span><span class="sc">{</span>patches_y<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patches_x<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Leftover pixels: </span><span class="sc">{</span>leftover_y<span class="sc">}</span><span class="ss"> rows, </span><span class="sc">{</span>leftover_x<span class="sc">}</span><span class="ss"> columns"</span>)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Unusable area: </span><span class="sc">{</span>(leftover_y <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">+</span> leftover_x <span class="op">*</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">-</span> leftover_y <span class="op">*</span> leftover_x)<span class="sc">:.0f}</span><span class="ss"> pixels"</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Information loss: </span><span class="sc">{</span><span class="dv">100</span> <span class="op">*</span> (leftover_y <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">+</span> leftover_x <span class="op">*</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">-</span> leftover_y <span class="op">*</span> leftover_x) <span class="op">/</span> (irregular_img.shape[<span class="dv">0</span>] <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>])<span class="sc">:.1f}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Edge Problem Analysis:
========================================
Image dimensions: 155×237
Patch size: 32×32
Complete patches fit: 4×7
Leftover pixels: 27 rows, 13 columns
Unusable area: 8063 pixels
Information loss: 21.9%</code></pre>
</div>
</div>
</section>
<section id="strategy-1-crop-discard-incomplete-patches" class="level3">
<h3 class="anchored" data-anchor-id="strategy-1-crop-discard-incomplete-patches">Strategy 1: Crop (Discard Incomplete Patches)</h3>
<p><strong>When to use</strong>: Speed is critical, edge information is less important, or when using overlapping patches that provide edge coverage.</p>
<div id="437ee3c9" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_crop_strategy(image, patch_size):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show crop strategy: discard patches that don't fit completely.</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate largest area that fits complete patches</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    crop_h <span class="op">=</span> (H <span class="op">//</span> patch_size) <span class="op">*</span> patch_size</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    crop_w <span class="op">=</span> (W <span class="op">//</span> patch_size) <span class="op">*</span> patch_size</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Crop image</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    cropped_img <span class="op">=</span> image[:crop_h, :crop_w, :]</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches from cropped image</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(cropped_img, patch_size)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image with crop boundary</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    crop_rect <span class="op">=</span> plt.Rectangle((<span class="dv">0</span>, <span class="dv">0</span>), crop_w, crop_h,</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>                             linewidth<span class="op">=</span><span class="dv">3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    ax1.add_patch(crop_rect)</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlim(<span class="dv">0</span>, W)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylim(H, <span class="dv">0</span>)</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original Image: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ch">\n</span><span class="ss">Red box: kept area'</span>)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cropped image with patches</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(cropped_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">12</span>]:  <span class="co"># Show first 12 patch boundaries</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, crop_w)</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(crop_h, <span class="dv">0</span>)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Cropped: </span><span class="sc">{</span>crop_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>crop_w<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 1: Crop (Discard Edge Data)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Statistics</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>    pixels_lost <span class="op">=</span> H <span class="op">*</span> W <span class="op">-</span> crop_h <span class="op">*</span> crop_w</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    loss_percentage <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> pixels_lost <span class="op">/</span> (H <span class="op">*</span> W)</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Crop Strategy Results:"</span>)</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>H<span class="op">*</span>W<span class="sc">:,}</span><span class="ss"> pixels"</span>)</span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Cropped:  </span><span class="sc">{</span>crop_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>crop_w<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>crop_h<span class="op">*</span>crop_w<span class="sc">:,}</span><span class="ss"> pixels"</span>)</span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Lost:     </span><span class="sc">{</span>pixels_lost<span class="sc">:,}</span><span class="ss"> pixels (</span><span class="sc">{</span>loss_percentage<span class="sc">:.1f}</span><span class="ss">%)"</span>)</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cropped_img, patches</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>cropped_img, crop_patches <span class="op">=</span> demonstrate_crop_strategy(irregular_img, patch_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Crop Strategy Results:
  Original: 155×237 = 36,735 pixels
  Cropped:  128×224 = 28,672 pixels
  Lost:     8,063 pixels (21.9%)
  Patches:  28</code></pre>
</div>
</div>
</section>
<section id="strategy-2-zero-padding" class="level3">
<h3 class="anchored" data-anchor-id="strategy-2-zero-padding">Strategy 2: Zero Padding</h3>
<p><strong>When to use</strong>: Complete coverage is essential, working with models robust to boundary artifacts, or when post-processing can handle padding effects.</p>
<div id="0cacf29d" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_zero_padding(image, patch_size):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show zero padding strategy: extend image with zeros to fit complete patches.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    pad_h <span class="op">=</span> patch_size <span class="op">-</span> (H <span class="op">%</span> patch_size) <span class="cf">if</span> H <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    pad_w <span class="op">=</span> patch_size <span class="op">-</span> (W <span class="op">%</span> patch_size) <span class="cf">if</span> W <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply zero padding</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    padded_img <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>                        mode<span class="op">=</span><span class="st">'constant'</span>, constant_values<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(padded_img, patch_size)</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Padded image with patches</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(padded_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight padding areas</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        padding_rect <span class="op">=</span> plt.Rectangle((W<span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span>), pad_w, H,</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>                                   facecolor<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(padding_rect)</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>        ax2.text(W <span class="op">+</span> pad_w<span class="op">/</span><span class="dv">2</span>, H<span class="op">/</span><span class="dv">2</span>, <span class="st">'Zero</span><span class="ch">\n</span><span class="st">Padding'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'red'</span>, weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        padding_rect <span class="op">=</span> plt.Rectangle((<span class="op">-</span><span class="fl">0.5</span>, H<span class="op">-</span><span class="fl">0.5</span>), W <span class="op">+</span> pad_w, pad_h,</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>                                   facecolor<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(padding_rect)</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>        ax2.text((W <span class="op">+</span> pad_w)<span class="op">/</span><span class="dv">2</span>, H <span class="op">+</span> pad_h<span class="op">/</span><span class="dv">2</span>, <span class="st">'Zero Padding'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'red'</span>, weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show some patch boundaries</span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">15</span>]:  <span class="co"># First 15 patches</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, padded_img.shape[<span class="dv">1</span>])</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(padded_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Padded: </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 2: Zero Padding'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Zero Padding Results:"</span>)</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padding:  +</span><span class="sc">{</span>pad_h<span class="sc">}</span><span class="ss"> rows, +</span><span class="sc">{</span>pad_w<span class="sc">}</span><span class="ss"> columns"</span>) </span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padded:   </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> padded_img, patches</span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a>padded_img, pad_patches <span class="op">=</span> demonstrate_zero_padding(irregular_img, patch_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zero Padding Results:
  Original: 155×237
  Padding:  +5 rows, +19 columns
  Padded:   160×256
  Patches:  40</code></pre>
</div>
</div>
</section>
<section id="strategy-3-reflect-padding" class="level3">
<h3 class="anchored" data-anchor-id="strategy-3-reflect-padding">Strategy 3: Reflect Padding</h3>
<p><strong>When to use</strong>: Image quality is critical, working with natural imagery where structure matters, or when models are sensitive to boundary artifacts.</p>
<div id="adb35f0a" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_reflect_padding(image, patch_size):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show reflect padding: mirror edge pixels for natural boundaries.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    pad_h <span class="op">=</span> patch_size <span class="op">-</span> (H <span class="op">%</span> patch_size) <span class="cf">if</span> H <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    pad_w <span class="op">=</span> patch_size <span class="op">-</span> (W <span class="op">%</span> patch_size) <span class="cf">if</span> W <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply reflection padding</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    padded_img <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), mode<span class="op">=</span><span class="st">'reflect'</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(padded_img, patch_size)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize  </span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Padded with reflection highlighting</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(padded_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Draw boundary between original and reflected content</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        ax2.axvline(W<span class="op">-</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'cyan'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        ax2.text(W <span class="op">+</span> pad_w<span class="op">/</span><span class="dv">2</span>, H<span class="op">/</span><span class="dv">2</span>, <span class="st">'Reflected</span><span class="ch">\n</span><span class="st">Content'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'cyan'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        ax2.axhline(H<span class="op">-</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'cyan'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.8</span>) </span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>        ax2.text((W <span class="op">+</span> pad_w)<span class="op">/</span><span class="dv">2</span>, H <span class="op">+</span> pad_h<span class="op">/</span><span class="dv">2</span>, <span class="st">'Reflected Content'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'cyan'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show patch boundaries</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">15</span>]:</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'yellow'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, padded_img.shape[<span class="dv">1</span>])</span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(padded_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Reflect Padded: </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 3: Reflect Padding (Preserves Structure)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Reflect Padding Results:"</span>)</span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padding:  +</span><span class="sc">{</span>pad_h<span class="sc">}</span><span class="ss"> rows, +</span><span class="sc">{</span>pad_w<span class="sc">}</span><span class="ss"> columns"</span>)</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padded:   </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Note: Reflected content preserves local image structure"</span>)</span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> padded_img, patches</span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a>reflect_img, reflect_patches <span class="op">=</span> demonstrate_reflect_padding(irregular_img, patch_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Reflect Padding Results:
  Original: 155×237
  Padding:  +5 rows, +19 columns
  Padded:   160×256
  Patches:  40
  Note: Reflected content preserves local image structure</code></pre>
</div>
</div>
</section>
<section id="comparing-padding-strategies" class="level3">
<h3 class="anchored" data-anchor-id="comparing-padding-strategies">Comparing Padding Strategies</h3>
<p>Let’s quantitatively compare how these strategies affect the actual patch content:</p>
<div id="eb0cfac3" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_padding_strategies():</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Compare the three padding strategies quantitatively.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Padding Strategy Comparison"</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Strategy'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patches'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory (MB)'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Edge Coverage'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Artifacts'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    strategies <span class="op">=</span> [</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Crop'</span>, crop_patches, <span class="st">'Incomplete'</span>, <span class="st">'None'</span>),</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Zero Pad'</span>, pad_patches, <span class="st">'Complete'</span>, <span class="st">'Boundary jumps'</span>),</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Reflect Pad'</span>, reflect_patches, <span class="st">'Complete'</span>, <span class="st">'Minimal'</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, patches, coverage, artifacts <span class="kw">in</span> strategies:</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        memory_mb <span class="op">=</span> patches.nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>memory_mb<span class="sc">:&lt;12.1f}</span><span class="ss"> </span><span class="sc">{</span>coverage<span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span>artifacts<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visual comparison of edge patches</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Top row: show full padded images</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> [cropped_img, padded_img, reflect_img]</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    titles <span class="op">=</span> [<span class="st">'Cropped'</span>, <span class="st">'Zero Padded'</span>, <span class="st">'Reflect Padded'</span>]</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (img, title) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(images, titles)):</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].imshow(img[:, :, :<span class="dv">3</span>])</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_title(title)</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_xticks([])</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_yticks([])</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bottom row: show edge patches that contain padding</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>    patch_sets <span class="op">=</span> [crop_patches, pad_patches, reflect_patches]</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (patches, title) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(patch_sets, titles)):</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># Crop strategy - show a regular patch</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>            edge_patch <span class="op">=</span> patches[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Last patch (still contains real data)</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].imshow(edge_patch[:, :, :<span class="dv">3</span>])</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">: Regular patch'</span>)</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># Padding strategies - show patch with padding</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>            edge_patch <span class="op">=</span> patches[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Last patch (contains padding)</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].imshow(edge_patch[:, :, :<span class="dv">3</span>])</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">: Edge patch'</span>)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_xticks([])</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_yticks([])</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Padding Strategy Comparison: Full Images (top) and Edge Patches (bottom)'</span>, </span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>                 fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>compare_padding_strategies()</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🎯 Strategy Selection Guidelines:"</span>)</span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • CROP: Use for large-scale analysis where speed &gt; completeness"</span>)</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • ZERO PAD: Use when complete coverage is mandatory"</span>)  </span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • REFLECT PAD: Use for high-quality analysis of natural imagery"</span>)</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Consider your downstream task requirements"</span>)</span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Test different strategies on your specific data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Padding Strategy Comparison
============================================================
Strategy        Patches  Memory (MB)  Edge Coverage   Artifacts
------------------------------------------------------------
Crop            28       0.9          Incomplete      None
Zero Pad        40       1.2          Complete        Boundary jumps
Reflect Pad     40       1.2          Complete        Minimal</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-13-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
🎯 Strategy Selection Guidelines:
   • CROP: Use for large-scale analysis where speed &gt; completeness
   • ZERO PAD: Use when complete coverage is mandatory
   • REFLECT PAD: Use for high-quality analysis of natural imagery
   • Consider your downstream task requirements
   • Test different strategies on your specific data</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="advanced-topics-multi-scale-and-multi-temporal-processing" class="level2">
<h2 class="anchored" data-anchor-id="advanced-topics-multi-scale-and-multi-temporal-processing">Advanced Topics: Multi-Scale and Multi-Temporal Processing</h2>
<section id="multi-scale-patch-extraction" class="level3">
<h3 class="anchored" data-anchor-id="multi-scale-patch-extraction">Multi-Scale Patch Extraction</h3>
<p>Real-world satellite analysis often requires processing the same area at multiple scales. For example, identifying broad land cover patterns (large patches) while also detecting detailed features (small patches):</p>
<div id="2ba929fe" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_scale_patch_extraction(image, patch_sizes<span class="op">=</span>[<span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>]):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate multi-scale patch extraction for hierarchical analysis.</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This approach is used in some advanced GFMs.</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Multi-Scale Analysis:"</span>)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="bu">len</span>(patch_sizes), figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, patch_size <span class="kw">in</span> <span class="bu">enumerate</span>(patch_sizes):</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(image, patch_size)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate scale-dependent information</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        patches_per_area <span class="op">=</span> <span class="bu">len</span>(patches) <span class="op">/</span> (image.shape[<span class="dv">0</span>] <span class="op">*</span> image.shape[<span class="dv">1</span>])</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        detail_level <span class="op">=</span> <span class="dv">1000</span> <span class="op">*</span> patches_per_area  <span class="co"># Patches per 1000 pixels</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Scale </span><span class="sc">{</span>idx<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches"</span>)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Total patches: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Detail level: </span><span class="sc">{</span>detail_level<span class="sc">:.2f}</span><span class="ss"> patches/1000px²"</span>)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Use case: </span><span class="sc">{</span><span class="st">'Fine details'</span> <span class="cf">if</span> patch_size <span class="op">&lt;=</span> <span class="dv">32</span> <span class="cf">else</span> <span class="st">'Broad patterns'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Visualize</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        ax.imshow(image[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show subset of patches to avoid clutter</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>        show_patches <span class="op">=</span> positions[::<span class="bu">max</span>(<span class="dv">1</span>, <span class="bu">len</span>(positions)<span class="op">//</span><span class="dv">12</span>)]  <span class="co"># Show ~12 patches</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x, y <span class="kw">in</span> show_patches:</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>                               linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>            ax.add_patch(rect)</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, image.shape[<span class="dv">1</span>])</span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(image.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Multi-Scale Patch Extraction'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>multi_scale_patch_extraction(satellite_img)</span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Multi-Scale Benefits:"</span>)</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Small patches: Capture fine details, textures, edges"</span>)</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Large patches: Capture spatial context, broad patterns"</span>)</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Combined: Enable hierarchical understanding"</span>)</span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Used in: Change detection, multi-resolution analysis"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Multi-Scale Analysis:
========================================
Scale 1: 16×16 patches
  Total patches: 77
  Detail level: 3.56 patches/1000px²
  Use case: Fine details
Scale 2: 32×32 patches
  Total patches: 15
  Detail level: 0.69 patches/1000px²
  Use case: Fine details
Scale 3: 64×64 patches
  Total patches: 2
  Detail level: 0.09 patches/1000px²
  Use case: Broad patterns</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-14-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
💡 Multi-Scale Benefits:
   • Small patches: Capture fine details, textures, edges
   • Large patches: Capture spatial context, broad patterns
   • Combined: Enable hierarchical understanding
   • Used in: Change detection, multi-resolution analysis</code></pre>
</div>
</div>
</section>
<section id="multi-temporal-patch-processing" class="level3">
<h3 class="anchored" data-anchor-id="multi-temporal-patch-processing">Multi-Temporal Patch Processing</h3>
<p>Many GFMs process time series of satellite imagery. Here’s how patch extraction works across time:</p>
<div id="f1418636" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_temporal_patches():</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how patches are extracted from multi-temporal imagery.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Critical for change detection and phenology monitoring.</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate time series (3 dates)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    dates <span class="op">=</span> [<span class="st">'2021-06-01'</span>, <span class="st">'2022-06-01'</span>, <span class="st">'2023-06-01'</span>]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create temporal changes (simulate seasonal/land use changes)</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    temporal_images <span class="op">=</span> []</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    base_img <span class="op">=</span> satellite_img.copy()</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, date <span class="kw">in</span> <span class="bu">enumerate</span>(dates):</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate temporal changes</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>        temp_img <span class="op">=</span> base_img.copy()</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate seasonal vegetation changes (NIR band changes)</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        vegetation_change <span class="op">=</span> np.sin(i <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> <span class="fl">0.3</span>  <span class="co"># Seasonal variation</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        temp_img[:, :, <span class="dv">3</span>] <span class="op">=</span> np.clip(temp_img[:, :, <span class="dv">3</span>] <span class="op">+</span> vegetation_change, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate some land cover change in a region</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:  <span class="co"># Changes start from second date</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            change_region <span class="op">=</span> <span class="bu">slice</span>(<span class="dv">40</span>, <span class="dv">80</span>), <span class="bu">slice</span>(<span class="dv">60</span>, <span class="dv">100</span>)</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>            temp_img[change_region] <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>]  <span class="co"># Urban development</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>        temporal_images.append(temp_img)</span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches from each time point</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    temporal_patch_sets <span class="op">=</span> []</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (img, date) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(temporal_images, dates)):</span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(img, patch_size)</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>        temporal_patch_sets.append(patches)</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show full image</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].imshow(img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>date<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_xticks([])</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_yticks([])</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Highlight a specific patch across time</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>        highlight_patch_idx <span class="op">=</span> <span class="dv">6</span>  <span class="co"># Same spatial location across all dates</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> positions[highlight_patch_idx]</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">3</span>, edgecolor<span class="op">=</span><span class="st">'yellow'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].add_patch(rect)</span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show the highlighted patch</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>        highlighted_patch <span class="op">=</span> patches[highlight_patch_idx]</span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].imshow(highlighted_patch[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'Patch </span><span class="sc">{</span>highlight_patch_idx<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>date<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_xticks([])</span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_yticks([])</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Multi-Temporal Patch Extraction (Same Spatial Location Over Time)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Analyze temporal patch consistency</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Temporal Patch Analysis:"</span>)</span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">30</span>)</span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Time points: </span><span class="sc">{</span><span class="bu">len</span>(dates)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patches per date: </span><span class="sc">{</span><span class="bu">len</span>(temporal_patch_sets[<span class="dv">0</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate change magnitude for the highlighted patch</span></span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>    patch_0 <span class="op">=</span> temporal_patch_sets[<span class="dv">0</span>][highlight_patch_idx]</span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>    patch_1 <span class="op">=</span> temporal_patch_sets[<span class="dv">1</span>][highlight_patch_idx] </span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a>    patch_2 <span class="op">=</span> temporal_patch_sets[<span class="dv">2</span>][highlight_patch_idx]</span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a>    change_1 <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(patch_1 <span class="op">-</span> patch_0))</span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a>    change_2 <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(patch_2 <span class="op">-</span> patch_1))</span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Change Analysis (Patch </span><span class="sc">{</span>highlight_patch_idx<span class="sc">}</span><span class="ss">):"</span>)</span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>dates[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>dates[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>change_1<span class="sc">:.3f}</span><span class="ss"> mean absolute change"</span>)</span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>dates[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>dates[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>change_2<span class="sc">:.3f}</span><span class="ss"> mean absolute change"</span>)</span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> temporal_patch_sets</span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a>temporal_patches <span class="op">=</span> demonstrate_temporal_patches()</span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🕐 Temporal Processing Insights:"</span>)</span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Same spatial patches tracked over time"</span>)</span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Enables change detection and trend analysis"</span>) </span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Requires careful image registration (alignment)"</span>)</span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Used in: Crop monitoring, deforestation detection, urban growth"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Temporal Patch Analysis:
==============================
Patch size: 40×40
Time points: 3
Patches per date: 12

Change Analysis (Patch 6):
  2021-06-01 → 2022-06-01: 0.141 mean absolute change
  2022-06-01 → 2023-06-01: 0.027 mean absolute change

🕐 Temporal Processing Insights:
   • Same spatial patches tracked over time
   • Enables change detection and trend analysis
   • Requires careful image registration (alignment)
   • Used in: Crop monitoring, deforestation detection, urban growth</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="connection-to-foundation-model-architectures" class="level2">
<h2 class="anchored" data-anchor-id="connection-to-foundation-model-architectures">Connection to Foundation Model Architectures</h2>
<section id="how-different-gfms-handle-patches" class="level3">
<h3 class="anchored" data-anchor-id="how-different-gfms-handle-patches">How Different GFMs Handle Patches</h3>
<p>Different geospatial foundation models make different choices about patch processing. Let’s examine some real examples:</p>
<div id="5ac49727" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_gfm_architectures():</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Compare patch handling across different geospatial foundation models.</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    gfm_configs <span class="op">=</span> {</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Prithvi (IBM)'</span>: {</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">16</span>,</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">6</span>,  <span class="co"># HLS bands</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">768</span>,</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Multi-spectral analysis'</span>,</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Pre-trained on HLS (Landsat + Sentinel-2)'</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">'SatMAE (Microsoft)'</span>: {</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">16</span>, </span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">4</span>,  <span class="co"># RGB + NIR</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">1024</span>,</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Self-supervised pretraining'</span>,</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Masked autoencoder approach'</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Scale-MAE'</span>: {</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">8</span>,</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">10</span>,  <span class="co"># Sentinel-2 bands</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">512</span>, </span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Multi-scale analysis'</span>,</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Handles multiple resolutions'</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Our Custom GFM'</span>: {</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">32</span>,</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">4</span>,</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">256</span>,</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Tutorial example'</span>,</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Designed for this course'</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Geospatial Foundation Model Architectures"</span>)</span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Model'</span><span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patch'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Bands'</span><span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Embed'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Use Case'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> model, config <span class="kw">in</span> gfm_configs.items():</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>        patch_str <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>config[<span class="st">'patch_size'</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>config[<span class="st">'patch_size'</span>]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>model<span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span>patch_str<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'bands'</span>]<span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'embed_dim'</span>]<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'use_case'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate tokens per image for each model</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Tokens per Landsat Scene (7791×7611 pixels):"</span>)</span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>    landsat_h, landsat_w <span class="op">=</span> <span class="dv">7791</span>, <span class="dv">7611</span></span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> model, config <span class="kw">in</span> gfm_configs.items():</span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> config[<span class="st">'patch_size'</span>]</span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a>        patches_y <span class="op">=</span> landsat_h <span class="op">//</span> patch_size</span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a>        patches_x <span class="op">=</span> landsat_w <span class="op">//</span> patch_size</span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a>        total_tokens <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>model<span class="sc">:&lt;20}</span><span class="ss">: </span><span class="sc">{</span>total_tokens<span class="sc">:&gt;8,}</span><span class="ss"> tokens"</span>)</span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize patch sizes</span></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>    models <span class="op">=</span> <span class="bu">list</span>(gfm_configs.keys())</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, model <span class="kw">in</span> <span class="bu">enumerate</span>(models):</span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a>        config <span class="op">=</span> gfm_configs[model]</span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> config[<span class="st">'patch_size'</span>]</span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a sample image region</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a>        sample_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a>        sample_img <span class="op">=</span> satellite_img[:sample_size, :sample_size, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]]</span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>        ax.imshow(sample_img)</span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Draw patch grid</span></span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, sample_size, patch_size):</span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, sample_size, patch_size):</span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x <span class="op">+</span> patch_size <span class="op">&lt;=</span> sample_size <span class="kw">and</span> y <span class="op">+</span> patch_size <span class="op">&lt;=</span> sample_size:</span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a>                    rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a>                                       linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a>                    ax.add_patch(rect)</span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, sample_size)</span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(sample_size, <span class="dv">0</span>)</span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>model<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-89"><a href="#cb30-89" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Patch Sizes in Different GFMs'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb30-90"><a href="#cb30-90" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb30-91"><a href="#cb30-91" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb30-92"><a href="#cb30-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-93"><a href="#cb30-93" aria-hidden="true" tabindex="-1"></a>compare_gfm_architectures()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Geospatial Foundation Model Architectures
============================================================
Model                Patch    Bands  Embed    Use Case
------------------------------------------------------------
Prithvi (IBM)        16×16    6      768      Multi-spectral analysis
SatMAE (Microsoft)   16×16    4      1024     Self-supervised pretraining
Scale-MAE            8×8      10     512      Multi-scale analysis
Our Custom GFM       32×32    4      256      Tutorial example

Tokens per Landsat Scene (7791×7611 pixels):
--------------------------------------------------
Prithvi (IBM)       :  230,850 tokens
SatMAE (Microsoft)  :  230,850 tokens
Scale-MAE           :  925,323 tokens
Our Custom GFM      :   57,591 tokens</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-16-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="masked-autoencoder-training" class="level3">
<h3 class="anchored" data-anchor-id="masked-autoencoder-training">Masked Autoencoder Training</h3>
<p>Many modern GFMs use masked autoencoder (MAE) training. Let’s demonstrate how masking works with patches:</p>
<div id="cb3cc5f2" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_mae_masking(patches, mask_ratio<span class="op">=</span><span class="fl">0.75</span>):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how masked autoencoder training works with satellite image patches.</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">    This is the core training strategy for many modern GFMs.</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    n_patches <span class="op">=</span> <span class="bu">len</span>(patches)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    n_masked <span class="op">=</span> <span class="bu">int</span>(n_patches <span class="op">*</span> mask_ratio)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Masked Autoencoder (MAE) Training"</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patches: </span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mask ratio: </span><span class="sc">{</span>mask_ratio<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>n_masked<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss"> patches masked)"</span>)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Visible patches: </span><span class="sc">{</span>n_patches <span class="op">-</span> n_masked<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create random mask</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    mask_indices <span class="op">=</span> np.random.choice(n_patches, n_masked, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct image grid for visualization</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    grid_size <span class="op">=</span> <span class="bu">int</span>(np.ceil(np.sqrt(n_patches)))</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Infer patch size and handle channel ordering robustly when visualizing</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    patch <span class="op">=</span> patches[<span class="dv">0</span>]</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> patch.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patch.shape[<span class="dv">0</span>]</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> patch.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patch.shape[<span class="dv">1</span>]</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patches.shape[<span class="dv">1</span>]</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create full image from patches</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    full_img <span class="op">=</span> np.zeros((grid_size <span class="op">*</span> patch_size, grid_size <span class="op">*</span> patch_size, <span class="dv">3</span>))</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    masked_img <span class="op">=</span> full_img.copy()</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches):</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> i <span class="op">//</span> grid_size</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> i <span class="op">%</span> grid_size</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a>        start_y <span class="op">=</span> row <span class="op">*</span> patch_size</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>        end_y <span class="op">=</span> start_y <span class="op">+</span> patch_size</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>        start_x <span class="op">=</span> col <span class="op">*</span> patch_size</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>        end_x <span class="op">=</span> start_x <span class="op">+</span> patch_size</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract an RGB visualization with channels-last ordering</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>        patch_i <span class="op">=</span> patches[i]</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>            patch_rgb <span class="op">=</span> patch_i[..., :<span class="dv">3</span>]</span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>            patch_rgb <span class="op">=</span> np.transpose(patch_i[:<span class="dv">3</span>, ...], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fallback for single-channel patches: replicate to 3 channels</span></span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.repeat(patch_i, <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.repeat(np.transpose(patch_i, (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)), <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Last resort: ensure shape (H, W, 3)</span></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> patch_i.shape[<span class="dv">0</span>]</span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a>                w <span class="op">=</span> patch_i.shape[<span class="dv">1</span>]</span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.zeros((h, w, <span class="dv">3</span>))</span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a>        full_img[start_y:end_y, start_x:end_x] <span class="op">=</span> patch_rgb</span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mask selected patches</span></span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> mask_indices:</span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a>            masked_img[start_y:end_y, start_x:end_x] <span class="op">=</span> patch_rgb</span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize MAE process</span></span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image</span></span>
<span id="cb32-72"><a href="#cb32-72" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(full_img)</span>
<span id="cb32-73"><a href="#cb32-73" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">'Original Image'</span>)</span>
<span id="cb32-74"><a href="#cb32-74" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb32-75"><a href="#cb32-75" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb32-76"><a href="#cb32-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-77"><a href="#cb32-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Masked image (input to encoder)</span></span>
<span id="cb32-78"><a href="#cb32-78" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(masked_img)</span>
<span id="cb32-79"><a href="#cb32-79" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Masked Input</span><span class="ch">\n</span><span class="ss">(</span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>mask_ratio)<span class="sc">:.0f}</span><span class="ss">% visible)'</span>)</span>
<span id="cb32-80"><a href="#cb32-80" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb32-81"><a href="#cb32-81" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb32-82"><a href="#cb32-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-83"><a href="#cb32-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight masked regions</span></span>
<span id="cb32-84"><a href="#cb32-84" aria-hidden="true" tabindex="-1"></a>    reconstruction_img <span class="op">=</span> full_img.copy()</span>
<span id="cb32-85"><a href="#cb32-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches):</span>
<span id="cb32-86"><a href="#cb32-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> mask_indices:</span>
<span id="cb32-87"><a href="#cb32-87" aria-hidden="true" tabindex="-1"></a>            row <span class="op">=</span> i <span class="op">//</span> grid_size</span>
<span id="cb32-88"><a href="#cb32-88" aria-hidden="true" tabindex="-1"></a>            col <span class="op">=</span> i <span class="op">%</span> grid_size</span>
<span id="cb32-89"><a href="#cb32-89" aria-hidden="true" tabindex="-1"></a>            start_y <span class="op">=</span> row <span class="op">*</span> patch_size</span>
<span id="cb32-90"><a href="#cb32-90" aria-hidden="true" tabindex="-1"></a>            end_y <span class="op">=</span> start_y <span class="op">+</span> patch_size</span>
<span id="cb32-91"><a href="#cb32-91" aria-hidden="true" tabindex="-1"></a>            start_x <span class="op">=</span> col <span class="op">*</span> patch_size</span>
<span id="cb32-92"><a href="#cb32-92" aria-hidden="true" tabindex="-1"></a>            end_x <span class="op">=</span> start_x <span class="op">+</span> patch_size</span>
<span id="cb32-93"><a href="#cb32-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-94"><a href="#cb32-94" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add red tint to show what needs reconstruction</span></span>
<span id="cb32-95"><a href="#cb32-95" aria-hidden="true" tabindex="-1"></a>            reconstruction_img[start_y:end_y, start_x:end_x, <span class="dv">0</span>] <span class="op">=</span> np.minimum(</span>
<span id="cb32-96"><a href="#cb32-96" aria-hidden="true" tabindex="-1"></a>                reconstruction_img[start_y:end_y, start_x:end_x, <span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.3</span>, <span class="fl">1.0</span>)</span>
<span id="cb32-97"><a href="#cb32-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-98"><a href="#cb32-98" aria-hidden="true" tabindex="-1"></a>    ax3.imshow(reconstruction_img)</span>
<span id="cb32-99"><a href="#cb32-99" aria-hidden="true" tabindex="-1"></a>    ax3.set_title(<span class="st">'Reconstruction Target</span><span class="ch">\n</span><span class="st">(Red = masked patches)'</span>)</span>
<span id="cb32-100"><a href="#cb32-100" aria-hidden="true" tabindex="-1"></a>    ax3.set_xticks([])</span>
<span id="cb32-101"><a href="#cb32-101" aria-hidden="true" tabindex="-1"></a>    ax3.set_yticks([])</span>
<span id="cb32-102"><a href="#cb32-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-103"><a href="#cb32-103" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Masked Autoencoder Training Process'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb32-104"><a href="#cb32-104" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb32-105"><a href="#cb32-105" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb32-106"><a href="#cb32-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-107"><a href="#cb32-107" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">🎯 MAE Training Process:"</span>)</span>
<span id="cb32-108"><a href="#cb32-108" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   1. Randomly mask </span><span class="sc">{</span>mask_ratio<span class="sc">:.0%}</span><span class="ss"> of patches"</span>)</span>
<span id="cb32-109"><a href="#cb32-109" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   2. Encoder processes only visible patches"</span>)</span>
<span id="cb32-110"><a href="#cb32-110" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   3. Decoder reconstructs all patches"</span>)</span>
<span id="cb32-111"><a href="#cb32-111" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   4. Loss computed only on masked patches"</span>)</span>
<span id="cb32-112"><a href="#cb32-112" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   5. Model learns spatial relationships and context"</span>)</span>
<span id="cb32-113"><a href="#cb32-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-114"><a href="#cb32-114" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mask_indices</span>
<span id="cb32-115"><a href="#cb32-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-116"><a href="#cb32-116" aria-hidden="true" tabindex="-1"></a>mask_indices <span class="op">=</span> demonstrate_mae_masking(patches)</span>
<span id="cb32-117"><a href="#cb32-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-118"><a href="#cb32-118" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🔍 Why MAE Works for Satellite Imagery:"</span>)</span>
<span id="cb32-119"><a href="#cb32-119" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Forces model to understand spatial context"</span>)</span>
<span id="cb32-120"><a href="#cb32-120" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Learns spectral relationships between bands"</span>)  </span>
<span id="cb32-121"><a href="#cb32-121" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Captures seasonal and phenological patterns"</span>)</span>
<span id="cb32-122"><a href="#cb32-122" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Creates transferable representations"</span>)</span>
<span id="cb32-123"><a href="#cb32-123" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Reduces need for labeled training data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Masked Autoencoder (MAE) Training
========================================
Total patches: 24
Mask ratio: 0.75 (18/24 patches masked)
Visible patches: 6</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-17-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
🎯 MAE Training Process:
   1. Randomly mask 75% of patches
   2. Encoder processes only visible patches
   3. Decoder reconstructs all patches
   4. Loss computed only on masked patches
   5. Model learns spatial relationships and context

🔍 Why MAE Works for Satellite Imagery:
   • Forces model to understand spatial context
   • Learns spectral relationships between bands
   • Captures seasonal and phenological patterns
   • Creates transferable representations
   • Reduces need for labeled training data</code></pre>
</div>
</div>
<hr>
</section>
</section>
<section id="performance-optimization-and-practical-considerations" class="level2">
<h2 class="anchored" data-anchor-id="performance-optimization-and-practical-considerations">Performance Optimization and Practical Considerations</h2>
<section id="memory-efficient-batch-processing" class="level3">
<h3 class="anchored" data-anchor-id="memory-efficient-batch-processing">Memory-Efficient Batch Processing</h3>
<p>When working with large satellite images, you need efficient strategies for processing patches in batches:</p>
<div id="766df23d" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_efficient_processing():</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Show memory-efficient strategies for processing large numbers of patches.</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate a large satellite image</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    large_img_shape <span class="op">=</span> (<span class="dv">2000</span>, <span class="dv">3000</span>, <span class="dv">6</span>)  <span class="co"># Realistic size</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate patch requirements</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    patches_y <span class="op">=</span> large_img_shape[<span class="dv">0</span>] <span class="op">//</span> patch_size</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    patches_x <span class="op">=</span> large_img_shape[<span class="dv">1</span>] <span class="op">//</span> patch_size  </span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    total_patches <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Memory calculations</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    patch_memory_bytes <span class="op">=</span> patch_size <span class="op">*</span> patch_size <span class="op">*</span> large_img_shape[<span class="dv">2</span>] <span class="op">*</span> <span class="dv">4</span>  <span class="co"># float32</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    total_patch_memory_gb <span class="op">=</span> (total_patches <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Large-Scale Processing Analysis"</span>)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Image size: </span><span class="sc">{</span>large_img_shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>large_img_shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>large_img_shape[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patches: </span><span class="sc">{</span>total_patches<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Memory per patch: </span><span class="sc">{</span>patch_memory_bytes<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss"> KB"</span>)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patch memory: </span><span class="sc">{</span>total_patch_memory_gb<span class="sc">:.2f}</span><span class="ss"> GB"</span>)</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Batch processing scenarios</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    gpu_memory_gb <span class="op">=</span> <span class="dv">16</span>  <span class="co"># Typical GPU</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    model_memory_gb <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Reserve for model weights</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    available_memory_gb <span class="op">=</span> gpu_memory_gb <span class="op">-</span> model_memory_gb</span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>    max_patches_per_batch <span class="op">=</span> <span class="bu">int</span>((available_memory_gb <span class="op">*</span> <span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>) <span class="op">/</span> patch_memory_bytes)</span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>    n_batches <span class="op">=</span> (total_patches <span class="op">+</span> max_patches_per_batch <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> max_patches_per_batch</span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Batch Processing Strategy:"</span>)</span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  GPU memory: </span><span class="sc">{</span>gpu_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>)</span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Model memory: </span><span class="sc">{</span>model_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>) </span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Available: </span><span class="sc">{</span>available_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>)</span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Max patches/batch: </span><span class="sc">{</span>max_patches_per_batch<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Batches needed: </span><span class="sc">{</span>n_batches<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show different batch size trade-offs</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    batch_sizes <span class="op">=</span> [<span class="dv">64</span>, <span class="dv">128</span>, <span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">1024</span>]</span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Batch Size Trade-offs:"</span>)</span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Batch Size'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Batches'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory (GB)'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Efficiency'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> batch_size <span class="kw">in</span> batch_sizes:</span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> batch_size <span class="op">&lt;=</span> max_patches_per_batch:</span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>            n_batches <span class="op">=</span> (total_patches <span class="op">+</span> batch_size <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> batch_size</span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>            memory_gb <span class="op">=</span> (batch_size <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>            efficiency <span class="op">=</span> <span class="st">"Optimal"</span> <span class="cf">if</span> batch_size <span class="op">==</span> max_patches_per_batch <span class="cf">else</span> <span class="st">"Good"</span></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>            n_batches <span class="op">=</span> <span class="st">"OOM"</span>  <span class="co"># Out of memory</span></span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a>            memory_gb <span class="op">=</span> (batch_size <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>            efficiency <span class="op">=</span> <span class="st">"Too large"</span></span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>batch_size<span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span>n_batches<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>memory_gb<span class="sc">:&lt;12.2f}</span><span class="ss"> </span><span class="sc">{</span>efficiency<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_patches_per_batch</span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a>optimal_batch_size <span class="op">=</span> demonstrate_efficient_processing()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Large-Scale Processing Analysis
========================================
Image size: 2000×3000×6
Patch size: 64×64
Total patches: 1,426
Memory per patch: 96.0 KB
Total patch memory: 0.13 GB

Batch Processing Strategy:
  GPU memory: 16 GB
  Model memory: 4 GB
  Available: 12 GB
  Max patches/batch: 131,072
  Batches needed: 1

Batch Size Trade-offs:
Batch Size   Batches  Memory (GB)  Efficiency
--------------------------------------------------
64           23       0.01         Good
128          12       0.01         Good
256          6        0.02         Good
512          3        0.05         Good
1024         2        0.09         Good</code></pre>
</div>
</div>
</section>
<section id="real-world-pipeline-implementation" class="level3">
<h3 class="anchored" data-anchor-id="real-world-pipeline-implementation">Real-World Pipeline Implementation</h3>
<p>Let’s put it all together with a realistic implementation that you might use in practice:</p>
<div id="faa67b3c" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_production_pipeline():</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate a production-ready patch extraction pipeline</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">    with all the considerations we've discussed.</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> SatelliteImageProcessor:</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, patch_size<span class="op">=</span><span class="dv">32</span>, stride<span class="op">=</span><span class="va">None</span>, padding<span class="op">=</span><span class="st">'reflect'</span>, </span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>                     batch_size<span class="op">=</span><span class="dv">256</span>, overlap_threshold<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.patch_size <span class="op">=</span> patch_size</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.stride <span class="op">=</span> stride <span class="cf">if</span> stride <span class="cf">else</span> patch_size</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.padding <span class="op">=</span> padding</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.batch_size <span class="op">=</span> batch_size</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.overlap_threshold <span class="op">=</span> overlap_threshold</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> extract_patches(<span class="va">self</span>, image):</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">"""Extract patches with specified strategy."""</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>            H, W, C <span class="op">=</span> image.shape</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply padding if needed</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.padding <span class="op">==</span> <span class="st">'reflect'</span>:</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>                pad_h <span class="op">=</span> <span class="va">self</span>.patch_size <span class="op">-</span> (H <span class="op">%</span> <span class="va">self</span>.patch_size) <span class="cf">if</span> H <span class="op">%</span> <span class="va">self</span>.patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>                pad_w <span class="op">=</span> <span class="va">self</span>.patch_size <span class="op">-</span> (W <span class="op">%</span> <span class="va">self</span>.patch_size) <span class="cf">if</span> W <span class="op">%</span> <span class="va">self</span>.patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>                    image <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), mode<span class="op">=</span><span class="st">'reflect'</span>)</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="va">self</span>.padding <span class="op">==</span> <span class="st">'crop'</span>:</span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>                crop_h <span class="op">=</span> (H <span class="op">//</span> <span class="va">self</span>.patch_size) <span class="op">*</span> <span class="va">self</span>.patch_size</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>                crop_w <span class="op">=</span> (W <span class="op">//</span> <span class="va">self</span>.patch_size) <span class="op">*</span> <span class="va">self</span>.patch_size</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>                image <span class="op">=</span> image[:crop_h, :crop_w, :]</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract patches</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>            patches <span class="op">=</span> []</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>            positions <span class="op">=</span> []</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>            H_new, W_new <span class="op">=</span> image.shape[:<span class="dv">2</span>]</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, H_new <span class="op">-</span> <span class="va">self</span>.patch_size <span class="op">+</span> <span class="dv">1</span>, <span class="va">self</span>.stride):</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, W_new <span class="op">-</span> <span class="va">self</span>.patch_size <span class="op">+</span> <span class="dv">1</span>, <span class="va">self</span>.stride):</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>                    patch <span class="op">=</span> image[y:y<span class="op">+</span><span class="va">self</span>.patch_size, x:x<span class="op">+</span><span class="va">self</span>.patch_size, :]</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>                    patches.append(patch)</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>                    positions.append((x, y))</span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.array(patches), positions, image.shape</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> process_in_batches(<span class="va">self</span>, patches, processing_func):</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>            <span class="co">"""Process patches in memory-efficient batches."""</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>            results <span class="op">=</span> []</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>            n_patches <span class="op">=</span> <span class="bu">len</span>(patches)</span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_patches, <span class="va">self</span>.batch_size):</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>                batch_end <span class="op">=</span> <span class="bu">min</span>(i <span class="op">+</span> <span class="va">self</span>.batch_size, n_patches)</span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>                batch <span class="op">=</span> patches[i:batch_end]</span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Simulate processing (could be model inference)</span></span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>                batch_results <span class="op">=</span> processing_func(batch)</span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>                results.extend(batch_results)</span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Processed batch </span><span class="sc">{</span>i<span class="op">//</span><span class="va">self</span><span class="sc">.</span>batch_size <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>(n_patches <span class="op">+</span> <span class="va">self</span>.batch_size <span class="op">-</span> <span class="dv">1</span>)<span class="op">//</span><span class="va">self</span><span class="sc">.</span>batch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> results</span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Demonstrate the pipeline</span></span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>    processor <span class="op">=</span> SatelliteImageProcessor(</span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>        patch_size<span class="op">=</span><span class="dv">32</span>,</span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a>        stride<span class="op">=</span><span class="dv">24</span>,  <span class="co"># 25% overlap</span></span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>        padding<span class="op">=</span><span class="st">'reflect'</span>,</span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>        batch_size<span class="op">=</span><span class="dv">64</span></span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Production Pipeline Demonstration"</span>)</span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a>    patches, positions, processed_shape <span class="op">=</span> processor.extract_patches(satellite_img)</span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Input image: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Processed image: </span><span class="sc">{</span>processed_shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patches extracted: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch overlap: </span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>(processor.patch_size <span class="op">-</span> processor.stride)<span class="op">/</span>processor<span class="sc">.</span>patch_size<span class="sc">:.0f}</span><span class="ss">%"</span>)</span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate processing function (could be model inference)</span></span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mock_processing(batch):</span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate model inference or feature extraction."""</span></span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return mean spectral values per patch as example</span></span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [np.mean(patch, axis<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="cf">for</span> patch <span class="kw">in</span> batch]</span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process in batches</span></span>
<span id="cb37-90"><a href="#cb37-90" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Processing </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches in batches of </span><span class="sc">{</span>processor<span class="sc">.</span>batch_size<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb37-91"><a href="#cb37-91" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> processor.process_in_batches(patches, mock_processing)</span>
<span id="cb37-92"><a href="#cb37-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-93"><a href="#cb37-93" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Processing complete!"</span>)</span>
<span id="cb37-94"><a href="#cb37-94" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Results shape: </span><span class="sc">{</span>np<span class="sc">.</span>array(results)<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb37-95"><a href="#cb37-95" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-96"><a href="#cb37-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize results (spectral signatures)</span></span>
<span id="cb37-97"><a href="#cb37-97" aria-hidden="true" tabindex="-1"></a>    results_array <span class="op">=</span> np.array(results)</span>
<span id="cb37-98"><a href="#cb37-98" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-99"><a href="#cb37-99" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb37-100"><a href="#cb37-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-101"><a href="#cb37-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show patch locations colored by first spectral band average</span></span>
<span id="cb37-102"><a href="#cb37-102" aria-hidden="true" tabindex="-1"></a>    x_coords <span class="op">=</span> [pos[<span class="dv">0</span>] <span class="op">+</span> processor.patch_size<span class="op">//</span><span class="dv">2</span> <span class="cf">for</span> pos <span class="kw">in</span> positions]</span>
<span id="cb37-103"><a href="#cb37-103" aria-hidden="true" tabindex="-1"></a>    y_coords <span class="op">=</span> [pos[<span class="dv">1</span>] <span class="op">+</span> processor.patch_size<span class="op">//</span><span class="dv">2</span> <span class="cf">for</span> pos <span class="kw">in</span> positions]</span>
<span id="cb37-104"><a href="#cb37-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-105"><a href="#cb37-105" aria-hidden="true" tabindex="-1"></a>    scatter <span class="op">=</span> ax1.scatter(x_coords, y_coords, c<span class="op">=</span>results_array[:, <span class="dv">0</span>], </span>
<span id="cb37-106"><a href="#cb37-106" aria-hidden="true" tabindex="-1"></a>                         cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb37-107"><a href="#cb37-107" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlim(<span class="dv">0</span>, satellite_img.shape[<span class="dv">1</span>])</span>
<span id="cb37-108"><a href="#cb37-108" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylim(satellite_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb37-109"><a href="#cb37-109" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">'Patch Results (Red Band Average)'</span>)</span>
<span id="cb37-110"><a href="#cb37-110" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlabel(<span class="st">'X Coordinate'</span>)</span>
<span id="cb37-111"><a href="#cb37-111" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylabel(<span class="st">'Y Coordinate'</span>)</span>
<span id="cb37-112"><a href="#cb37-112" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(scatter, ax<span class="op">=</span>ax1)</span>
<span id="cb37-113"><a href="#cb37-113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-114"><a href="#cb37-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show spectral signatures distribution</span></span>
<span id="cb37-115"><a href="#cb37-115" aria-hidden="true" tabindex="-1"></a>    band_names <span class="op">=</span> [<span class="st">'Red'</span>, <span class="st">'Green'</span>, <span class="st">'Blue'</span>, <span class="st">'NIR'</span>]</span>
<span id="cb37-116"><a href="#cb37-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(band_names):</span>
<span id="cb37-117"><a href="#cb37-117" aria-hidden="true" tabindex="-1"></a>        ax2.hist(results_array[:, i], bins<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span>band)</span>
<span id="cb37-118"><a href="#cb37-118" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-119"><a href="#cb37-119" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlabel(<span class="st">'Average Band Value'</span>)</span>
<span id="cb37-120"><a href="#cb37-120" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylabel(<span class="st">'Frequency'</span>)  </span>
<span id="cb37-121"><a href="#cb37-121" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="st">'Distribution of Spectral Values Across Patches'</span>)</span>
<span id="cb37-122"><a href="#cb37-122" aria-hidden="true" tabindex="-1"></a>    ax2.legend()</span>
<span id="cb37-123"><a href="#cb37-123" aria-hidden="true" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb37-124"><a href="#cb37-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-125"><a href="#cb37-125" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb37-126"><a href="#cb37-126" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb37-127"><a href="#cb37-127" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-128"><a href="#cb37-128" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> processor, results</span>
<span id="cb37-129"><a href="#cb37-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-130"><a href="#cb37-130" aria-hidden="true" tabindex="-1"></a>pipeline, processing_results <span class="op">=</span> create_production_pipeline()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Production Pipeline Demonstration
========================================
Input image: (120, 180, 4)
Processed image: (128, 192, 4)
Patches extracted: 35
Patch overlap: 25%

Processing 35 patches in batches of 64...
Processed batch 1/1
Processing complete!
Results shape: (35, 4)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="tiling-and-patches_files/figure-html/cell-19-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
</section>
</section>
<section id="key-takeaways-and-best-practices" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways-and-best-practices">Key Takeaways and Best Practices</h2>
<p>After working through these examples, here are the essential principles for effective patch extraction in geospatial foundation models:</p>
<section id="understand-your-memory-constraints" class="level3">
<h3 class="anchored" data-anchor-id="understand-your-memory-constraints">1. <strong>Understand Your Memory Constraints</strong></h3>
<ul>
<li>Calculate patch memory requirements before processing</li>
<li>Use batch processing for large images<br>
</li>
<li>Consider GPU memory limitations in your pipeline design</li>
</ul>
</section>
<section id="choose-patch-size-strategically" class="level3">
<h3 class="anchored" data-anchor-id="choose-patch-size-strategically">2. <strong>Choose Patch Size Strategically</strong></h3>
<ul>
<li><strong>Small patches (8-16px)</strong>: Capture fine details, more patches, higher memory</li>
<li><strong>Medium patches (32-64px)</strong>: Balance detail and context, most common choice</li>
<li><strong>Large patches (128px+)</strong>: Capture broad context, fewer patches, less memory</li>
</ul>
</section>
<section id="select-padding-strategy-based-on-your-use-case" class="level3">
<h3 class="anchored" data-anchor-id="select-padding-strategy-based-on-your-use-case">3. <strong>Select Padding Strategy Based on Your Use Case</strong></h3>
<ul>
<li><strong>Crop</strong>: Speed-critical applications, overlapping patches</li>
<li><strong>Zero padding</strong>: Complete coverage required, simple implementation</li>
<li><strong>Reflect padding</strong>: Image quality critical, natural imagery</li>
</ul>
</section>
<section id="consider-overlap-for-better-performance" class="level3">
<h3 class="anchored" data-anchor-id="consider-overlap-for-better-performance">4. <strong>Consider Overlap for Better Performance</strong></h3>
<ul>
<li><strong>No overlap</strong>: Fastest processing, good for classification</li>
<li><strong>25-50% overlap</strong>: Better boundary handling, moderate cost increase</li>
<li><strong>75%+ overlap</strong>: Maximum context, highest computational cost</li>
</ul>
</section>
<section id="plan-for-multi-scale-and-multi-temporal-processing" class="level3">
<h3 class="anchored" data-anchor-id="plan-for-multi-scale-and-multi-temporal-processing">5. <strong>Plan for Multi-Scale and Multi-Temporal Processing</strong></h3>
<ul>
<li>Design pipelines that can handle different patch sizes</li>
<li>Ensure spatial alignment across time series</li>
<li>Consider temporal consistency in patch extraction</li>
</ul>
</section>
<section id="optimize-for-your-specific-gfm-architecture" class="level3">
<h3 class="anchored" data-anchor-id="optimize-for-your-specific-gfm-architecture">6. <strong>Optimize for Your Specific GFM Architecture</strong></h3>
<ul>
<li>Match patch sizes to your model’s training configuration</li>
<li>Consider spectral band requirements</li>
<li>Plan for masked autoencoder training if applicable</li>
</ul>
<hr>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Patch extraction is far more than a simple preprocessing step—it’s a critical design choice that affects every aspect of your geospatial AI pipeline. The strategies we’ve explored provide a foundation for making informed decisions about:</p>
<ul>
<li><strong>Memory management</strong> and computational efficiency</li>
<li><strong>Information preservation</strong> vs.&nbsp;processing speed trade-offs<br>
</li>
<li><strong>Spatial context</strong> and boundary handling</li>
<li><strong>Multi-scale and temporal</strong> processing requirements</li>
<li><strong>Model architecture</strong> compatibility</li>
</ul>
<p>As you develop your own geospatial foundation models, remember that the “best” patch extraction strategy depends entirely on your specific use case, data characteristics, and computational constraints. Use these examples as starting points, but always validate your choices with your own data and requirements.</p>
<p>The techniques demonstrated here form the foundation for the more advanced topics we’ll explore in subsequent chapters, including attention mechanisms, self-supervised learning, and model deployment at scale.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kcaylor\.github\.io\/GEOG-288KC-geospatial-foundation-models");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb39" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Geospatial Patch Extraction for Foundation Models"</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "From Satellite Imagery to Vision Transformer Inputs"</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> geoai</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">    toc: true</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">    toc-depth: 3</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: false</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction: Why Patches Matter in Geospatial AI</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>When working with satellite imagery and geospatial foundation models (GFMs), one of the most critical preprocessing steps is **patch extraction** — the process of dividing large satellite images into smaller, manageable pieces that can be fed into neural networks. This isn't just a technical necessity; it's a fundamental design choice that affects everything from computational efficiency to model performance.</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Scale Challenge in Remote Sensing</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>Satellite images present unique challenges compared to natural images used in computer vision:</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Massive dimensions**: A single Landsat scene covers 185×185 kilometers at 30m resolution, resulting in images with dimensions of approximately 6,000×6,000 pixels per band</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Multi-spectral complexity**: Satellite imagery often contains 7-13 spectral bands (compared to 3 RGB channels in natural images)  </span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Memory constraints**: Loading a full Sentinel-2 scene (10,980×10,980 pixels × 13 bands) would require over 6GB of RAM as float32 arrays</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Computational limits**: Most GPUs cannot process such large images in a single forward pass</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a><span class="fu">### How Vision Transformers Process Images</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>Vision Transformers (ViTs), the architecture underlying most geospatial foundation models, don't process images as continuous arrays like Convolutional Neural Networks (CNNs). Instead, they:</span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Divide images into fixed-size patches** (typically 8×8, 16×16, or 32×32 pixels)</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Flatten each patch** into a 1D vector (e.g., a 16×16×3 patch becomes a 768-element vector)</span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Apply linear projection** to transform patch vectors into embedding space</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Add positional encodings** so the model knows where each patch came from spatially</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Process patches as a sequence** using self-attention mechanisms</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>This patch-based approach is why understanding patch extraction is crucial for working with GFMs — the quality of your patches directly impacts model performance.</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a><span class="fu">## Fundamental Concepts: From Images to Tokens</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Patch Extraction Pipeline</span></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a><span class="in">%%{init: { 'logLevel': 'debug' } }%%</span></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a><span class="in">graph TD</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a><span class="in">    A[Satellite Image&lt;br/&gt;H x W x C] --&gt; B[Spatial Tiling&lt;br/&gt;Divide into regions]</span></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a><span class="in">    B --&gt; C[Patch Extraction&lt;br/&gt;Fixed-size windows]</span></span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a><span class="in">    C --&gt; D[Patch Flattening&lt;br/&gt;3D to 1D vectors]</span></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a><span class="in">    D --&gt; E[Linear Projection&lt;br/&gt;To embedding space]</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a><span class="in">    E --&gt; F[Add Positional Encoding&lt;br/&gt;Spatial awareness]</span></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a><span class="in">    F --&gt; G[Token Sequence&lt;br/&gt;Ready for Transformer]</span></span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a><span class="in">    style A fill:#e1f5fe</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a><span class="in">    style G fill:#f3e5f5</span></span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-59"><a href="#cb39-59" aria-hidden="true" tabindex="-1"></a>Let's work through this pipeline step by step using real examples.</span>
<span id="cb39-60"><a href="#cb39-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-61"><a href="#cb39-61" aria-hidden="true" tabindex="-1"></a><span class="fu">### Step 1: Understanding Image Dimensions and Memory</span></span>
<span id="cb39-62"><a href="#cb39-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-63"><a href="#cb39-63" aria-hidden="true" tabindex="-1"></a>First, let's examine what we're working with when we load satellite imagery and why patches are necessary.</span>
<span id="cb39-64"><a href="#cb39-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-67"><a href="#cb39-67" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-68"><a href="#cb39-68" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb39-69"><a href="#cb39-69" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb39-70"><a href="#cb39-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-71"><a href="#cb39-71" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate dimensions of common satellite image types</span></span>
<span id="cb39-72"><a href="#cb39-72" aria-hidden="true" tabindex="-1"></a>satellite_scenarios <span class="op">=</span> {</span>
<span id="cb39-73"><a href="#cb39-73" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Landsat-8 Scene'</span>: {<span class="st">'height'</span>: <span class="dv">7611</span>, <span class="st">'width'</span>: <span class="dv">7791</span>, <span class="st">'bands'</span>: <span class="dv">11</span>, <span class="st">'pixel_size'</span>: <span class="dv">30</span>},</span>
<span id="cb39-74"><a href="#cb39-74" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Sentinel-2 Tile'</span>: {<span class="st">'height'</span>: <span class="dv">10980</span>, <span class="st">'width'</span>: <span class="dv">10980</span>, <span class="st">'bands'</span>: <span class="dv">13</span>, <span class="st">'pixel_size'</span>: <span class="dv">10</span>}, </span>
<span id="cb39-75"><a href="#cb39-75" aria-hidden="true" tabindex="-1"></a>    <span class="st">'MODIS Daily'</span>: {<span class="st">'height'</span>: <span class="dv">1200</span>, <span class="st">'width'</span>: <span class="dv">1200</span>, <span class="st">'bands'</span>: <span class="dv">36</span>, <span class="st">'pixel_size'</span>: <span class="dv">500</span>},</span>
<span id="cb39-76"><a href="#cb39-76" aria-hidden="true" tabindex="-1"></a>    <span class="st">'High-res Drone'</span>: {<span class="st">'height'</span>: <span class="dv">20000</span>, <span class="st">'width'</span>: <span class="dv">20000</span>, <span class="st">'bands'</span>: <span class="dv">3</span>, <span class="st">'pixel_size'</span>: <span class="fl">0.1</span>}</span>
<span id="cb39-77"><a href="#cb39-77" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-78"><a href="#cb39-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-79"><a href="#cb39-79" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Memory Requirements for Full Images (as float32):"</span>)</span>
<span id="cb39-80"><a href="#cb39-80" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb39-81"><a href="#cb39-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-82"><a href="#cb39-82" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, specs <span class="kw">in</span> satellite_scenarios.items():</span>
<span id="cb39-83"><a href="#cb39-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate total pixels</span></span>
<span id="cb39-84"><a href="#cb39-84" aria-hidden="true" tabindex="-1"></a>    total_pixels <span class="op">=</span> specs[<span class="st">'height'</span>] <span class="op">*</span> specs[<span class="st">'width'</span>] <span class="op">*</span> specs[<span class="st">'bands'</span>]</span>
<span id="cb39-85"><a href="#cb39-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-86"><a href="#cb39-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Memory in bytes (float32 = 4 bytes per value)</span></span>
<span id="cb39-87"><a href="#cb39-87" aria-hidden="true" tabindex="-1"></a>    memory_bytes <span class="op">=</span> total_pixels <span class="op">*</span> <span class="dv">4</span></span>
<span id="cb39-88"><a href="#cb39-88" aria-hidden="true" tabindex="-1"></a>    memory_gb <span class="op">=</span> memory_bytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb39-89"><a href="#cb39-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-90"><a href="#cb39-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Coverage area</span></span>
<span id="cb39-91"><a href="#cb39-91" aria-hidden="true" tabindex="-1"></a>    area_m2 <span class="op">=</span> (specs[<span class="st">'height'</span>] <span class="op">*</span> specs[<span class="st">'pixel_size'</span>]) <span class="op">*</span> (specs[<span class="st">'width'</span>] <span class="op">*</span> specs[<span class="st">'pixel_size'</span>])</span>
<span id="cb39-92"><a href="#cb39-92" aria-hidden="true" tabindex="-1"></a>    area_km2 <span class="op">=</span> area_m2 <span class="op">/</span> (<span class="dv">1000</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb39-93"><a href="#cb39-93" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-94"><a href="#cb39-94" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:20}</span><span class="ss"> | </span><span class="sc">{</span>specs[<span class="st">'height'</span>]<span class="sc">:5}</span><span class="ss">×</span><span class="sc">{</span>specs[<span class="st">'width'</span>]<span class="sc">:5}</span><span class="ss">×</span><span class="sc">{</span>specs[<span class="st">'bands'</span>]<span class="sc">:2}</span><span class="ss"> | </span><span class="sc">{</span>memory_gb<span class="sc">:5.2f}</span><span class="ss"> GB | </span><span class="sc">{</span>area_km2<span class="sc">:8.1f}</span><span class="ss"> km²"</span>)</span>
<span id="cb39-95"><a href="#cb39-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-96"><a href="#cb39-96" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Key Insight: Even 'small' satellite images require gigabytes of memory!"</span>)</span>
<span id="cb39-97"><a href="#cb39-97" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   Most GPUs have 8-24GB VRAM, so we must process images in smaller pieces."</span>)</span>
<span id="cb39-98"><a href="#cb39-98" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-99"><a href="#cb39-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-100"><a href="#cb39-100" aria-hidden="true" tabindex="-1"></a>This memory constraint is the primary **practical** reason for patch extraction, but there are also **theoretical** advantages:</span>
<span id="cb39-101"><a href="#cb39-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-102"><a href="#cb39-102" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Spatial attention**: Transformers can learn relationships between different spatial regions</span>
<span id="cb39-103"><a href="#cb39-103" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Scale invariance**: Models trained on patches can potentially handle images of any size  </span>
<span id="cb39-104"><a href="#cb39-104" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Data augmentation**: Each patch can be augmented independently, increasing training diversity</span>
<span id="cb39-105"><a href="#cb39-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-106"><a href="#cb39-106" aria-hidden="true" tabindex="-1"></a><span class="fu">### Step 2: Basic Patch Extraction Mechanics</span></span>
<span id="cb39-107"><a href="#cb39-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-108"><a href="#cb39-108" aria-hidden="true" tabindex="-1"></a>Let's start with a simple example to understand the mechanics. We'll create a synthetic satellite-like image and show how patches are extracted:</span>
<span id="cb39-109"><a href="#cb39-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-112"><a href="#cb39-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-113"><a href="#cb39-113" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a synthetic multi-spectral "satellite" image with realistic structure</span></span>
<span id="cb39-114"><a href="#cb39-114" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb39-115"><a href="#cb39-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-116"><a href="#cb39-116" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate different land cover types with distinct spectral signatures</span></span>
<span id="cb39-117"><a href="#cb39-117" aria-hidden="true" tabindex="-1"></a>height, width <span class="op">=</span> <span class="dv">120</span>, <span class="dv">180</span></span>
<span id="cb39-118"><a href="#cb39-118" aria-hidden="true" tabindex="-1"></a>bands <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Red, Green, Blue, NIR (Near-Infrared)</span></span>
<span id="cb39-119"><a href="#cb39-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-120"><a href="#cb39-120" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize image array</span></span>
<span id="cb39-121"><a href="#cb39-121" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">=</span> np.zeros((height, width, bands))</span>
<span id="cb39-122"><a href="#cb39-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-123"><a href="#cb39-123" aria-hidden="true" tabindex="-1"></a><span class="co"># Create realistic land cover patterns</span></span>
<span id="cb39-124"><a href="#cb39-124" aria-hidden="true" tabindex="-1"></a><span class="co"># Forest areas (low red, moderate green, low blue, high NIR)</span></span>
<span id="cb39-125"><a href="#cb39-125" aria-hidden="true" tabindex="-1"></a>forest_mask <span class="op">=</span> np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.3</span></span>
<span id="cb39-126"><a href="#cb39-126" aria-hidden="true" tabindex="-1"></a>satellite_img[forest_mask] <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>, <span class="fl">0.8</span>]</span>
<span id="cb39-127"><a href="#cb39-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-128"><a href="#cb39-128" aria-hidden="true" tabindex="-1"></a><span class="co"># Agricultural fields (moderate red, high green, low blue, very high NIR) </span></span>
<span id="cb39-129"><a href="#cb39-129" aria-hidden="true" tabindex="-1"></a>ag_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.4</span>)</span>
<span id="cb39-130"><a href="#cb39-130" aria-hidden="true" tabindex="-1"></a>satellite_img[ag_mask] <span class="op">=</span> [<span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="fl">0.2</span>, <span class="fl">0.9</span>]</span>
<span id="cb39-131"><a href="#cb39-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-132"><a href="#cb39-132" aria-hidden="true" tabindex="-1"></a><span class="co"># Urban areas (moderate all visible, low NIR)</span></span>
<span id="cb39-133"><a href="#cb39-133" aria-hidden="true" tabindex="-1"></a>urban_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (<span class="op">~</span>ag_mask) <span class="op">&amp;</span> (np.random.random((height, width)) <span class="op">&lt;</span> <span class="fl">0.5</span>)</span>
<span id="cb39-134"><a href="#cb39-134" aria-hidden="true" tabindex="-1"></a>satellite_img[urban_mask] <span class="op">=</span> [<span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.4</span>, <span class="fl">0.2</span>]</span>
<span id="cb39-135"><a href="#cb39-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-136"><a href="#cb39-136" aria-hidden="true" tabindex="-1"></a><span class="co"># Water bodies (low red, low green, moderate blue, very low NIR)</span></span>
<span id="cb39-137"><a href="#cb39-137" aria-hidden="true" tabindex="-1"></a>water_mask <span class="op">=</span> (<span class="op">~</span>forest_mask) <span class="op">&amp;</span> (<span class="op">~</span>ag_mask) <span class="op">&amp;</span> (<span class="op">~</span>urban_mask)</span>
<span id="cb39-138"><a href="#cb39-138" aria-hidden="true" tabindex="-1"></a>satellite_img[water_mask] <span class="op">=</span> [<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span>]</span>
<span id="cb39-139"><a href="#cb39-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-140"><a href="#cb39-140" aria-hidden="true" tabindex="-1"></a><span class="co"># Add some noise to make it more realistic</span></span>
<span id="cb39-141"><a href="#cb39-141" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">+=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.02</span>, satellite_img.shape)</span>
<span id="cb39-142"><a href="#cb39-142" aria-hidden="true" tabindex="-1"></a>satellite_img <span class="op">=</span> np.clip(satellite_img, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb39-143"><a href="#cb39-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-144"><a href="#cb39-144" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize using false color composite (NIR-Red-Green)</span></span>
<span id="cb39-145"><a href="#cb39-145" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-146"><a href="#cb39-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-147"><a href="#cb39-147" aria-hidden="true" tabindex="-1"></a><span class="co"># True color (RGB)</span></span>
<span id="cb39-148"><a href="#cb39-148" aria-hidden="true" tabindex="-1"></a>ax1.imshow(satellite_img[:, :, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]])  <span class="co"># Red, Green, Blue</span></span>
<span id="cb39-149"><a href="#cb39-149" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'True Color Composite (RGB)'</span>)</span>
<span id="cb39-150"><a href="#cb39-150" aria-hidden="true" tabindex="-1"></a>ax1.set_xticks([])</span>
<span id="cb39-151"><a href="#cb39-151" aria-hidden="true" tabindex="-1"></a>ax1.set_yticks([])</span>
<span id="cb39-152"><a href="#cb39-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-153"><a href="#cb39-153" aria-hidden="true" tabindex="-1"></a><span class="co"># False color (NIR-Red-Green) - vegetation appears red</span></span>
<span id="cb39-154"><a href="#cb39-154" aria-hidden="true" tabindex="-1"></a>false_color <span class="op">=</span> satellite_img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]]  <span class="co"># NIR, Red, Green</span></span>
<span id="cb39-155"><a href="#cb39-155" aria-hidden="true" tabindex="-1"></a>ax2.imshow(false_color)</span>
<span id="cb39-156"><a href="#cb39-156" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'False Color Composite (NIR-R-G)'</span>)</span>
<span id="cb39-157"><a href="#cb39-157" aria-hidden="true" tabindex="-1"></a>ax2.set_xticks([])</span>
<span id="cb39-158"><a href="#cb39-158" aria-hidden="true" tabindex="-1"></a>ax2.set_yticks([])</span>
<span id="cb39-159"><a href="#cb39-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-160"><a href="#cb39-160" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="ss">f'Synthetic Satellite Image: </span><span class="sc">{</span>height<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>width<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>bands<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>, y<span class="op">=</span><span class="fl">1.02</span>)</span>
<span id="cb39-161"><a href="#cb39-161" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb39-162"><a href="#cb39-162" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb39-163"><a href="#cb39-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-164"><a href="#cb39-164" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Image shape: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-165"><a href="#cb39-165" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Memory usage: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)<span class="sc">:.2f}</span><span class="ss"> MB"</span>)</span>
<span id="cb39-166"><a href="#cb39-166" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Spectral bands: Red, Green, Blue, Near-Infrared"</span>)</span>
<span id="cb39-167"><a href="#cb39-167" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-168"><a href="#cb39-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-169"><a href="#cb39-169" aria-hidden="true" tabindex="-1"></a>Now let's extract patches from this image and understand what happens at each step:</span>
<span id="cb39-170"><a href="#cb39-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-173"><a href="#cb39-173" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-174"><a href="#cb39-174" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_patches_with_visualization(image, patch_size, stride<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb39-175"><a href="#cb39-175" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-176"><a href="#cb39-176" aria-hidden="true" tabindex="-1"></a><span class="co">    Extract patches from a multi-spectral image and visualize the process.</span></span>
<span id="cb39-177"><a href="#cb39-177" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb39-178"><a href="#cb39-178" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb39-179"><a href="#cb39-179" aria-hidden="true" tabindex="-1"></a><span class="co">        image: numpy array of shape (H, W, C)</span></span>
<span id="cb39-180"><a href="#cb39-180" aria-hidden="true" tabindex="-1"></a><span class="co">        patch_size: int, size of square patches</span></span>
<span id="cb39-181"><a href="#cb39-181" aria-hidden="true" tabindex="-1"></a><span class="co">        stride: int, step size between patches (defaults to patch_size for non-overlapping)</span></span>
<span id="cb39-182"><a href="#cb39-182" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb39-183"><a href="#cb39-183" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb39-184"><a href="#cb39-184" aria-hidden="true" tabindex="-1"></a><span class="co">        patches: array of shape (n_patches, patch_size, patch_size, C)</span></span>
<span id="cb39-185"><a href="#cb39-185" aria-hidden="true" tabindex="-1"></a><span class="co">        patch_positions: list of (x, y) coordinates for each patch</span></span>
<span id="cb39-186"><a href="#cb39-186" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-187"><a href="#cb39-187" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> stride <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb39-188"><a href="#cb39-188" aria-hidden="true" tabindex="-1"></a>        stride <span class="op">=</span> patch_size</span>
<span id="cb39-189"><a href="#cb39-189" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-190"><a href="#cb39-190" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb39-191"><a href="#cb39-191" aria-hidden="true" tabindex="-1"></a>    patches <span class="op">=</span> []</span>
<span id="cb39-192"><a href="#cb39-192" aria-hidden="true" tabindex="-1"></a>    patch_positions <span class="op">=</span> []</span>
<span id="cb39-193"><a href="#cb39-193" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-194"><a href="#cb39-194" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate how many patches fit</span></span>
<span id="cb39-195"><a href="#cb39-195" aria-hidden="true" tabindex="-1"></a>    n_patches_y <span class="op">=</span> (H <span class="op">-</span> patch_size) <span class="op">//</span> stride <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb39-196"><a href="#cb39-196" aria-hidden="true" tabindex="-1"></a>    n_patches_x <span class="op">=</span> (W <span class="op">-</span> patch_size) <span class="op">//</span> stride <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb39-197"><a href="#cb39-197" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-198"><a href="#cb39-198" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb39-199"><a href="#cb39-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches_y):</span>
<span id="cb39-200"><a href="#cb39-200" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_patches_x):</span>
<span id="cb39-201"><a href="#cb39-201" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> i <span class="op">*</span> stride</span>
<span id="cb39-202"><a href="#cb39-202" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> j <span class="op">*</span> stride</span>
<span id="cb39-203"><a href="#cb39-203" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-204"><a href="#cb39-204" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Ensure patch doesn't exceed image boundaries</span></span>
<span id="cb39-205"><a href="#cb39-205" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> y <span class="op">+</span> patch_size <span class="op">&lt;=</span> H <span class="kw">and</span> x <span class="op">+</span> patch_size <span class="op">&lt;=</span> W:</span>
<span id="cb39-206"><a href="#cb39-206" aria-hidden="true" tabindex="-1"></a>                patch <span class="op">=</span> image[y:y<span class="op">+</span>patch_size, x:x<span class="op">+</span>patch_size, :]</span>
<span id="cb39-207"><a href="#cb39-207" aria-hidden="true" tabindex="-1"></a>                patches.append(patch)</span>
<span id="cb39-208"><a href="#cb39-208" aria-hidden="true" tabindex="-1"></a>                patch_positions.append((x, y))</span>
<span id="cb39-209"><a href="#cb39-209" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-210"><a href="#cb39-210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(patches), patch_positions</span>
<span id="cb39-211"><a href="#cb39-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-212"><a href="#cb39-212" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract patches</span></span>
<span id="cb39-213"><a href="#cb39-213" aria-hidden="true" tabindex="-1"></a>patch_size <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb39-214"><a href="#cb39-214" aria-hidden="true" tabindex="-1"></a>stride <span class="op">=</span> <span class="dv">30</span>  <span class="co"># Non-overlapping patches</span></span>
<span id="cb39-215"><a href="#cb39-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-216"><a href="#cb39-216" aria-hidden="true" tabindex="-1"></a>patches, positions <span class="op">=</span> extract_patches_with_visualization(satellite_img, patch_size, stride)</span>
<span id="cb39-217"><a href="#cb39-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-218"><a href="#cb39-218" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original image: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-219"><a href="#cb39-219" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-220"><a href="#cb39-220" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Stride: </span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss"> (overlap: </span><span class="sc">{</span>patch_size<span class="op">-</span>stride<span class="sc">}</span><span class="ss"> pixels)"</span>)</span>
<span id="cb39-221"><a href="#cb39-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patches extracted: </span><span class="sc">{</span>patches<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-222"><a href="#cb39-222" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch array shape: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-223"><a href="#cb39-223" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Memory per patch: </span><span class="sc">{</span>patches[<span class="dv">0</span>]<span class="sc">.</span>nbytes <span class="op">/</span> <span class="dv">1024</span><span class="sc">:.2f}</span><span class="ss"> KB"</span>)</span>
<span id="cb39-224"><a href="#cb39-224" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total patch memory: </span><span class="sc">{</span>patches<span class="sc">.</span>nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)<span class="sc">:.2f}</span><span class="ss"> MB"</span>)</span>
<span id="cb39-225"><a href="#cb39-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-226"><a href="#cb39-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-227"><a href="#cb39-227" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing the Patch Grid</span></span>
<span id="cb39-228"><a href="#cb39-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-229"><a href="#cb39-229" aria-hidden="true" tabindex="-1"></a>Understanding where patches come from spatially is crucial for interpreting model outputs later:</span>
<span id="cb39-230"><a href="#cb39-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-233"><a href="#cb39-233" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-234"><a href="#cb39-234" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize patch extraction grid on the original image</span></span>
<span id="cb39-235"><a href="#cb39-235" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb39-236"><a href="#cb39-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-237"><a href="#cb39-237" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the false color composite as background</span></span>
<span id="cb39-238"><a href="#cb39-238" aria-hidden="true" tabindex="-1"></a>ax.imshow(satellite_img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># NIR-Red-Green</span></span>
<span id="cb39-239"><a href="#cb39-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-240"><a href="#cb39-240" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw patch boundaries</span></span>
<span id="cb39-241"><a href="#cb39-241" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(positions):</span>
<span id="cb39-242"><a href="#cb39-242" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Draw patch boundary</span></span>
<span id="cb39-243"><a href="#cb39-243" aria-hidden="true" tabindex="-1"></a>    rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-244"><a href="#cb39-244" aria-hidden="true" tabindex="-1"></a>                        linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb39-245"><a href="#cb39-245" aria-hidden="true" tabindex="-1"></a>    ax.add_patch(rect)</span>
<span id="cb39-246"><a href="#cb39-246" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-247"><a href="#cb39-247" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Label first few patches to show indexing</span></span>
<span id="cb39-248"><a href="#cb39-248" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">9</span>:  <span class="co"># Only label first 9 patches to avoid clutter</span></span>
<span id="cb39-249"><a href="#cb39-249" aria-hidden="true" tabindex="-1"></a>        center_x, center_y <span class="op">=</span> x <span class="op">+</span> patch_size<span class="op">//</span><span class="dv">2</span>, y <span class="op">+</span> patch_size<span class="op">//</span><span class="dv">2</span></span>
<span id="cb39-250"><a href="#cb39-250" aria-hidden="true" tabindex="-1"></a>        ax.text(center_x, center_y, <span class="bu">str</span>(i), ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb39-251"><a href="#cb39-251" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'yellow'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb39-252"><a href="#cb39-252" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'black'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>))</span>
<span id="cb39-253"><a href="#cb39-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-254"><a href="#cb39-254" aria-hidden="true" tabindex="-1"></a>ax.set_xlim(<span class="dv">0</span>, satellite_img.shape[<span class="dv">1</span>])</span>
<span id="cb39-255"><a href="#cb39-255" aria-hidden="true" tabindex="-1"></a>ax.set_ylim(satellite_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-256"><a href="#cb39-256" aria-hidden="true" tabindex="-1"></a>ax.set_xticks([])</span>
<span id="cb39-257"><a href="#cb39-257" aria-hidden="true" tabindex="-1"></a>ax.set_yticks([])</span>
<span id="cb39-258"><a href="#cb39-258" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="ss">f'Patch Extraction Grid: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches, stride=</span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-259"><a href="#cb39-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-260"><a href="#cb39-260" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb39-261"><a href="#cb39-261" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb39-262"><a href="#cb39-262" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-263"><a href="#cb39-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-264"><a href="#cb39-264" aria-hidden="true" tabindex="-1"></a><span class="fu">### Step 3: From Patches to Tokens</span></span>
<span id="cb39-265"><a href="#cb39-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-266"><a href="#cb39-266" aria-hidden="true" tabindex="-1"></a>Now let's demonstrate how these patches become the input tokens that Vision Transformers process:</span>
<span id="cb39-267"><a href="#cb39-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-270"><a href="#cb39-270" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-271"><a href="#cb39-271" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> patches_to_tokens_demo(patches, embed_dim<span class="op">=</span><span class="dv">256</span>):</span>
<span id="cb39-272"><a href="#cb39-272" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-273"><a href="#cb39-273" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate the conversion from image patches to transformer tokens.</span></span>
<span id="cb39-274"><a href="#cb39-274" aria-hidden="true" tabindex="-1"></a><span class="co">    This simulates what happens inside a Vision Transformer.</span></span>
<span id="cb39-275"><a href="#cb39-275" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-276"><a href="#cb39-276" aria-hidden="true" tabindex="-1"></a>    n_patches, patch_h, patch_w, channels <span class="op">=</span> patches.shape</span>
<span id="cb39-277"><a href="#cb39-277" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-278"><a href="#cb39-278" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Flatten each patch into a 1D vector</span></span>
<span id="cb39-279"><a href="#cb39-279" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is what ViTs do: treat each patch as a "word" in a sequence</span></span>
<span id="cb39-280"><a href="#cb39-280" aria-hidden="true" tabindex="-1"></a>    flattened_patches <span class="op">=</span> patches.reshape(n_patches, patch_h <span class="op">*</span> patch_w <span class="op">*</span> channels)</span>
<span id="cb39-281"><a href="#cb39-281" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-282"><a href="#cb39-282" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Token Creation Process:"</span>)</span>
<span id="cb39-283"><a href="#cb39-283" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-284"><a href="#cb39-284" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"1. Input patches shape: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-285"><a href="#cb39-285" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - </span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss"> patches"</span>)  </span>
<span id="cb39-286"><a href="#cb39-286" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each patch: </span><span class="sc">{</span>patch_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_w<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>channels<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>patch_h<span class="op">*</span>patch_w<span class="op">*</span>channels<span class="sc">}</span><span class="ss"> values"</span>)</span>
<span id="cb39-287"><a href="#cb39-287" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"2. Flattened patches: </span><span class="sc">{</span>flattened_patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-288"><a href="#cb39-288" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each patch becomes a </span><span class="sc">{</span>flattened_patches<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">-dimensional vector"</span>)</span>
<span id="cb39-289"><a href="#cb39-289" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-290"><a href="#cb39-290" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Linear projection to embedding space (simplified simulation)</span></span>
<span id="cb39-291"><a href="#cb39-291" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In real ViTs, this is a learnable linear layer: nn.Linear(patch_dim, embed_dim)</span></span>
<span id="cb39-292"><a href="#cb39-292" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)  <span class="co"># For reproducible "projection"</span></span>
<span id="cb39-293"><a href="#cb39-293" aria-hidden="true" tabindex="-1"></a>    projection_matrix <span class="op">=</span> np.random.randn(flattened_patches.shape[<span class="dv">1</span>], embed_dim) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb39-294"><a href="#cb39-294" aria-hidden="true" tabindex="-1"></a>    token_embeddings <span class="op">=</span> flattened_patches <span class="op">@</span> projection_matrix</span>
<span id="cb39-295"><a href="#cb39-295" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-296"><a href="#cb39-296" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"3. Linear projection to embeddings: </span><span class="sc">{</span>token_embeddings<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-297"><a href="#cb39-297" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each token now has </span><span class="sc">{</span>embed_dim<span class="sc">}</span><span class="ss"> dimensions"</span>)</span>
<span id="cb39-298"><a href="#cb39-298" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - These embeddings will be processed by transformer layers"</span>)</span>
<span id="cb39-299"><a href="#cb39-299" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-300"><a href="#cb39-300" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Add positional encodings (simplified)</span></span>
<span id="cb39-301"><a href="#cb39-301" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This tells the model where each patch came from spatially</span></span>
<span id="cb39-302"><a href="#cb39-302" aria-hidden="true" tabindex="-1"></a>    positions_2d <span class="op">=</span> np.array([(i <span class="op">%</span> <span class="bu">int</span>(np.sqrt(n_patches)), i <span class="op">//</span> <span class="bu">int</span>(np.sqrt(n_patches))) </span>
<span id="cb39-303"><a href="#cb39-303" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches)])</span>
<span id="cb39-304"><a href="#cb39-304" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-305"><a href="#cb39-305" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"4. Spatial positions: </span><span class="sc">{</span>positions_2d<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-306"><a href="#cb39-306" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - Each token gets x,y coordinates of its source patch"</span>)</span>
<span id="cb39-307"><a href="#cb39-307" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   - This preserves spatial relationships"</span>)</span>
<span id="cb39-308"><a href="#cb39-308" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-309"><a href="#cb39-309" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> token_embeddings, positions_2d</span>
<span id="cb39-310"><a href="#cb39-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-311"><a href="#cb39-311" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert our extracted patches to tokens</span></span>
<span id="cb39-312"><a href="#cb39-312" aria-hidden="true" tabindex="-1"></a>token_embeddings, spatial_positions <span class="op">=</span> patches_to_tokens_demo(patches)</span>
<span id="cb39-313"><a href="#cb39-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-314"><a href="#cb39-314" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize token statistics</span></span>
<span id="cb39-315"><a href="#cb39-315" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-316"><a href="#cb39-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-317"><a href="#cb39-317" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution of token embedding values</span></span>
<span id="cb39-318"><a href="#cb39-318" aria-hidden="true" tabindex="-1"></a>ax1.hist(token_embeddings.flatten(), bins<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, color<span class="op">=</span><span class="st">'skyblue'</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb39-319"><a href="#cb39-319" aria-hidden="true" tabindex="-1"></a>ax1.set_xlabel(<span class="st">'Embedding Value'</span>)</span>
<span id="cb39-320"><a href="#cb39-320" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb39-321"><a href="#cb39-321" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">'Distribution of Token Embedding Values'</span>)</span>
<span id="cb39-322"><a href="#cb39-322" aria-hidden="true" tabindex="-1"></a>ax1.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-323"><a href="#cb39-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-324"><a href="#cb39-324" aria-hidden="true" tabindex="-1"></a><span class="co"># Show spatial positions</span></span>
<span id="cb39-325"><a href="#cb39-325" aria-hidden="true" tabindex="-1"></a>ax2.scatter(spatial_positions[:, <span class="dv">0</span>], spatial_positions[:, <span class="dv">1</span>], </span>
<span id="cb39-326"><a href="#cb39-326" aria-hidden="true" tabindex="-1"></a>           c<span class="op">=</span><span class="bu">range</span>(<span class="bu">len</span>(spatial_positions)), cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb39-327"><a href="#cb39-327" aria-hidden="true" tabindex="-1"></a>ax2.set_xlabel(<span class="st">'Patch X Position'</span>)</span>
<span id="cb39-328"><a href="#cb39-328" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Patch Y Position'</span>)</span>
<span id="cb39-329"><a href="#cb39-329" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">'Spatial Positions of Tokens'</span>)</span>
<span id="cb39-330"><a href="#cb39-330" aria-hidden="true" tabindex="-1"></a>ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-331"><a href="#cb39-331" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(spatial_positions[:<span class="dv">9</span>]):  <span class="co"># Label first 9</span></span>
<span id="cb39-332"><a href="#cb39-332" aria-hidden="true" tabindex="-1"></a>    ax2.annotate(<span class="bu">str</span>(i), (x, y), xytext<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>), textcoords<span class="op">=</span><span class="st">'offset points'</span>, fontsize<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb39-333"><a href="#cb39-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-334"><a href="#cb39-334" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb39-335"><a href="#cb39-335" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb39-336"><a href="#cb39-336" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-337"><a href="#cb39-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-338"><a href="#cb39-338" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-339"><a href="#cb39-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-340"><a href="#cb39-340" aria-hidden="true" tabindex="-1"></a><span class="fu">## Real-World Considerations: Memory, Computation, and Scale</span></span>
<span id="cb39-341"><a href="#cb39-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-342"><a href="#cb39-342" aria-hidden="true" tabindex="-1"></a><span class="fu">### Computational Requirements Analysis</span></span>
<span id="cb39-343"><a href="#cb39-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-344"><a href="#cb39-344" aria-hidden="true" tabindex="-1"></a>Before diving into advanced techniques, let's understand the computational trade-offs involved in different patch extraction strategies:</span>
<span id="cb39-345"><a href="#cb39-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-348"><a href="#cb39-348" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-349"><a href="#cb39-349" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_computational_requirements():</span>
<span id="cb39-350"><a href="#cb39-350" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-351"><a href="#cb39-351" aria-hidden="true" tabindex="-1"></a><span class="co">    Analyze memory and computational requirements for different patch strategies</span></span>
<span id="cb39-352"><a href="#cb39-352" aria-hidden="true" tabindex="-1"></a><span class="co">    with real satellite imagery scenarios.</span></span>
<span id="cb39-353"><a href="#cb39-353" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-354"><a href="#cb39-354" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-355"><a href="#cb39-355" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Common GFM patch sizes used in literature</span></span>
<span id="cb39-356"><a href="#cb39-356" aria-hidden="true" tabindex="-1"></a>    patch_sizes <span class="op">=</span> [<span class="dv">8</span>, <span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>]</span>
<span id="cb39-357"><a href="#cb39-357" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-358"><a href="#cb39-358" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Realistic satellite image scenarios</span></span>
<span id="cb39-359"><a href="#cb39-359" aria-hidden="true" tabindex="-1"></a>    scenarios <span class="op">=</span> {</span>
<span id="cb39-360"><a href="#cb39-360" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Sentinel-2 10m'</span>: {<span class="st">'height'</span>: <span class="dv">10980</span>, <span class="st">'width'</span>: <span class="dv">10980</span>, <span class="st">'bands'</span>: <span class="dv">4</span>},  <span class="co"># RGB + NIR</span></span>
<span id="cb39-361"><a href="#cb39-361" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Landsat-8'</span>: {<span class="st">'height'</span>: <span class="dv">7791</span>, <span class="st">'width'</span>: <span class="dv">7611</span>, <span class="st">'bands'</span>: <span class="dv">7</span>},  <span class="co"># Selected bands</span></span>
<span id="cb39-362"><a href="#cb39-362" aria-hidden="true" tabindex="-1"></a>        <span class="st">'MODIS 250m'</span>: {<span class="st">'height'</span>: <span class="dv">4800</span>, <span class="st">'width'</span>: <span class="dv">4800</span>, <span class="st">'bands'</span>: <span class="dv">2</span>},  <span class="co"># Red + NIR</span></span>
<span id="cb39-363"><a href="#cb39-363" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Drone RGB'</span>: {<span class="st">'height'</span>: <span class="dv">8000</span>, <span class="st">'width'</span>: <span class="dv">8000</span>, <span class="st">'bands'</span>: <span class="dv">3</span>}   <span class="co"># High-res RGB</span></span>
<span id="cb39-364"><a href="#cb39-364" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb39-365"><a href="#cb39-365" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-366"><a href="#cb39-366" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Computational Analysis: Patches per Image"</span>)</span>
<span id="cb39-367"><a href="#cb39-367" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb39-368"><a href="#cb39-368" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Scenario'</span><span class="sc">:15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Image Size'</span><span class="sc">:12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patch'</span><span class="sc">:5}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patches'</span><span class="sc">:8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory/Batch'</span><span class="sc">:12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'GPU Batches'</span><span class="sc">:10}</span><span class="ss">"</span>)</span>
<span id="cb39-369"><a href="#cb39-369" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">80</span>)</span>
<span id="cb39-370"><a href="#cb39-370" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-371"><a href="#cb39-371" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> scenario_name, specs <span class="kw">in</span> scenarios.items():</span>
<span id="cb39-372"><a href="#cb39-372" aria-hidden="true" tabindex="-1"></a>        h, w, c <span class="op">=</span> specs[<span class="st">'height'</span>], specs[<span class="st">'width'</span>], specs[<span class="st">'bands'</span>]</span>
<span id="cb39-373"><a href="#cb39-373" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-374"><a href="#cb39-374" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> patch_size <span class="kw">in</span> patch_sizes:</span>
<span id="cb39-375"><a href="#cb39-375" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate non-overlapping patches</span></span>
<span id="cb39-376"><a href="#cb39-376" aria-hidden="true" tabindex="-1"></a>            patches_y <span class="op">=</span> h <span class="op">//</span> patch_size</span>
<span id="cb39-377"><a href="#cb39-377" aria-hidden="true" tabindex="-1"></a>            patches_x <span class="op">=</span> w <span class="op">//</span> patch_size  </span>
<span id="cb39-378"><a href="#cb39-378" aria-hidden="true" tabindex="-1"></a>            total_patches <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb39-379"><a href="#cb39-379" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-380"><a href="#cb39-380" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Memory per patch in MB (float32)</span></span>
<span id="cb39-381"><a href="#cb39-381" aria-hidden="true" tabindex="-1"></a>            patch_memory_mb <span class="op">=</span> (patch_size <span class="op">*</span> patch_size <span class="op">*</span> c <span class="op">*</span> <span class="dv">4</span>) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb39-382"><a href="#cb39-382" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-383"><a href="#cb39-383" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Typical GPU memory limit (assume 16GB for analysis)</span></span>
<span id="cb39-384"><a href="#cb39-384" aria-hidden="true" tabindex="-1"></a>            gpu_memory_gb <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb39-385"><a href="#cb39-385" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Reserve 4GB for model weights and intermediate activations</span></span>
<span id="cb39-386"><a href="#cb39-386" aria-hidden="true" tabindex="-1"></a>            available_memory_gb <span class="op">=</span> gpu_memory_gb <span class="op">-</span> <span class="dv">4</span></span>
<span id="cb39-387"><a href="#cb39-387" aria-hidden="true" tabindex="-1"></a>            available_memory_mb <span class="op">=</span> available_memory_gb <span class="op">*</span> <span class="dv">1024</span></span>
<span id="cb39-388"><a href="#cb39-388" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-389"><a href="#cb39-389" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Maximum patches per batch</span></span>
<span id="cb39-390"><a href="#cb39-390" aria-hidden="true" tabindex="-1"></a>            max_batch_size <span class="op">=</span> <span class="bu">int</span>(available_memory_mb <span class="op">/</span> patch_memory_mb)</span>
<span id="cb39-391"><a href="#cb39-391" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-392"><a href="#cb39-392" aria-hidden="true" tabindex="-1"></a>            <span class="co"># How many GPU batches needed to process full image</span></span>
<span id="cb39-393"><a href="#cb39-393" aria-hidden="true" tabindex="-1"></a>            batches_needed <span class="op">=</span> (total_patches <span class="op">+</span> max_batch_size <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> max_batch_size</span>
<span id="cb39-394"><a href="#cb39-394" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-395"><a href="#cb39-395" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>scenario_name<span class="sc">:15}</span><span class="ss"> </span><span class="sc">{</span>h<span class="sc">:4}</span><span class="ss">×</span><span class="sc">{</span>w<span class="sc">:4}</span><span class="ss"> </span><span class="sc">{</span>patch_size<span class="sc">:3}</span><span class="ss"> </span><span class="sc">{</span>total_patches<span class="sc">:8,}</span><span class="ss"> "</span></span>
<span id="cb39-396"><a href="#cb39-396" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"</span><span class="sc">{</span>patch_memory_mb<span class="sc">:7.2f}</span><span class="ss"> MB </span><span class="sc">{</span>batches_needed<span class="sc">:8}</span><span class="ss">"</span>)</span>
<span id="cb39-397"><a href="#cb39-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-398"><a href="#cb39-398" aria-hidden="true" tabindex="-1"></a>analyze_computational_requirements()</span>
<span id="cb39-399"><a href="#cb39-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-400"><a href="#cb39-400" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Key Insights:"</span>)</span>
<span id="cb39-401"><a href="#cb39-401" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Smaller patches = more patches = more GPU batches needed"</span>)</span>
<span id="cb39-402"><a href="#cb39-402" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Larger patches = fewer patches but higher memory per patch"</span>)</span>
<span id="cb39-403"><a href="#cb39-403" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Most real scenarios require multiple GPU batches for inference"</span>)</span>
<span id="cb39-404"><a href="#cb39-404" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Memory-compute trade-off is crucial for deployment planning"</span>)</span>
<span id="cb39-405"><a href="#cb39-405" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-406"><a href="#cb39-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-407"><a href="#cb39-407" aria-hidden="true" tabindex="-1"></a><span class="fu">### Overlapping Patches: Information vs. Computation Trade-offs</span></span>
<span id="cb39-408"><a href="#cb39-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-409"><a href="#cb39-409" aria-hidden="true" tabindex="-1"></a>Many GFMs use overlapping patches to capture more spatial context and improve boundary handling. Let's explore this trade-off:</span>
<span id="cb39-410"><a href="#cb39-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-413"><a href="#cb39-413" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-414"><a href="#cb39-414" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_overlap_effects(image, patch_size<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb39-415"><a href="#cb39-415" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-416"><a href="#cb39-416" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how different stride values affect patch overlap and information coverage.</span></span>
<span id="cb39-417"><a href="#cb39-417" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-418"><a href="#cb39-418" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-419"><a href="#cb39-419" aria-hidden="true" tabindex="-1"></a>    stride_values <span class="op">=</span> [<span class="dv">32</span>, <span class="dv">16</span>, <span class="dv">8</span>]  <span class="co"># 0%, 50%, 75% overlap</span></span>
<span id="cb39-420"><a href="#cb39-420" aria-hidden="true" tabindex="-1"></a>    overlap_percentages <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">50</span>, <span class="dv">75</span>]</span>
<span id="cb39-421"><a href="#cb39-421" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-422"><a href="#cb39-422" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb39-423"><a href="#cb39-423" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-424"><a href="#cb39-424" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, (stride, overlap_pct) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(stride_values, overlap_percentages)):</span>
<span id="cb39-425"><a href="#cb39-425" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb39-426"><a href="#cb39-426" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-427"><a href="#cb39-427" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract patches with this stride</span></span>
<span id="cb39-428"><a href="#cb39-428" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(image, patch_size, stride)</span>
<span id="cb39-429"><a href="#cb39-429" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-430"><a href="#cb39-430" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show image background</span></span>
<span id="cb39-431"><a href="#cb39-431" aria-hidden="true" tabindex="-1"></a>        ax.imshow(image[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb39-432"><a href="#cb39-432" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-433"><a href="#cb39-433" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Draw patch boundaries with different colors to show overlap</span></span>
<span id="cb39-434"><a href="#cb39-434" aria-hidden="true" tabindex="-1"></a>        colors <span class="op">=</span> [<span class="st">'red'</span>, <span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'orange'</span>, <span class="st">'purple'</span>, <span class="st">'cyan'</span>]</span>
<span id="cb39-435"><a href="#cb39-435" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (x, y) <span class="kw">in</span> <span class="bu">enumerate</span>(positions[:<span class="dv">18</span>]):  <span class="co"># Show first 18 patches</span></span>
<span id="cb39-436"><a href="#cb39-436" aria-hidden="true" tabindex="-1"></a>            color <span class="op">=</span> colors[i <span class="op">%</span> <span class="bu">len</span>(colors)]</span>
<span id="cb39-437"><a href="#cb39-437" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-438"><a href="#cb39-438" aria-hidden="true" tabindex="-1"></a>                               linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span>color, facecolor<span class="op">=</span>color, </span>
<span id="cb39-439"><a href="#cb39-439" aria-hidden="true" tabindex="-1"></a>                               alpha<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb39-440"><a href="#cb39-440" aria-hidden="true" tabindex="-1"></a>            ax.add_patch(rect)</span>
<span id="cb39-441"><a href="#cb39-441" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-442"><a href="#cb39-442" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, image.shape[<span class="dv">1</span>])</span>
<span id="cb39-443"><a href="#cb39-443" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(image.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-444"><a href="#cb39-444" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb39-445"><a href="#cb39-445" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb39-446"><a href="#cb39-446" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>overlap_pct<span class="sc">}</span><span class="ss">% Overlap</span><span class="ch">\n</span><span class="ss">Stride=</span><span class="sc">{</span>stride<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span><span class="bu">len</span>(positions)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-447"><a href="#cb39-447" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-448"><a href="#cb39-448" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="ss">f'Effect of Patch Overlap (patch size = </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-449"><a href="#cb39-449" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-450"><a href="#cb39-450" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-451"><a href="#cb39-451" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-452"><a href="#cb39-452" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Quantitative analysis</span></span>
<span id="cb39-453"><a href="#cb39-453" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Overlap Analysis:"</span>)</span>
<span id="cb39-454"><a href="#cb39-454" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb39-455"><a href="#cb39-455" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stride, overlap_pct <span class="kw">in</span> <span class="bu">zip</span>(stride_values, overlap_percentages):</span>
<span id="cb39-456"><a href="#cb39-456" aria-hidden="true" tabindex="-1"></a>        patches, _ <span class="op">=</span> extract_patches_with_visualization(image, patch_size, stride)</span>
<span id="cb39-457"><a href="#cb39-457" aria-hidden="true" tabindex="-1"></a>        memory_mb <span class="op">=</span> patches.nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb39-458"><a href="#cb39-458" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Overlap </span><span class="sc">{</span>overlap_pct<span class="sc">:2}</span><span class="ss">%: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">:3}</span><span class="ss"> patches, </span><span class="sc">{</span>memory_mb<span class="sc">:5.1f}</span><span class="ss"> MB"</span>)</span>
<span id="cb39-459"><a href="#cb39-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-460"><a href="#cb39-460" aria-hidden="true" tabindex="-1"></a>demonstrate_overlap_effects(satellite_img)</span>
<span id="cb39-461"><a href="#cb39-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-462"><a href="#cb39-462" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Overlap Trade-offs:"</span>)</span>
<span id="cb39-463"><a href="#cb39-463" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • More overlap = better spatial context + boundary handling"</span>)</span>
<span id="cb39-464"><a href="#cb39-464" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • More overlap = more patches = higher computational cost"</span>) </span>
<span id="cb39-465"><a href="#cb39-465" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Optimal overlap depends on your specific task requirements"</span>)</span>
<span id="cb39-466"><a href="#cb39-466" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Change detection often benefits from overlap"</span>)</span>
<span id="cb39-467"><a href="#cb39-467" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Classification tasks may not need much overlap"</span>)</span>
<span id="cb39-468"><a href="#cb39-468" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-469"><a href="#cb39-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-470"><a href="#cb39-470" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-471"><a href="#cb39-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-472"><a href="#cb39-472" aria-hidden="true" tabindex="-1"></a><span class="fu">## Handling Edge Cases: Padding Strategies for Real-World Data</span></span>
<span id="cb39-473"><a href="#cb39-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-474"><a href="#cb39-474" aria-hidden="true" tabindex="-1"></a>When working with satellite imagery, images rarely divide evenly into patches. Different padding strategies offer different trade-offs between information preservation, computational efficiency, and model performance.</span>
<span id="cb39-475"><a href="#cb39-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-476"><a href="#cb39-476" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Edge Problem</span></span>
<span id="cb39-477"><a href="#cb39-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-478"><a href="#cb39-478" aria-hidden="true" tabindex="-1"></a>Let's create a realistic scenario where image dimensions don't divide evenly by patch size:</span>
<span id="cb39-479"><a href="#cb39-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-482"><a href="#cb39-482" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-483"><a href="#cb39-483" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a satellite image with dimensions that don't divide evenly</span></span>
<span id="cb39-484"><a href="#cb39-484" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb39-485"><a href="#cb39-485" aria-hidden="true" tabindex="-1"></a>irregular_img <span class="op">=</span> np.random.rand(<span class="dv">155</span>, <span class="dv">237</span>, <span class="dv">4</span>)  <span class="co"># Irregular dimensions</span></span>
<span id="cb39-486"><a href="#cb39-486" aria-hidden="true" tabindex="-1"></a>irregular_img <span class="op">=</span> irregular_img <span class="op">*</span> <span class="fl">0.3</span> <span class="op">+</span> <span class="fl">0.4</span>  <span class="co"># Moderate intensity values</span></span>
<span id="cb39-487"><a href="#cb39-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-488"><a href="#cb39-488" aria-hidden="true" tabindex="-1"></a>patch_size <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb39-489"><a href="#cb39-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-490"><a href="#cb39-490" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the mismatch</span></span>
<span id="cb39-491"><a href="#cb39-491" aria-hidden="true" tabindex="-1"></a>patches_y <span class="op">=</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">//</span> patch_size</span>
<span id="cb39-492"><a href="#cb39-492" aria-hidden="true" tabindex="-1"></a>patches_x <span class="op">=</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">//</span> patch_size</span>
<span id="cb39-493"><a href="#cb39-493" aria-hidden="true" tabindex="-1"></a>leftover_y <span class="op">=</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">%</span> patch_size  </span>
<span id="cb39-494"><a href="#cb39-494" aria-hidden="true" tabindex="-1"></a>leftover_x <span class="op">=</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">%</span> patch_size</span>
<span id="cb39-495"><a href="#cb39-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-496"><a href="#cb39-496" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edge Problem Analysis:"</span>)</span>
<span id="cb39-497"><a href="#cb39-497" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-498"><a href="#cb39-498" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Image dimensions: </span><span class="sc">{</span>irregular_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>irregular_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-499"><a href="#cb39-499" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-500"><a href="#cb39-500" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Complete patches fit: </span><span class="sc">{</span>patches_y<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patches_x<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-501"><a href="#cb39-501" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Leftover pixels: </span><span class="sc">{</span>leftover_y<span class="sc">}</span><span class="ss"> rows, </span><span class="sc">{</span>leftover_x<span class="sc">}</span><span class="ss"> columns"</span>)</span>
<span id="cb39-502"><a href="#cb39-502" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Unusable area: </span><span class="sc">{</span>(leftover_y <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">+</span> leftover_x <span class="op">*</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">-</span> leftover_y <span class="op">*</span> leftover_x)<span class="sc">:.0f}</span><span class="ss"> pixels"</span>)</span>
<span id="cb39-503"><a href="#cb39-503" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Information loss: </span><span class="sc">{</span><span class="dv">100</span> <span class="op">*</span> (leftover_y <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>] <span class="op">+</span> leftover_x <span class="op">*</span> irregular_img.shape[<span class="dv">0</span>] <span class="op">-</span> leftover_y <span class="op">*</span> leftover_x) <span class="op">/</span> (irregular_img.shape[<span class="dv">0</span>] <span class="op">*</span> irregular_img.shape[<span class="dv">1</span>])<span class="sc">:.1f}</span><span class="ss">%"</span>)</span>
<span id="cb39-504"><a href="#cb39-504" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-505"><a href="#cb39-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-506"><a href="#cb39-506" aria-hidden="true" tabindex="-1"></a><span class="fu">### Strategy 1: Crop (Discard Incomplete Patches)</span></span>
<span id="cb39-507"><a href="#cb39-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-508"><a href="#cb39-508" aria-hidden="true" tabindex="-1"></a>**When to use**: Speed is critical, edge information is less important, or when using overlapping patches that provide edge coverage.</span>
<span id="cb39-509"><a href="#cb39-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-512"><a href="#cb39-512" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-513"><a href="#cb39-513" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_crop_strategy(image, patch_size):</span>
<span id="cb39-514"><a href="#cb39-514" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-515"><a href="#cb39-515" aria-hidden="true" tabindex="-1"></a><span class="co">    Show crop strategy: discard patches that don't fit completely.</span></span>
<span id="cb39-516"><a href="#cb39-516" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-517"><a href="#cb39-517" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb39-518"><a href="#cb39-518" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-519"><a href="#cb39-519" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate largest area that fits complete patches</span></span>
<span id="cb39-520"><a href="#cb39-520" aria-hidden="true" tabindex="-1"></a>    crop_h <span class="op">=</span> (H <span class="op">//</span> patch_size) <span class="op">*</span> patch_size</span>
<span id="cb39-521"><a href="#cb39-521" aria-hidden="true" tabindex="-1"></a>    crop_w <span class="op">=</span> (W <span class="op">//</span> patch_size) <span class="op">*</span> patch_size</span>
<span id="cb39-522"><a href="#cb39-522" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-523"><a href="#cb39-523" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Crop image</span></span>
<span id="cb39-524"><a href="#cb39-524" aria-hidden="true" tabindex="-1"></a>    cropped_img <span class="op">=</span> image[:crop_h, :crop_w, :]</span>
<span id="cb39-525"><a href="#cb39-525" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-526"><a href="#cb39-526" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches from cropped image</span></span>
<span id="cb39-527"><a href="#cb39-527" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(cropped_img, patch_size)</span>
<span id="cb39-528"><a href="#cb39-528" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-529"><a href="#cb39-529" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize</span></span>
<span id="cb39-530"><a href="#cb39-530" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-531"><a href="#cb39-531" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-532"><a href="#cb39-532" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image with crop boundary</span></span>
<span id="cb39-533"><a href="#cb39-533" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-534"><a href="#cb39-534" aria-hidden="true" tabindex="-1"></a>    crop_rect <span class="op">=</span> plt.Rectangle((<span class="dv">0</span>, <span class="dv">0</span>), crop_w, crop_h,</span>
<span id="cb39-535"><a href="#cb39-535" aria-hidden="true" tabindex="-1"></a>                             linewidth<span class="op">=</span><span class="dv">3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb39-536"><a href="#cb39-536" aria-hidden="true" tabindex="-1"></a>    ax1.add_patch(crop_rect)</span>
<span id="cb39-537"><a href="#cb39-537" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlim(<span class="dv">0</span>, W)</span>
<span id="cb39-538"><a href="#cb39-538" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylim(H, <span class="dv">0</span>)</span>
<span id="cb39-539"><a href="#cb39-539" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original Image: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ch">\n</span><span class="ss">Red box: kept area'</span>)</span>
<span id="cb39-540"><a href="#cb39-540" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb39-541"><a href="#cb39-541" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb39-542"><a href="#cb39-542" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-543"><a href="#cb39-543" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cropped image with patches</span></span>
<span id="cb39-544"><a href="#cb39-544" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(cropped_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-545"><a href="#cb39-545" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">12</span>]:  <span class="co"># Show first 12 patch boundaries</span></span>
<span id="cb39-546"><a href="#cb39-546" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-547"><a href="#cb39-547" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb39-548"><a href="#cb39-548" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb39-549"><a href="#cb39-549" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, crop_w)</span>
<span id="cb39-550"><a href="#cb39-550" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(crop_h, <span class="dv">0</span>)</span>
<span id="cb39-551"><a href="#cb39-551" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Cropped: </span><span class="sc">{</span>crop_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>crop_w<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-552"><a href="#cb39-552" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb39-553"><a href="#cb39-553" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb39-554"><a href="#cb39-554" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-555"><a href="#cb39-555" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 1: Crop (Discard Edge Data)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-556"><a href="#cb39-556" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-557"><a href="#cb39-557" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-558"><a href="#cb39-558" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-559"><a href="#cb39-559" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Statistics</span></span>
<span id="cb39-560"><a href="#cb39-560" aria-hidden="true" tabindex="-1"></a>    pixels_lost <span class="op">=</span> H <span class="op">*</span> W <span class="op">-</span> crop_h <span class="op">*</span> crop_w</span>
<span id="cb39-561"><a href="#cb39-561" aria-hidden="true" tabindex="-1"></a>    loss_percentage <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> pixels_lost <span class="op">/</span> (H <span class="op">*</span> W)</span>
<span id="cb39-562"><a href="#cb39-562" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-563"><a href="#cb39-563" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Crop Strategy Results:"</span>)</span>
<span id="cb39-564"><a href="#cb39-564" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>H<span class="op">*</span>W<span class="sc">:,}</span><span class="ss"> pixels"</span>)</span>
<span id="cb39-565"><a href="#cb39-565" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Cropped:  </span><span class="sc">{</span>crop_h<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>crop_w<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>crop_h<span class="op">*</span>crop_w<span class="sc">:,}</span><span class="ss"> pixels"</span>)</span>
<span id="cb39-566"><a href="#cb39-566" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Lost:     </span><span class="sc">{</span>pixels_lost<span class="sc">:,}</span><span class="ss"> pixels (</span><span class="sc">{</span>loss_percentage<span class="sc">:.1f}</span><span class="ss">%)"</span>)</span>
<span id="cb39-567"><a href="#cb39-567" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-568"><a href="#cb39-568" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-569"><a href="#cb39-569" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cropped_img, patches</span>
<span id="cb39-570"><a href="#cb39-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-571"><a href="#cb39-571" aria-hidden="true" tabindex="-1"></a>cropped_img, crop_patches <span class="op">=</span> demonstrate_crop_strategy(irregular_img, patch_size)</span>
<span id="cb39-572"><a href="#cb39-572" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-573"><a href="#cb39-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-574"><a href="#cb39-574" aria-hidden="true" tabindex="-1"></a><span class="fu">### Strategy 2: Zero Padding</span></span>
<span id="cb39-575"><a href="#cb39-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-576"><a href="#cb39-576" aria-hidden="true" tabindex="-1"></a>**When to use**: Complete coverage is essential, working with models robust to boundary artifacts, or when post-processing can handle padding effects.</span>
<span id="cb39-577"><a href="#cb39-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-580"><a href="#cb39-580" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-581"><a href="#cb39-581" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_zero_padding(image, patch_size):</span>
<span id="cb39-582"><a href="#cb39-582" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-583"><a href="#cb39-583" aria-hidden="true" tabindex="-1"></a><span class="co">    Show zero padding strategy: extend image with zeros to fit complete patches.</span></span>
<span id="cb39-584"><a href="#cb39-584" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-585"><a href="#cb39-585" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb39-586"><a href="#cb39-586" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-587"><a href="#cb39-587" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb39-588"><a href="#cb39-588" aria-hidden="true" tabindex="-1"></a>    pad_h <span class="op">=</span> patch_size <span class="op">-</span> (H <span class="op">%</span> patch_size) <span class="cf">if</span> H <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-589"><a href="#cb39-589" aria-hidden="true" tabindex="-1"></a>    pad_w <span class="op">=</span> patch_size <span class="op">-</span> (W <span class="op">%</span> patch_size) <span class="cf">if</span> W <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-590"><a href="#cb39-590" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-591"><a href="#cb39-591" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply zero padding</span></span>
<span id="cb39-592"><a href="#cb39-592" aria-hidden="true" tabindex="-1"></a>    padded_img <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), </span>
<span id="cb39-593"><a href="#cb39-593" aria-hidden="true" tabindex="-1"></a>                        mode<span class="op">=</span><span class="st">'constant'</span>, constant_values<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb39-594"><a href="#cb39-594" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-595"><a href="#cb39-595" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb39-596"><a href="#cb39-596" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(padded_img, patch_size)</span>
<span id="cb39-597"><a href="#cb39-597" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-598"><a href="#cb39-598" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize</span></span>
<span id="cb39-599"><a href="#cb39-599" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-600"><a href="#cb39-600" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-601"><a href="#cb39-601" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image</span></span>
<span id="cb39-602"><a href="#cb39-602" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-603"><a href="#cb39-603" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb39-604"><a href="#cb39-604" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb39-605"><a href="#cb39-605" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb39-606"><a href="#cb39-606" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-607"><a href="#cb39-607" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Padded image with patches</span></span>
<span id="cb39-608"><a href="#cb39-608" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(padded_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-609"><a href="#cb39-609" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-610"><a href="#cb39-610" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight padding areas</span></span>
<span id="cb39-611"><a href="#cb39-611" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb39-612"><a href="#cb39-612" aria-hidden="true" tabindex="-1"></a>        padding_rect <span class="op">=</span> plt.Rectangle((W<span class="op">-</span><span class="fl">0.5</span>, <span class="op">-</span><span class="fl">0.5</span>), pad_w, H,</span>
<span id="cb39-613"><a href="#cb39-613" aria-hidden="true" tabindex="-1"></a>                                   facecolor<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb39-614"><a href="#cb39-614" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(padding_rect)</span>
<span id="cb39-615"><a href="#cb39-615" aria-hidden="true" tabindex="-1"></a>        ax2.text(W <span class="op">+</span> pad_w<span class="op">/</span><span class="dv">2</span>, H<span class="op">/</span><span class="dv">2</span>, <span class="st">'Zero</span><span class="ch">\n</span><span class="st">Padding'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb39-616"><a href="#cb39-616" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'red'</span>, weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb39-617"><a href="#cb39-617" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-618"><a href="#cb39-618" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb39-619"><a href="#cb39-619" aria-hidden="true" tabindex="-1"></a>        padding_rect <span class="op">=</span> plt.Rectangle((<span class="op">-</span><span class="fl">0.5</span>, H<span class="op">-</span><span class="fl">0.5</span>), W <span class="op">+</span> pad_w, pad_h,</span>
<span id="cb39-620"><a href="#cb39-620" aria-hidden="true" tabindex="-1"></a>                                   facecolor<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, edgecolor<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb39-621"><a href="#cb39-621" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(padding_rect)</span>
<span id="cb39-622"><a href="#cb39-622" aria-hidden="true" tabindex="-1"></a>        ax2.text((W <span class="op">+</span> pad_w)<span class="op">/</span><span class="dv">2</span>, H <span class="op">+</span> pad_h<span class="op">/</span><span class="dv">2</span>, <span class="st">'Zero Padding'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb39-623"><a href="#cb39-623" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'red'</span>, weight<span class="op">=</span><span class="st">'bold'</span>)</span>
<span id="cb39-624"><a href="#cb39-624" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-625"><a href="#cb39-625" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show some patch boundaries</span></span>
<span id="cb39-626"><a href="#cb39-626" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">15</span>]:  <span class="co"># First 15 patches</span></span>
<span id="cb39-627"><a href="#cb39-627" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-628"><a href="#cb39-628" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb39-629"><a href="#cb39-629" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb39-630"><a href="#cb39-630" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-631"><a href="#cb39-631" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, padded_img.shape[<span class="dv">1</span>])</span>
<span id="cb39-632"><a href="#cb39-632" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(padded_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-633"><a href="#cb39-633" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Padded: </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-634"><a href="#cb39-634" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb39-635"><a href="#cb39-635" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb39-636"><a href="#cb39-636" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-637"><a href="#cb39-637" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 2: Zero Padding'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-638"><a href="#cb39-638" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-639"><a href="#cb39-639" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-640"><a href="#cb39-640" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-641"><a href="#cb39-641" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Zero Padding Results:"</span>)</span>
<span id="cb39-642"><a href="#cb39-642" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-643"><a href="#cb39-643" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padding:  +</span><span class="sc">{</span>pad_h<span class="sc">}</span><span class="ss"> rows, +</span><span class="sc">{</span>pad_w<span class="sc">}</span><span class="ss"> columns"</span>) </span>
<span id="cb39-644"><a href="#cb39-644" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padded:   </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-645"><a href="#cb39-645" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-646"><a href="#cb39-646" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-647"><a href="#cb39-647" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> padded_img, patches</span>
<span id="cb39-648"><a href="#cb39-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-649"><a href="#cb39-649" aria-hidden="true" tabindex="-1"></a>padded_img, pad_patches <span class="op">=</span> demonstrate_zero_padding(irregular_img, patch_size)</span>
<span id="cb39-650"><a href="#cb39-650" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-651"><a href="#cb39-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-652"><a href="#cb39-652" aria-hidden="true" tabindex="-1"></a><span class="fu">### Strategy 3: Reflect Padding</span></span>
<span id="cb39-653"><a href="#cb39-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-654"><a href="#cb39-654" aria-hidden="true" tabindex="-1"></a>**When to use**: Image quality is critical, working with natural imagery where structure matters, or when models are sensitive to boundary artifacts.</span>
<span id="cb39-655"><a href="#cb39-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-658"><a href="#cb39-658" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-659"><a href="#cb39-659" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_reflect_padding(image, patch_size):</span>
<span id="cb39-660"><a href="#cb39-660" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-661"><a href="#cb39-661" aria-hidden="true" tabindex="-1"></a><span class="co">    Show reflect padding: mirror edge pixels for natural boundaries.</span></span>
<span id="cb39-662"><a href="#cb39-662" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-663"><a href="#cb39-663" aria-hidden="true" tabindex="-1"></a>    H, W, C <span class="op">=</span> image.shape</span>
<span id="cb39-664"><a href="#cb39-664" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-665"><a href="#cb39-665" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate padding needed</span></span>
<span id="cb39-666"><a href="#cb39-666" aria-hidden="true" tabindex="-1"></a>    pad_h <span class="op">=</span> patch_size <span class="op">-</span> (H <span class="op">%</span> patch_size) <span class="cf">if</span> H <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-667"><a href="#cb39-667" aria-hidden="true" tabindex="-1"></a>    pad_w <span class="op">=</span> patch_size <span class="op">-</span> (W <span class="op">%</span> patch_size) <span class="cf">if</span> W <span class="op">%</span> patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-668"><a href="#cb39-668" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-669"><a href="#cb39-669" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply reflection padding</span></span>
<span id="cb39-670"><a href="#cb39-670" aria-hidden="true" tabindex="-1"></a>    padded_img <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), mode<span class="op">=</span><span class="st">'reflect'</span>)</span>
<span id="cb39-671"><a href="#cb39-671" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-672"><a href="#cb39-672" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb39-673"><a href="#cb39-673" aria-hidden="true" tabindex="-1"></a>    patches, positions <span class="op">=</span> extract_patches_with_visualization(padded_img, patch_size)</span>
<span id="cb39-674"><a href="#cb39-674" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-675"><a href="#cb39-675" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize  </span></span>
<span id="cb39-676"><a href="#cb39-676" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-677"><a href="#cb39-677" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-678"><a href="#cb39-678" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original</span></span>
<span id="cb39-679"><a href="#cb39-679" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(image[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-680"><a href="#cb39-680" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="ss">f'Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb39-681"><a href="#cb39-681" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb39-682"><a href="#cb39-682" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb39-683"><a href="#cb39-683" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-684"><a href="#cb39-684" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Padded with reflection highlighting</span></span>
<span id="cb39-685"><a href="#cb39-685" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(padded_img[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-686"><a href="#cb39-686" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-687"><a href="#cb39-687" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Draw boundary between original and reflected content</span></span>
<span id="cb39-688"><a href="#cb39-688" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb39-689"><a href="#cb39-689" aria-hidden="true" tabindex="-1"></a>        ax2.axvline(W<span class="op">-</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'cyan'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb39-690"><a href="#cb39-690" aria-hidden="true" tabindex="-1"></a>        ax2.text(W <span class="op">+</span> pad_w<span class="op">/</span><span class="dv">2</span>, H<span class="op">/</span><span class="dv">2</span>, <span class="st">'Reflected</span><span class="ch">\n</span><span class="st">Content'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb39-691"><a href="#cb39-691" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'cyan'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb39-692"><a href="#cb39-692" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb39-693"><a href="#cb39-693" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-694"><a href="#cb39-694" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb39-695"><a href="#cb39-695" aria-hidden="true" tabindex="-1"></a>        ax2.axhline(H<span class="op">-</span><span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'cyan'</span>, linewidth<span class="op">=</span><span class="dv">3</span>, alpha<span class="op">=</span><span class="fl">0.8</span>) </span>
<span id="cb39-696"><a href="#cb39-696" aria-hidden="true" tabindex="-1"></a>        ax2.text((W <span class="op">+</span> pad_w)<span class="op">/</span><span class="dv">2</span>, H <span class="op">+</span> pad_h<span class="op">/</span><span class="dv">2</span>, <span class="st">'Reflected Content'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>,</span>
<span id="cb39-697"><a href="#cb39-697" aria-hidden="true" tabindex="-1"></a>                fontsize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span><span class="st">'cyan'</span>, weight<span class="op">=</span><span class="st">'bold'</span>,</span>
<span id="cb39-698"><a href="#cb39-698" aria-hidden="true" tabindex="-1"></a>                bbox<span class="op">=</span><span class="bu">dict</span>(boxstyle<span class="op">=</span><span class="st">"round,pad=0.3"</span>, facecolor<span class="op">=</span><span class="st">'white'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>))</span>
<span id="cb39-699"><a href="#cb39-699" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-700"><a href="#cb39-700" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show patch boundaries</span></span>
<span id="cb39-701"><a href="#cb39-701" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x, y <span class="kw">in</span> positions[:<span class="dv">15</span>]:</span>
<span id="cb39-702"><a href="#cb39-702" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-703"><a href="#cb39-703" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'yellow'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb39-704"><a href="#cb39-704" aria-hidden="true" tabindex="-1"></a>        ax2.add_patch(rect)</span>
<span id="cb39-705"><a href="#cb39-705" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-706"><a href="#cb39-706" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlim(<span class="dv">0</span>, padded_img.shape[<span class="dv">1</span>])</span>
<span id="cb39-707"><a href="#cb39-707" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylim(padded_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-708"><a href="#cb39-708" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Reflect Padded: </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-709"><a href="#cb39-709" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb39-710"><a href="#cb39-710" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb39-711"><a href="#cb39-711" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-712"><a href="#cb39-712" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Strategy 3: Reflect Padding (Preserves Structure)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-713"><a href="#cb39-713" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-714"><a href="#cb39-714" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-715"><a href="#cb39-715" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-716"><a href="#cb39-716" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Reflect Padding Results:"</span>)</span>
<span id="cb39-717"><a href="#cb39-717" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-718"><a href="#cb39-718" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padding:  +</span><span class="sc">{</span>pad_h<span class="sc">}</span><span class="ss"> rows, +</span><span class="sc">{</span>pad_w<span class="sc">}</span><span class="ss"> columns"</span>)</span>
<span id="cb39-719"><a href="#cb39-719" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Padded:   </span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>padded_img<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-720"><a href="#cb39-720" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Patches:  </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-721"><a href="#cb39-721" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Note: Reflected content preserves local image structure"</span>)</span>
<span id="cb39-722"><a href="#cb39-722" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-723"><a href="#cb39-723" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> padded_img, patches</span>
<span id="cb39-724"><a href="#cb39-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-725"><a href="#cb39-725" aria-hidden="true" tabindex="-1"></a>reflect_img, reflect_patches <span class="op">=</span> demonstrate_reflect_padding(irregular_img, patch_size)</span>
<span id="cb39-726"><a href="#cb39-726" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-727"><a href="#cb39-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-728"><a href="#cb39-728" aria-hidden="true" tabindex="-1"></a><span class="fu">### Comparing Padding Strategies</span></span>
<span id="cb39-729"><a href="#cb39-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-730"><a href="#cb39-730" aria-hidden="true" tabindex="-1"></a>Let's quantitatively compare how these strategies affect the actual patch content:</span>
<span id="cb39-731"><a href="#cb39-731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-734"><a href="#cb39-734" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-735"><a href="#cb39-735" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_padding_strategies():</span>
<span id="cb39-736"><a href="#cb39-736" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-737"><a href="#cb39-737" aria-hidden="true" tabindex="-1"></a><span class="co">    Compare the three padding strategies quantitatively.</span></span>
<span id="cb39-738"><a href="#cb39-738" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-739"><a href="#cb39-739" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Padding Strategy Comparison"</span>)</span>
<span id="cb39-740"><a href="#cb39-740" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb39-741"><a href="#cb39-741" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Strategy'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patches'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory (MB)'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Edge Coverage'</span><span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Artifacts'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-742"><a href="#cb39-742" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb39-743"><a href="#cb39-743" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-744"><a href="#cb39-744" aria-hidden="true" tabindex="-1"></a>    strategies <span class="op">=</span> [</span>
<span id="cb39-745"><a href="#cb39-745" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Crop'</span>, crop_patches, <span class="st">'Incomplete'</span>, <span class="st">'None'</span>),</span>
<span id="cb39-746"><a href="#cb39-746" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Zero Pad'</span>, pad_patches, <span class="st">'Complete'</span>, <span class="st">'Boundary jumps'</span>),</span>
<span id="cb39-747"><a href="#cb39-747" aria-hidden="true" tabindex="-1"></a>        (<span class="st">'Reflect Pad'</span>, reflect_patches, <span class="st">'Complete'</span>, <span class="st">'Minimal'</span>)</span>
<span id="cb39-748"><a href="#cb39-748" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb39-749"><a href="#cb39-749" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-750"><a href="#cb39-750" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, patches, coverage, artifacts <span class="kw">in</span> strategies:</span>
<span id="cb39-751"><a href="#cb39-751" aria-hidden="true" tabindex="-1"></a>        memory_mb <span class="op">=</span> patches.nbytes <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb39-752"><a href="#cb39-752" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>name<span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>memory_mb<span class="sc">:&lt;12.1f}</span><span class="ss"> </span><span class="sc">{</span>coverage<span class="sc">:&lt;15}</span><span class="ss"> </span><span class="sc">{</span>artifacts<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-753"><a href="#cb39-753" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-754"><a href="#cb39-754" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visual comparison of edge patches</span></span>
<span id="cb39-755"><a href="#cb39-755" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb39-756"><a href="#cb39-756" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-757"><a href="#cb39-757" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Top row: show full padded images</span></span>
<span id="cb39-758"><a href="#cb39-758" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> [cropped_img, padded_img, reflect_img]</span>
<span id="cb39-759"><a href="#cb39-759" aria-hidden="true" tabindex="-1"></a>    titles <span class="op">=</span> [<span class="st">'Cropped'</span>, <span class="st">'Zero Padded'</span>, <span class="st">'Reflect Padded'</span>]</span>
<span id="cb39-760"><a href="#cb39-760" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-761"><a href="#cb39-761" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (img, title) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(images, titles)):</span>
<span id="cb39-762"><a href="#cb39-762" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].imshow(img[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-763"><a href="#cb39-763" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_title(title)</span>
<span id="cb39-764"><a href="#cb39-764" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_xticks([])</span>
<span id="cb39-765"><a href="#cb39-765" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_yticks([])</span>
<span id="cb39-766"><a href="#cb39-766" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-767"><a href="#cb39-767" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bottom row: show edge patches that contain padding</span></span>
<span id="cb39-768"><a href="#cb39-768" aria-hidden="true" tabindex="-1"></a>    patch_sets <span class="op">=</span> [crop_patches, pad_patches, reflect_patches]</span>
<span id="cb39-769"><a href="#cb39-769" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-770"><a href="#cb39-770" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (patches, title) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(patch_sets, titles)):</span>
<span id="cb39-771"><a href="#cb39-771" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># Crop strategy - show a regular patch</span></span>
<span id="cb39-772"><a href="#cb39-772" aria-hidden="true" tabindex="-1"></a>            edge_patch <span class="op">=</span> patches[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Last patch (still contains real data)</span></span>
<span id="cb39-773"><a href="#cb39-773" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].imshow(edge_patch[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-774"><a href="#cb39-774" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">: Regular patch'</span>)</span>
<span id="cb39-775"><a href="#cb39-775" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># Padding strategies - show patch with padding</span></span>
<span id="cb39-776"><a href="#cb39-776" aria-hidden="true" tabindex="-1"></a>            edge_patch <span class="op">=</span> patches[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># Last patch (contains padding)</span></span>
<span id="cb39-777"><a href="#cb39-777" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].imshow(edge_patch[:, :, :<span class="dv">3</span>])</span>
<span id="cb39-778"><a href="#cb39-778" aria-hidden="true" tabindex="-1"></a>            axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">: Edge patch'</span>)</span>
<span id="cb39-779"><a href="#cb39-779" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-780"><a href="#cb39-780" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_xticks([])</span>
<span id="cb39-781"><a href="#cb39-781" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_yticks([])</span>
<span id="cb39-782"><a href="#cb39-782" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-783"><a href="#cb39-783" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Padding Strategy Comparison: Full Images (top) and Edge Patches (bottom)'</span>, </span>
<span id="cb39-784"><a href="#cb39-784" aria-hidden="true" tabindex="-1"></a>                 fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-785"><a href="#cb39-785" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-786"><a href="#cb39-786" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-787"><a href="#cb39-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-788"><a href="#cb39-788" aria-hidden="true" tabindex="-1"></a>compare_padding_strategies()</span>
<span id="cb39-789"><a href="#cb39-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-790"><a href="#cb39-790" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🎯 Strategy Selection Guidelines:"</span>)</span>
<span id="cb39-791"><a href="#cb39-791" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • CROP: Use for large-scale analysis where speed &gt; completeness"</span>)</span>
<span id="cb39-792"><a href="#cb39-792" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • ZERO PAD: Use when complete coverage is mandatory"</span>)  </span>
<span id="cb39-793"><a href="#cb39-793" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • REFLECT PAD: Use for high-quality analysis of natural imagery"</span>)</span>
<span id="cb39-794"><a href="#cb39-794" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Consider your downstream task requirements"</span>)</span>
<span id="cb39-795"><a href="#cb39-795" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Test different strategies on your specific data"</span>)</span>
<span id="cb39-796"><a href="#cb39-796" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-797"><a href="#cb39-797" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-798"><a href="#cb39-798" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-799"><a href="#cb39-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-800"><a href="#cb39-800" aria-hidden="true" tabindex="-1"></a><span class="fu">## Advanced Topics: Multi-Scale and Multi-Temporal Processing</span></span>
<span id="cb39-801"><a href="#cb39-801" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-802"><a href="#cb39-802" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multi-Scale Patch Extraction</span></span>
<span id="cb39-803"><a href="#cb39-803" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-804"><a href="#cb39-804" aria-hidden="true" tabindex="-1"></a>Real-world satellite analysis often requires processing the same area at multiple scales. For example, identifying broad land cover patterns (large patches) while also detecting detailed features (small patches):</span>
<span id="cb39-805"><a href="#cb39-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-808"><a href="#cb39-808" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-809"><a href="#cb39-809" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> multi_scale_patch_extraction(image, patch_sizes<span class="op">=</span>[<span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>]):</span>
<span id="cb39-810"><a href="#cb39-810" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-811"><a href="#cb39-811" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate multi-scale patch extraction for hierarchical analysis.</span></span>
<span id="cb39-812"><a href="#cb39-812" aria-hidden="true" tabindex="-1"></a><span class="co">    This approach is used in some advanced GFMs.</span></span>
<span id="cb39-813"><a href="#cb39-813" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-814"><a href="#cb39-814" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-815"><a href="#cb39-815" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Multi-Scale Analysis:"</span>)</span>
<span id="cb39-816"><a href="#cb39-816" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-817"><a href="#cb39-817" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-818"><a href="#cb39-818" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="bu">len</span>(patch_sizes), figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb39-819"><a href="#cb39-819" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-820"><a href="#cb39-820" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, patch_size <span class="kw">in</span> <span class="bu">enumerate</span>(patch_sizes):</span>
<span id="cb39-821"><a href="#cb39-821" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(image, patch_size)</span>
<span id="cb39-822"><a href="#cb39-822" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-823"><a href="#cb39-823" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate scale-dependent information</span></span>
<span id="cb39-824"><a href="#cb39-824" aria-hidden="true" tabindex="-1"></a>        patches_per_area <span class="op">=</span> <span class="bu">len</span>(patches) <span class="op">/</span> (image.shape[<span class="dv">0</span>] <span class="op">*</span> image.shape[<span class="dv">1</span>])</span>
<span id="cb39-825"><a href="#cb39-825" aria-hidden="true" tabindex="-1"></a>        detail_level <span class="op">=</span> <span class="dv">1000</span> <span class="op">*</span> patches_per_area  <span class="co"># Patches per 1000 pixels</span></span>
<span id="cb39-826"><a href="#cb39-826" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-827"><a href="#cb39-827" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Scale </span><span class="sc">{</span>idx<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches"</span>)</span>
<span id="cb39-828"><a href="#cb39-828" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Total patches: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-829"><a href="#cb39-829" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Detail level: </span><span class="sc">{</span>detail_level<span class="sc">:.2f}</span><span class="ss"> patches/1000px²"</span>)</span>
<span id="cb39-830"><a href="#cb39-830" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Use case: </span><span class="sc">{</span><span class="st">'Fine details'</span> <span class="cf">if</span> patch_size <span class="op">&lt;=</span> <span class="dv">32</span> <span class="cf">else</span> <span class="st">'Broad patterns'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-831"><a href="#cb39-831" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-832"><a href="#cb39-832" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Visualize</span></span>
<span id="cb39-833"><a href="#cb39-833" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb39-834"><a href="#cb39-834" aria-hidden="true" tabindex="-1"></a>        ax.imshow(image[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb39-835"><a href="#cb39-835" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-836"><a href="#cb39-836" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show subset of patches to avoid clutter</span></span>
<span id="cb39-837"><a href="#cb39-837" aria-hidden="true" tabindex="-1"></a>        show_patches <span class="op">=</span> positions[::<span class="bu">max</span>(<span class="dv">1</span>, <span class="bu">len</span>(positions)<span class="op">//</span><span class="dv">12</span>)]  <span class="co"># Show ~12 patches</span></span>
<span id="cb39-838"><a href="#cb39-838" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x, y <span class="kw">in</span> show_patches:</span>
<span id="cb39-839"><a href="#cb39-839" aria-hidden="true" tabindex="-1"></a>            rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-840"><a href="#cb39-840" aria-hidden="true" tabindex="-1"></a>                               linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>, alpha<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb39-841"><a href="#cb39-841" aria-hidden="true" tabindex="-1"></a>            ax.add_patch(rect)</span>
<span id="cb39-842"><a href="#cb39-842" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-843"><a href="#cb39-843" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, image.shape[<span class="dv">1</span>])</span>
<span id="cb39-844"><a href="#cb39-844" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(image.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-845"><a href="#cb39-845" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb39-846"><a href="#cb39-846" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb39-847"><a href="#cb39-847" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-848"><a href="#cb39-848" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-849"><a href="#cb39-849" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Multi-Scale Patch Extraction'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-850"><a href="#cb39-850" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-851"><a href="#cb39-851" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-852"><a href="#cb39-852" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-853"><a href="#cb39-853" aria-hidden="true" tabindex="-1"></a>multi_scale_patch_extraction(satellite_img)</span>
<span id="cb39-854"><a href="#cb39-854" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-855"><a href="#cb39-855" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">💡 Multi-Scale Benefits:"</span>)</span>
<span id="cb39-856"><a href="#cb39-856" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Small patches: Capture fine details, textures, edges"</span>)</span>
<span id="cb39-857"><a href="#cb39-857" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Large patches: Capture spatial context, broad patterns"</span>)</span>
<span id="cb39-858"><a href="#cb39-858" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Combined: Enable hierarchical understanding"</span>)</span>
<span id="cb39-859"><a href="#cb39-859" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Used in: Change detection, multi-resolution analysis"</span>)</span>
<span id="cb39-860"><a href="#cb39-860" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-861"><a href="#cb39-861" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-862"><a href="#cb39-862" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multi-Temporal Patch Processing</span></span>
<span id="cb39-863"><a href="#cb39-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-864"><a href="#cb39-864" aria-hidden="true" tabindex="-1"></a>Many GFMs process time series of satellite imagery. Here's how patch extraction works across time:</span>
<span id="cb39-865"><a href="#cb39-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-868"><a href="#cb39-868" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-869"><a href="#cb39-869" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_temporal_patches():</span>
<span id="cb39-870"><a href="#cb39-870" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-871"><a href="#cb39-871" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how patches are extracted from multi-temporal imagery.</span></span>
<span id="cb39-872"><a href="#cb39-872" aria-hidden="true" tabindex="-1"></a><span class="co">    Critical for change detection and phenology monitoring.</span></span>
<span id="cb39-873"><a href="#cb39-873" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-874"><a href="#cb39-874" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-875"><a href="#cb39-875" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate time series (3 dates)</span></span>
<span id="cb39-876"><a href="#cb39-876" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb39-877"><a href="#cb39-877" aria-hidden="true" tabindex="-1"></a>    dates <span class="op">=</span> [<span class="st">'2021-06-01'</span>, <span class="st">'2022-06-01'</span>, <span class="st">'2023-06-01'</span>]</span>
<span id="cb39-878"><a href="#cb39-878" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-879"><a href="#cb39-879" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create temporal changes (simulate seasonal/land use changes)</span></span>
<span id="cb39-880"><a href="#cb39-880" aria-hidden="true" tabindex="-1"></a>    temporal_images <span class="op">=</span> []</span>
<span id="cb39-881"><a href="#cb39-881" aria-hidden="true" tabindex="-1"></a>    base_img <span class="op">=</span> satellite_img.copy()</span>
<span id="cb39-882"><a href="#cb39-882" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-883"><a href="#cb39-883" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, date <span class="kw">in</span> <span class="bu">enumerate</span>(dates):</span>
<span id="cb39-884"><a href="#cb39-884" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate temporal changes</span></span>
<span id="cb39-885"><a href="#cb39-885" aria-hidden="true" tabindex="-1"></a>        temp_img <span class="op">=</span> base_img.copy()</span>
<span id="cb39-886"><a href="#cb39-886" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-887"><a href="#cb39-887" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate seasonal vegetation changes (NIR band changes)</span></span>
<span id="cb39-888"><a href="#cb39-888" aria-hidden="true" tabindex="-1"></a>        vegetation_change <span class="op">=</span> np.sin(i <span class="op">*</span> np.pi <span class="op">/</span> <span class="dv">2</span>) <span class="op">*</span> <span class="fl">0.3</span>  <span class="co"># Seasonal variation</span></span>
<span id="cb39-889"><a href="#cb39-889" aria-hidden="true" tabindex="-1"></a>        temp_img[:, :, <span class="dv">3</span>] <span class="op">=</span> np.clip(temp_img[:, :, <span class="dv">3</span>] <span class="op">+</span> vegetation_change, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb39-890"><a href="#cb39-890" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-891"><a href="#cb39-891" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Simulate some land cover change in a region</span></span>
<span id="cb39-892"><a href="#cb39-892" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:  <span class="co"># Changes start from second date</span></span>
<span id="cb39-893"><a href="#cb39-893" aria-hidden="true" tabindex="-1"></a>            change_region <span class="op">=</span> <span class="bu">slice</span>(<span class="dv">40</span>, <span class="dv">80</span>), <span class="bu">slice</span>(<span class="dv">60</span>, <span class="dv">100</span>)</span>
<span id="cb39-894"><a href="#cb39-894" aria-hidden="true" tabindex="-1"></a>            temp_img[change_region] <span class="op">=</span> [<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>, <span class="fl">0.1</span>]  <span class="co"># Urban development</span></span>
<span id="cb39-895"><a href="#cb39-895" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-896"><a href="#cb39-896" aria-hidden="true" tabindex="-1"></a>        temporal_images.append(temp_img)</span>
<span id="cb39-897"><a href="#cb39-897" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-898"><a href="#cb39-898" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches from each time point</span></span>
<span id="cb39-899"><a href="#cb39-899" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb39-900"><a href="#cb39-900" aria-hidden="true" tabindex="-1"></a>    temporal_patch_sets <span class="op">=</span> []</span>
<span id="cb39-901"><a href="#cb39-901" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-902"><a href="#cb39-902" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb39-903"><a href="#cb39-903" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-904"><a href="#cb39-904" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (img, date) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(temporal_images, dates)):</span>
<span id="cb39-905"><a href="#cb39-905" aria-hidden="true" tabindex="-1"></a>        patches, positions <span class="op">=</span> extract_patches_with_visualization(img, patch_size)</span>
<span id="cb39-906"><a href="#cb39-906" aria-hidden="true" tabindex="-1"></a>        temporal_patch_sets.append(patches)</span>
<span id="cb39-907"><a href="#cb39-907" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-908"><a href="#cb39-908" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show full image</span></span>
<span id="cb39-909"><a href="#cb39-909" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].imshow(img[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])  <span class="co"># False color</span></span>
<span id="cb39-910"><a href="#cb39-910" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_title(<span class="ss">f'</span><span class="sc">{</span>date<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-911"><a href="#cb39-911" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_xticks([])</span>
<span id="cb39-912"><a href="#cb39-912" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].set_yticks([])</span>
<span id="cb39-913"><a href="#cb39-913" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-914"><a href="#cb39-914" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Highlight a specific patch across time</span></span>
<span id="cb39-915"><a href="#cb39-915" aria-hidden="true" tabindex="-1"></a>        highlight_patch_idx <span class="op">=</span> <span class="dv">6</span>  <span class="co"># Same spatial location across all dates</span></span>
<span id="cb39-916"><a href="#cb39-916" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> positions[highlight_patch_idx]</span>
<span id="cb39-917"><a href="#cb39-917" aria-hidden="true" tabindex="-1"></a>        rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-918"><a href="#cb39-918" aria-hidden="true" tabindex="-1"></a>                           linewidth<span class="op">=</span><span class="dv">3</span>, edgecolor<span class="op">=</span><span class="st">'yellow'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb39-919"><a href="#cb39-919" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">0</span>, i].add_patch(rect)</span>
<span id="cb39-920"><a href="#cb39-920" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-921"><a href="#cb39-921" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show the highlighted patch</span></span>
<span id="cb39-922"><a href="#cb39-922" aria-hidden="true" tabindex="-1"></a>        highlighted_patch <span class="op">=</span> patches[highlight_patch_idx]</span>
<span id="cb39-923"><a href="#cb39-923" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].imshow(highlighted_patch[:, :, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb39-924"><a href="#cb39-924" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_title(<span class="ss">f'Patch </span><span class="sc">{</span>highlight_patch_idx<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>date<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb39-925"><a href="#cb39-925" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_xticks([])</span>
<span id="cb39-926"><a href="#cb39-926" aria-hidden="true" tabindex="-1"></a>        axes[<span class="dv">1</span>, i].set_yticks([])</span>
<span id="cb39-927"><a href="#cb39-927" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-928"><a href="#cb39-928" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Multi-Temporal Patch Extraction (Same Spatial Location Over Time)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-929"><a href="#cb39-929" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-930"><a href="#cb39-930" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-931"><a href="#cb39-931" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-932"><a href="#cb39-932" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Analyze temporal patch consistency</span></span>
<span id="cb39-933"><a href="#cb39-933" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Temporal Patch Analysis:"</span>)</span>
<span id="cb39-934"><a href="#cb39-934" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">30</span>)</span>
<span id="cb39-935"><a href="#cb39-935" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-936"><a href="#cb39-936" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Time points: </span><span class="sc">{</span><span class="bu">len</span>(dates)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-937"><a href="#cb39-937" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patches per date: </span><span class="sc">{</span><span class="bu">len</span>(temporal_patch_sets[<span class="dv">0</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-938"><a href="#cb39-938" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-939"><a href="#cb39-939" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate change magnitude for the highlighted patch</span></span>
<span id="cb39-940"><a href="#cb39-940" aria-hidden="true" tabindex="-1"></a>    patch_0 <span class="op">=</span> temporal_patch_sets[<span class="dv">0</span>][highlight_patch_idx]</span>
<span id="cb39-941"><a href="#cb39-941" aria-hidden="true" tabindex="-1"></a>    patch_1 <span class="op">=</span> temporal_patch_sets[<span class="dv">1</span>][highlight_patch_idx] </span>
<span id="cb39-942"><a href="#cb39-942" aria-hidden="true" tabindex="-1"></a>    patch_2 <span class="op">=</span> temporal_patch_sets[<span class="dv">2</span>][highlight_patch_idx]</span>
<span id="cb39-943"><a href="#cb39-943" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-944"><a href="#cb39-944" aria-hidden="true" tabindex="-1"></a>    change_1 <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(patch_1 <span class="op">-</span> patch_0))</span>
<span id="cb39-945"><a href="#cb39-945" aria-hidden="true" tabindex="-1"></a>    change_2 <span class="op">=</span> np.mean(np.<span class="bu">abs</span>(patch_2 <span class="op">-</span> patch_1))</span>
<span id="cb39-946"><a href="#cb39-946" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-947"><a href="#cb39-947" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Change Analysis (Patch </span><span class="sc">{</span>highlight_patch_idx<span class="sc">}</span><span class="ss">):"</span>)</span>
<span id="cb39-948"><a href="#cb39-948" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>dates[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>dates[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>change_1<span class="sc">:.3f}</span><span class="ss"> mean absolute change"</span>)</span>
<span id="cb39-949"><a href="#cb39-949" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>dates[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> → </span><span class="sc">{</span>dates[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>change_2<span class="sc">:.3f}</span><span class="ss"> mean absolute change"</span>)</span>
<span id="cb39-950"><a href="#cb39-950" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-951"><a href="#cb39-951" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> temporal_patch_sets</span>
<span id="cb39-952"><a href="#cb39-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-953"><a href="#cb39-953" aria-hidden="true" tabindex="-1"></a>temporal_patches <span class="op">=</span> demonstrate_temporal_patches()</span>
<span id="cb39-954"><a href="#cb39-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-955"><a href="#cb39-955" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🕐 Temporal Processing Insights:"</span>)</span>
<span id="cb39-956"><a href="#cb39-956" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Same spatial patches tracked over time"</span>)</span>
<span id="cb39-957"><a href="#cb39-957" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Enables change detection and trend analysis"</span>) </span>
<span id="cb39-958"><a href="#cb39-958" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Requires careful image registration (alignment)"</span>)</span>
<span id="cb39-959"><a href="#cb39-959" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Used in: Crop monitoring, deforestation detection, urban growth"</span>)</span>
<span id="cb39-960"><a href="#cb39-960" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-961"><a href="#cb39-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-962"><a href="#cb39-962" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-963"><a href="#cb39-963" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-964"><a href="#cb39-964" aria-hidden="true" tabindex="-1"></a><span class="fu">## Connection to Foundation Model Architectures</span></span>
<span id="cb39-965"><a href="#cb39-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-966"><a href="#cb39-966" aria-hidden="true" tabindex="-1"></a><span class="fu">### How Different GFMs Handle Patches</span></span>
<span id="cb39-967"><a href="#cb39-967" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-968"><a href="#cb39-968" aria-hidden="true" tabindex="-1"></a>Different geospatial foundation models make different choices about patch processing. Let's examine some real examples:</span>
<span id="cb39-969"><a href="#cb39-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-972"><a href="#cb39-972" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-973"><a href="#cb39-973" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compare_gfm_architectures():</span>
<span id="cb39-974"><a href="#cb39-974" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-975"><a href="#cb39-975" aria-hidden="true" tabindex="-1"></a><span class="co">    Compare patch handling across different geospatial foundation models.</span></span>
<span id="cb39-976"><a href="#cb39-976" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-977"><a href="#cb39-977" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-978"><a href="#cb39-978" aria-hidden="true" tabindex="-1"></a>    gfm_configs <span class="op">=</span> {</span>
<span id="cb39-979"><a href="#cb39-979" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Prithvi (IBM)'</span>: {</span>
<span id="cb39-980"><a href="#cb39-980" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">16</span>,</span>
<span id="cb39-981"><a href="#cb39-981" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">6</span>,  <span class="co"># HLS bands</span></span>
<span id="cb39-982"><a href="#cb39-982" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">768</span>,</span>
<span id="cb39-983"><a href="#cb39-983" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Multi-spectral analysis'</span>,</span>
<span id="cb39-984"><a href="#cb39-984" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Pre-trained on HLS (Landsat + Sentinel-2)'</span></span>
<span id="cb39-985"><a href="#cb39-985" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb39-986"><a href="#cb39-986" aria-hidden="true" tabindex="-1"></a>        <span class="st">'SatMAE (Microsoft)'</span>: {</span>
<span id="cb39-987"><a href="#cb39-987" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">16</span>, </span>
<span id="cb39-988"><a href="#cb39-988" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">4</span>,  <span class="co"># RGB + NIR</span></span>
<span id="cb39-989"><a href="#cb39-989" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">1024</span>,</span>
<span id="cb39-990"><a href="#cb39-990" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Self-supervised pretraining'</span>,</span>
<span id="cb39-991"><a href="#cb39-991" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Masked autoencoder approach'</span></span>
<span id="cb39-992"><a href="#cb39-992" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb39-993"><a href="#cb39-993" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Scale-MAE'</span>: {</span>
<span id="cb39-994"><a href="#cb39-994" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">8</span>,</span>
<span id="cb39-995"><a href="#cb39-995" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">10</span>,  <span class="co"># Sentinel-2 bands</span></span>
<span id="cb39-996"><a href="#cb39-996" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">512</span>, </span>
<span id="cb39-997"><a href="#cb39-997" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Multi-scale analysis'</span>,</span>
<span id="cb39-998"><a href="#cb39-998" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Handles multiple resolutions'</span></span>
<span id="cb39-999"><a href="#cb39-999" aria-hidden="true" tabindex="-1"></a>        },</span>
<span id="cb39-1000"><a href="#cb39-1000" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Our Custom GFM'</span>: {</span>
<span id="cb39-1001"><a href="#cb39-1001" aria-hidden="true" tabindex="-1"></a>            <span class="st">'patch_size'</span>: <span class="dv">32</span>,</span>
<span id="cb39-1002"><a href="#cb39-1002" aria-hidden="true" tabindex="-1"></a>            <span class="st">'bands'</span>: <span class="dv">4</span>,</span>
<span id="cb39-1003"><a href="#cb39-1003" aria-hidden="true" tabindex="-1"></a>            <span class="st">'embed_dim'</span>: <span class="dv">256</span>,</span>
<span id="cb39-1004"><a href="#cb39-1004" aria-hidden="true" tabindex="-1"></a>            <span class="st">'use_case'</span>: <span class="st">'Tutorial example'</span>,</span>
<span id="cb39-1005"><a href="#cb39-1005" aria-hidden="true" tabindex="-1"></a>            <span class="st">'notes'</span>: <span class="st">'Designed for this course'</span></span>
<span id="cb39-1006"><a href="#cb39-1006" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb39-1007"><a href="#cb39-1007" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb39-1008"><a href="#cb39-1008" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1009"><a href="#cb39-1009" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Geospatial Foundation Model Architectures"</span>)</span>
<span id="cb39-1010"><a href="#cb39-1010" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb39-1011"><a href="#cb39-1011" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Model'</span><span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Patch'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Bands'</span><span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Embed'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Use Case'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1012"><a href="#cb39-1012" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb39-1013"><a href="#cb39-1013" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1014"><a href="#cb39-1014" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> model, config <span class="kw">in</span> gfm_configs.items():</span>
<span id="cb39-1015"><a href="#cb39-1015" aria-hidden="true" tabindex="-1"></a>        patch_str <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span>config[<span class="st">'patch_size'</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>config[<span class="st">'patch_size'</span>]<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb39-1016"><a href="#cb39-1016" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>model<span class="sc">:&lt;20}</span><span class="ss"> </span><span class="sc">{</span>patch_str<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'bands'</span>]<span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'embed_dim'</span>]<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>config[<span class="st">'use_case'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1017"><a href="#cb39-1017" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1018"><a href="#cb39-1018" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate tokens per image for each model</span></span>
<span id="cb39-1019"><a href="#cb39-1019" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Tokens per Landsat Scene (7791×7611 pixels):"</span>)</span>
<span id="cb39-1020"><a href="#cb39-1020" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb39-1021"><a href="#cb39-1021" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1022"><a href="#cb39-1022" aria-hidden="true" tabindex="-1"></a>    landsat_h, landsat_w <span class="op">=</span> <span class="dv">7791</span>, <span class="dv">7611</span></span>
<span id="cb39-1023"><a href="#cb39-1023" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1024"><a href="#cb39-1024" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> model, config <span class="kw">in</span> gfm_configs.items():</span>
<span id="cb39-1025"><a href="#cb39-1025" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> config[<span class="st">'patch_size'</span>]</span>
<span id="cb39-1026"><a href="#cb39-1026" aria-hidden="true" tabindex="-1"></a>        patches_y <span class="op">=</span> landsat_h <span class="op">//</span> patch_size</span>
<span id="cb39-1027"><a href="#cb39-1027" aria-hidden="true" tabindex="-1"></a>        patches_x <span class="op">=</span> landsat_w <span class="op">//</span> patch_size</span>
<span id="cb39-1028"><a href="#cb39-1028" aria-hidden="true" tabindex="-1"></a>        total_tokens <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb39-1029"><a href="#cb39-1029" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1030"><a href="#cb39-1030" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>model<span class="sc">:&lt;20}</span><span class="ss">: </span><span class="sc">{</span>total_tokens<span class="sc">:&gt;8,}</span><span class="ss"> tokens"</span>)</span>
<span id="cb39-1031"><a href="#cb39-1031" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1032"><a href="#cb39-1032" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize patch sizes</span></span>
<span id="cb39-1033"><a href="#cb39-1033" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">4</span>, figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">4</span>))</span>
<span id="cb39-1034"><a href="#cb39-1034" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1035"><a href="#cb39-1035" aria-hidden="true" tabindex="-1"></a>    models <span class="op">=</span> <span class="bu">list</span>(gfm_configs.keys())</span>
<span id="cb39-1036"><a href="#cb39-1036" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, model <span class="kw">in</span> <span class="bu">enumerate</span>(models):</span>
<span id="cb39-1037"><a href="#cb39-1037" aria-hidden="true" tabindex="-1"></a>        config <span class="op">=</span> gfm_configs[model]</span>
<span id="cb39-1038"><a href="#cb39-1038" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> config[<span class="st">'patch_size'</span>]</span>
<span id="cb39-1039"><a href="#cb39-1039" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1040"><a href="#cb39-1040" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a sample image region</span></span>
<span id="cb39-1041"><a href="#cb39-1041" aria-hidden="true" tabindex="-1"></a>        sample_size <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb39-1042"><a href="#cb39-1042" aria-hidden="true" tabindex="-1"></a>        sample_img <span class="op">=</span> satellite_img[:sample_size, :sample_size, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]]</span>
<span id="cb39-1043"><a href="#cb39-1043" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1044"><a href="#cb39-1044" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx]</span>
<span id="cb39-1045"><a href="#cb39-1045" aria-hidden="true" tabindex="-1"></a>        ax.imshow(sample_img)</span>
<span id="cb39-1046"><a href="#cb39-1046" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1047"><a href="#cb39-1047" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Draw patch grid</span></span>
<span id="cb39-1048"><a href="#cb39-1048" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, sample_size, patch_size):</span>
<span id="cb39-1049"><a href="#cb39-1049" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, sample_size, patch_size):</span>
<span id="cb39-1050"><a href="#cb39-1050" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> x <span class="op">+</span> patch_size <span class="op">&lt;=</span> sample_size <span class="kw">and</span> y <span class="op">+</span> patch_size <span class="op">&lt;=</span> sample_size:</span>
<span id="cb39-1051"><a href="#cb39-1051" aria-hidden="true" tabindex="-1"></a>                    rect <span class="op">=</span> plt.Rectangle((x<span class="op">-</span><span class="fl">0.5</span>, y<span class="op">-</span><span class="fl">0.5</span>), patch_size, patch_size,</span>
<span id="cb39-1052"><a href="#cb39-1052" aria-hidden="true" tabindex="-1"></a>                                       linewidth<span class="op">=</span><span class="dv">2</span>, edgecolor<span class="op">=</span><span class="st">'white'</span>, facecolor<span class="op">=</span><span class="st">'none'</span>)</span>
<span id="cb39-1053"><a href="#cb39-1053" aria-hidden="true" tabindex="-1"></a>                    ax.add_patch(rect)</span>
<span id="cb39-1054"><a href="#cb39-1054" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1055"><a href="#cb39-1055" aria-hidden="true" tabindex="-1"></a>        ax.set_xlim(<span class="dv">0</span>, sample_size)</span>
<span id="cb39-1056"><a href="#cb39-1056" aria-hidden="true" tabindex="-1"></a>        ax.set_ylim(sample_size, <span class="dv">0</span>)</span>
<span id="cb39-1057"><a href="#cb39-1057" aria-hidden="true" tabindex="-1"></a>        ax.set_xticks([])</span>
<span id="cb39-1058"><a href="#cb39-1058" aria-hidden="true" tabindex="-1"></a>        ax.set_yticks([])</span>
<span id="cb39-1059"><a href="#cb39-1059" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>model<span class="sc">}</span><span class="ch">\n</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss"> patches'</span>)</span>
<span id="cb39-1060"><a href="#cb39-1060" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1061"><a href="#cb39-1061" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Patch Sizes in Different GFMs'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-1062"><a href="#cb39-1062" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-1063"><a href="#cb39-1063" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-1064"><a href="#cb39-1064" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1065"><a href="#cb39-1065" aria-hidden="true" tabindex="-1"></a>compare_gfm_architectures()</span>
<span id="cb39-1066"><a href="#cb39-1066" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-1067"><a href="#cb39-1067" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1068"><a href="#cb39-1068" aria-hidden="true" tabindex="-1"></a><span class="fu">### Masked Autoencoder Training</span></span>
<span id="cb39-1069"><a href="#cb39-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1070"><a href="#cb39-1070" aria-hidden="true" tabindex="-1"></a>Many modern GFMs use masked autoencoder (MAE) training. Let's demonstrate how masking works with patches:</span>
<span id="cb39-1071"><a href="#cb39-1071" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1074"><a href="#cb39-1074" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-1075"><a href="#cb39-1075" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_mae_masking(patches, mask_ratio<span class="op">=</span><span class="fl">0.75</span>):</span>
<span id="cb39-1076"><a href="#cb39-1076" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-1077"><a href="#cb39-1077" aria-hidden="true" tabindex="-1"></a><span class="co">    Show how masked autoencoder training works with satellite image patches.</span></span>
<span id="cb39-1078"><a href="#cb39-1078" aria-hidden="true" tabindex="-1"></a><span class="co">    This is the core training strategy for many modern GFMs.</span></span>
<span id="cb39-1079"><a href="#cb39-1079" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-1080"><a href="#cb39-1080" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1081"><a href="#cb39-1081" aria-hidden="true" tabindex="-1"></a>    n_patches <span class="op">=</span> <span class="bu">len</span>(patches)</span>
<span id="cb39-1082"><a href="#cb39-1082" aria-hidden="true" tabindex="-1"></a>    n_masked <span class="op">=</span> <span class="bu">int</span>(n_patches <span class="op">*</span> mask_ratio)</span>
<span id="cb39-1083"><a href="#cb39-1083" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1084"><a href="#cb39-1084" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Masked Autoencoder (MAE) Training"</span>)</span>
<span id="cb39-1085"><a href="#cb39-1085" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-1086"><a href="#cb39-1086" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patches: </span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1087"><a href="#cb39-1087" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Mask ratio: </span><span class="sc">{</span>mask_ratio<span class="sc">}</span><span class="ss"> (</span><span class="sc">{</span>n_masked<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_patches<span class="sc">}</span><span class="ss"> patches masked)"</span>)</span>
<span id="cb39-1088"><a href="#cb39-1088" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Visible patches: </span><span class="sc">{</span>n_patches <span class="op">-</span> n_masked<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1089"><a href="#cb39-1089" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1090"><a href="#cb39-1090" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create random mask</span></span>
<span id="cb39-1091"><a href="#cb39-1091" aria-hidden="true" tabindex="-1"></a>    np.random.seed(<span class="dv">42</span>)</span>
<span id="cb39-1092"><a href="#cb39-1092" aria-hidden="true" tabindex="-1"></a>    mask_indices <span class="op">=</span> np.random.choice(n_patches, n_masked, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb39-1093"><a href="#cb39-1093" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1094"><a href="#cb39-1094" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct image grid for visualization</span></span>
<span id="cb39-1095"><a href="#cb39-1095" aria-hidden="true" tabindex="-1"></a>    grid_size <span class="op">=</span> <span class="bu">int</span>(np.ceil(np.sqrt(n_patches)))</span>
<span id="cb39-1096"><a href="#cb39-1096" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Infer patch size and handle channel ordering robustly when visualizing</span></span>
<span id="cb39-1097"><a href="#cb39-1097" aria-hidden="true" tabindex="-1"></a>    patch <span class="op">=</span> patches[<span class="dv">0</span>]</span>
<span id="cb39-1098"><a href="#cb39-1098" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> patch.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb39-1099"><a href="#cb39-1099" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patch.shape[<span class="dv">0</span>]</span>
<span id="cb39-1100"><a href="#cb39-1100" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> patch.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb39-1101"><a href="#cb39-1101" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patch.shape[<span class="dv">1</span>]</span>
<span id="cb39-1102"><a href="#cb39-1102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb39-1103"><a href="#cb39-1103" aria-hidden="true" tabindex="-1"></a>        patch_size <span class="op">=</span> patches.shape[<span class="dv">1</span>]</span>
<span id="cb39-1104"><a href="#cb39-1104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1105"><a href="#cb39-1105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create full image from patches</span></span>
<span id="cb39-1106"><a href="#cb39-1106" aria-hidden="true" tabindex="-1"></a>    full_img <span class="op">=</span> np.zeros((grid_size <span class="op">*</span> patch_size, grid_size <span class="op">*</span> patch_size, <span class="dv">3</span>))</span>
<span id="cb39-1107"><a href="#cb39-1107" aria-hidden="true" tabindex="-1"></a>    masked_img <span class="op">=</span> full_img.copy()</span>
<span id="cb39-1108"><a href="#cb39-1108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1109"><a href="#cb39-1109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches):</span>
<span id="cb39-1110"><a href="#cb39-1110" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> i <span class="op">//</span> grid_size</span>
<span id="cb39-1111"><a href="#cb39-1111" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> i <span class="op">%</span> grid_size</span>
<span id="cb39-1112"><a href="#cb39-1112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1113"><a href="#cb39-1113" aria-hidden="true" tabindex="-1"></a>        start_y <span class="op">=</span> row <span class="op">*</span> patch_size</span>
<span id="cb39-1114"><a href="#cb39-1114" aria-hidden="true" tabindex="-1"></a>        end_y <span class="op">=</span> start_y <span class="op">+</span> patch_size</span>
<span id="cb39-1115"><a href="#cb39-1115" aria-hidden="true" tabindex="-1"></a>        start_x <span class="op">=</span> col <span class="op">*</span> patch_size</span>
<span id="cb39-1116"><a href="#cb39-1116" aria-hidden="true" tabindex="-1"></a>        end_x <span class="op">=</span> start_x <span class="op">+</span> patch_size</span>
<span id="cb39-1117"><a href="#cb39-1117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1118"><a href="#cb39-1118" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract an RGB visualization with channels-last ordering</span></span>
<span id="cb39-1119"><a href="#cb39-1119" aria-hidden="true" tabindex="-1"></a>        patch_i <span class="op">=</span> patches[i]</span>
<span id="cb39-1120"><a href="#cb39-1120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb39-1121"><a href="#cb39-1121" aria-hidden="true" tabindex="-1"></a>            patch_rgb <span class="op">=</span> patch_i[..., :<span class="dv">3</span>]</span>
<span id="cb39-1122"><a href="#cb39-1122" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="dv">0</span>] <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb39-1123"><a href="#cb39-1123" aria-hidden="true" tabindex="-1"></a>            patch_rgb <span class="op">=</span> np.transpose(patch_i[:<span class="dv">3</span>, ...], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb39-1124"><a href="#cb39-1124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb39-1125"><a href="#cb39-1125" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fallback for single-channel patches: replicate to 3 channels</span></span>
<span id="cb39-1126"><a href="#cb39-1126" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb39-1127"><a href="#cb39-1127" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.repeat(patch_i, <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb39-1128"><a href="#cb39-1128" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> patch_i.ndim <span class="op">==</span> <span class="dv">3</span> <span class="kw">and</span> patch_i.shape[<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb39-1129"><a href="#cb39-1129" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.repeat(np.transpose(patch_i, (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>)), <span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb39-1130"><a href="#cb39-1130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb39-1131"><a href="#cb39-1131" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Last resort: ensure shape (H, W, 3)</span></span>
<span id="cb39-1132"><a href="#cb39-1132" aria-hidden="true" tabindex="-1"></a>                h <span class="op">=</span> patch_i.shape[<span class="dv">0</span>]</span>
<span id="cb39-1133"><a href="#cb39-1133" aria-hidden="true" tabindex="-1"></a>                w <span class="op">=</span> patch_i.shape[<span class="dv">1</span>]</span>
<span id="cb39-1134"><a href="#cb39-1134" aria-hidden="true" tabindex="-1"></a>                patch_rgb <span class="op">=</span> np.zeros((h, w, <span class="dv">3</span>))</span>
<span id="cb39-1135"><a href="#cb39-1135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1136"><a href="#cb39-1136" aria-hidden="true" tabindex="-1"></a>        full_img[start_y:end_y, start_x:end_x] <span class="op">=</span> patch_rgb</span>
<span id="cb39-1137"><a href="#cb39-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1138"><a href="#cb39-1138" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mask selected patches</span></span>
<span id="cb39-1139"><a href="#cb39-1139" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> mask_indices:</span>
<span id="cb39-1140"><a href="#cb39-1140" aria-hidden="true" tabindex="-1"></a>            masked_img[start_y:end_y, start_x:end_x] <span class="op">=</span> patch_rgb</span>
<span id="cb39-1141"><a href="#cb39-1141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1142"><a href="#cb39-1142" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize MAE process</span></span>
<span id="cb39-1143"><a href="#cb39-1143" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">5</span>))</span>
<span id="cb39-1144"><a href="#cb39-1144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1145"><a href="#cb39-1145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Original image</span></span>
<span id="cb39-1146"><a href="#cb39-1146" aria-hidden="true" tabindex="-1"></a>    ax1.imshow(full_img)</span>
<span id="cb39-1147"><a href="#cb39-1147" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">'Original Image'</span>)</span>
<span id="cb39-1148"><a href="#cb39-1148" aria-hidden="true" tabindex="-1"></a>    ax1.set_xticks([])</span>
<span id="cb39-1149"><a href="#cb39-1149" aria-hidden="true" tabindex="-1"></a>    ax1.set_yticks([])</span>
<span id="cb39-1150"><a href="#cb39-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1151"><a href="#cb39-1151" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Masked image (input to encoder)</span></span>
<span id="cb39-1152"><a href="#cb39-1152" aria-hidden="true" tabindex="-1"></a>    ax2.imshow(masked_img)</span>
<span id="cb39-1153"><a href="#cb39-1153" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="ss">f'Masked Input</span><span class="ch">\n</span><span class="ss">(</span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>mask_ratio)<span class="sc">:.0f}</span><span class="ss">% visible)'</span>)</span>
<span id="cb39-1154"><a href="#cb39-1154" aria-hidden="true" tabindex="-1"></a>    ax2.set_xticks([])</span>
<span id="cb39-1155"><a href="#cb39-1155" aria-hidden="true" tabindex="-1"></a>    ax2.set_yticks([])</span>
<span id="cb39-1156"><a href="#cb39-1156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1157"><a href="#cb39-1157" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Highlight masked regions</span></span>
<span id="cb39-1158"><a href="#cb39-1158" aria-hidden="true" tabindex="-1"></a>    reconstruction_img <span class="op">=</span> full_img.copy()</span>
<span id="cb39-1159"><a href="#cb39-1159" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_patches):</span>
<span id="cb39-1160"><a href="#cb39-1160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> mask_indices:</span>
<span id="cb39-1161"><a href="#cb39-1161" aria-hidden="true" tabindex="-1"></a>            row <span class="op">=</span> i <span class="op">//</span> grid_size</span>
<span id="cb39-1162"><a href="#cb39-1162" aria-hidden="true" tabindex="-1"></a>            col <span class="op">=</span> i <span class="op">%</span> grid_size</span>
<span id="cb39-1163"><a href="#cb39-1163" aria-hidden="true" tabindex="-1"></a>            start_y <span class="op">=</span> row <span class="op">*</span> patch_size</span>
<span id="cb39-1164"><a href="#cb39-1164" aria-hidden="true" tabindex="-1"></a>            end_y <span class="op">=</span> start_y <span class="op">+</span> patch_size</span>
<span id="cb39-1165"><a href="#cb39-1165" aria-hidden="true" tabindex="-1"></a>            start_x <span class="op">=</span> col <span class="op">*</span> patch_size</span>
<span id="cb39-1166"><a href="#cb39-1166" aria-hidden="true" tabindex="-1"></a>            end_x <span class="op">=</span> start_x <span class="op">+</span> patch_size</span>
<span id="cb39-1167"><a href="#cb39-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1168"><a href="#cb39-1168" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add red tint to show what needs reconstruction</span></span>
<span id="cb39-1169"><a href="#cb39-1169" aria-hidden="true" tabindex="-1"></a>            reconstruction_img[start_y:end_y, start_x:end_x, <span class="dv">0</span>] <span class="op">=</span> np.minimum(</span>
<span id="cb39-1170"><a href="#cb39-1170" aria-hidden="true" tabindex="-1"></a>                reconstruction_img[start_y:end_y, start_x:end_x, <span class="dv">0</span>] <span class="op">+</span> <span class="fl">0.3</span>, <span class="fl">1.0</span>)</span>
<span id="cb39-1171"><a href="#cb39-1171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1172"><a href="#cb39-1172" aria-hidden="true" tabindex="-1"></a>    ax3.imshow(reconstruction_img)</span>
<span id="cb39-1173"><a href="#cb39-1173" aria-hidden="true" tabindex="-1"></a>    ax3.set_title(<span class="st">'Reconstruction Target</span><span class="ch">\n</span><span class="st">(Red = masked patches)'</span>)</span>
<span id="cb39-1174"><a href="#cb39-1174" aria-hidden="true" tabindex="-1"></a>    ax3.set_xticks([])</span>
<span id="cb39-1175"><a href="#cb39-1175" aria-hidden="true" tabindex="-1"></a>    ax3.set_yticks([])</span>
<span id="cb39-1176"><a href="#cb39-1176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1177"><a href="#cb39-1177" aria-hidden="true" tabindex="-1"></a>    plt.suptitle(<span class="st">'Masked Autoencoder Training Process'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb39-1178"><a href="#cb39-1178" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-1179"><a href="#cb39-1179" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-1180"><a href="#cb39-1180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1181"><a href="#cb39-1181" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">🎯 MAE Training Process:"</span>)</span>
<span id="cb39-1182"><a href="#cb39-1182" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   1. Randomly mask </span><span class="sc">{</span>mask_ratio<span class="sc">:.0%}</span><span class="ss"> of patches"</span>)</span>
<span id="cb39-1183"><a href="#cb39-1183" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   2. Encoder processes only visible patches"</span>)</span>
<span id="cb39-1184"><a href="#cb39-1184" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   3. Decoder reconstructs all patches"</span>)</span>
<span id="cb39-1185"><a href="#cb39-1185" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   4. Loss computed only on masked patches"</span>)</span>
<span id="cb39-1186"><a href="#cb39-1186" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"   5. Model learns spatial relationships and context"</span>)</span>
<span id="cb39-1187"><a href="#cb39-1187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1188"><a href="#cb39-1188" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mask_indices</span>
<span id="cb39-1189"><a href="#cb39-1189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1190"><a href="#cb39-1190" aria-hidden="true" tabindex="-1"></a>mask_indices <span class="op">=</span> demonstrate_mae_masking(patches)</span>
<span id="cb39-1191"><a href="#cb39-1191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1192"><a href="#cb39-1192" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">🔍 Why MAE Works for Satellite Imagery:"</span>)</span>
<span id="cb39-1193"><a href="#cb39-1193" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Forces model to understand spatial context"</span>)</span>
<span id="cb39-1194"><a href="#cb39-1194" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Learns spectral relationships between bands"</span>)  </span>
<span id="cb39-1195"><a href="#cb39-1195" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Captures seasonal and phenological patterns"</span>)</span>
<span id="cb39-1196"><a href="#cb39-1196" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Creates transferable representations"</span>)</span>
<span id="cb39-1197"><a href="#cb39-1197" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"   • Reduces need for labeled training data"</span>)</span>
<span id="cb39-1198"><a href="#cb39-1198" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-1199"><a href="#cb39-1199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1200"><a href="#cb39-1200" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-1201"><a href="#cb39-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1202"><a href="#cb39-1202" aria-hidden="true" tabindex="-1"></a><span class="fu">## Performance Optimization and Practical Considerations</span></span>
<span id="cb39-1203"><a href="#cb39-1203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1204"><a href="#cb39-1204" aria-hidden="true" tabindex="-1"></a><span class="fu">### Memory-Efficient Batch Processing</span></span>
<span id="cb39-1205"><a href="#cb39-1205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1206"><a href="#cb39-1206" aria-hidden="true" tabindex="-1"></a>When working with large satellite images, you need efficient strategies for processing patches in batches:</span>
<span id="cb39-1207"><a href="#cb39-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1210"><a href="#cb39-1210" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-1211"><a href="#cb39-1211" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> demonstrate_efficient_processing():</span>
<span id="cb39-1212"><a href="#cb39-1212" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-1213"><a href="#cb39-1213" aria-hidden="true" tabindex="-1"></a><span class="co">    Show memory-efficient strategies for processing large numbers of patches.</span></span>
<span id="cb39-1214"><a href="#cb39-1214" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-1215"><a href="#cb39-1215" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1216"><a href="#cb39-1216" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate a large satellite image</span></span>
<span id="cb39-1217"><a href="#cb39-1217" aria-hidden="true" tabindex="-1"></a>    large_img_shape <span class="op">=</span> (<span class="dv">2000</span>, <span class="dv">3000</span>, <span class="dv">6</span>)  <span class="co"># Realistic size</span></span>
<span id="cb39-1218"><a href="#cb39-1218" aria-hidden="true" tabindex="-1"></a>    patch_size <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb39-1219"><a href="#cb39-1219" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1220"><a href="#cb39-1220" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate patch requirements</span></span>
<span id="cb39-1221"><a href="#cb39-1221" aria-hidden="true" tabindex="-1"></a>    patches_y <span class="op">=</span> large_img_shape[<span class="dv">0</span>] <span class="op">//</span> patch_size</span>
<span id="cb39-1222"><a href="#cb39-1222" aria-hidden="true" tabindex="-1"></a>    patches_x <span class="op">=</span> large_img_shape[<span class="dv">1</span>] <span class="op">//</span> patch_size  </span>
<span id="cb39-1223"><a href="#cb39-1223" aria-hidden="true" tabindex="-1"></a>    total_patches <span class="op">=</span> patches_y <span class="op">*</span> patches_x</span>
<span id="cb39-1224"><a href="#cb39-1224" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1225"><a href="#cb39-1225" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Memory calculations</span></span>
<span id="cb39-1226"><a href="#cb39-1226" aria-hidden="true" tabindex="-1"></a>    patch_memory_bytes <span class="op">=</span> patch_size <span class="op">*</span> patch_size <span class="op">*</span> large_img_shape[<span class="dv">2</span>] <span class="op">*</span> <span class="dv">4</span>  <span class="co"># float32</span></span>
<span id="cb39-1227"><a href="#cb39-1227" aria-hidden="true" tabindex="-1"></a>    total_patch_memory_gb <span class="op">=</span> (total_patches <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb39-1228"><a href="#cb39-1228" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1229"><a href="#cb39-1229" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Large-Scale Processing Analysis"</span>)</span>
<span id="cb39-1230"><a href="#cb39-1230" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-1231"><a href="#cb39-1231" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Image size: </span><span class="sc">{</span>large_img_shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>large_img_shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>large_img_shape[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1232"><a href="#cb39-1232" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch size: </span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>patch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1233"><a href="#cb39-1233" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patches: </span><span class="sc">{</span>total_patches<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb39-1234"><a href="#cb39-1234" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Memory per patch: </span><span class="sc">{</span>patch_memory_bytes<span class="op">/</span><span class="dv">1024</span><span class="sc">:.1f}</span><span class="ss"> KB"</span>)</span>
<span id="cb39-1235"><a href="#cb39-1235" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Total patch memory: </span><span class="sc">{</span>total_patch_memory_gb<span class="sc">:.2f}</span><span class="ss"> GB"</span>)</span>
<span id="cb39-1236"><a href="#cb39-1236" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1237"><a href="#cb39-1237" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Batch processing scenarios</span></span>
<span id="cb39-1238"><a href="#cb39-1238" aria-hidden="true" tabindex="-1"></a>    gpu_memory_gb <span class="op">=</span> <span class="dv">16</span>  <span class="co"># Typical GPU</span></span>
<span id="cb39-1239"><a href="#cb39-1239" aria-hidden="true" tabindex="-1"></a>    model_memory_gb <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Reserve for model weights</span></span>
<span id="cb39-1240"><a href="#cb39-1240" aria-hidden="true" tabindex="-1"></a>    available_memory_gb <span class="op">=</span> gpu_memory_gb <span class="op">-</span> model_memory_gb</span>
<span id="cb39-1241"><a href="#cb39-1241" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1242"><a href="#cb39-1242" aria-hidden="true" tabindex="-1"></a>    max_patches_per_batch <span class="op">=</span> <span class="bu">int</span>((available_memory_gb <span class="op">*</span> <span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>) <span class="op">/</span> patch_memory_bytes)</span>
<span id="cb39-1243"><a href="#cb39-1243" aria-hidden="true" tabindex="-1"></a>    n_batches <span class="op">=</span> (total_patches <span class="op">+</span> max_patches_per_batch <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> max_patches_per_batch</span>
<span id="cb39-1244"><a href="#cb39-1244" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1245"><a href="#cb39-1245" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Batch Processing Strategy:"</span>)</span>
<span id="cb39-1246"><a href="#cb39-1246" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  GPU memory: </span><span class="sc">{</span>gpu_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>)</span>
<span id="cb39-1247"><a href="#cb39-1247" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Model memory: </span><span class="sc">{</span>model_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>) </span>
<span id="cb39-1248"><a href="#cb39-1248" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Available: </span><span class="sc">{</span>available_memory_gb<span class="sc">}</span><span class="ss"> GB"</span>)</span>
<span id="cb39-1249"><a href="#cb39-1249" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Max patches/batch: </span><span class="sc">{</span>max_patches_per_batch<span class="sc">:,}</span><span class="ss">"</span>)</span>
<span id="cb39-1250"><a href="#cb39-1250" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Batches needed: </span><span class="sc">{</span>n_batches<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1251"><a href="#cb39-1251" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1252"><a href="#cb39-1252" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show different batch size trade-offs</span></span>
<span id="cb39-1253"><a href="#cb39-1253" aria-hidden="true" tabindex="-1"></a>    batch_sizes <span class="op">=</span> [<span class="dv">64</span>, <span class="dv">128</span>, <span class="dv">256</span>, <span class="dv">512</span>, <span class="dv">1024</span>]</span>
<span id="cb39-1254"><a href="#cb39-1254" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1255"><a href="#cb39-1255" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Batch Size Trade-offs:"</span>)</span>
<span id="cb39-1256"><a href="#cb39-1256" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'Batch Size'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Batches'</span><span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Memory (GB)'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Efficiency'</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1257"><a href="#cb39-1257" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"-"</span><span class="op">*</span><span class="dv">50</span>)</span>
<span id="cb39-1258"><a href="#cb39-1258" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1259"><a href="#cb39-1259" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> batch_size <span class="kw">in</span> batch_sizes:</span>
<span id="cb39-1260"><a href="#cb39-1260" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> batch_size <span class="op">&lt;=</span> max_patches_per_batch:</span>
<span id="cb39-1261"><a href="#cb39-1261" aria-hidden="true" tabindex="-1"></a>            n_batches <span class="op">=</span> (total_patches <span class="op">+</span> batch_size <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> batch_size</span>
<span id="cb39-1262"><a href="#cb39-1262" aria-hidden="true" tabindex="-1"></a>            memory_gb <span class="op">=</span> (batch_size <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb39-1263"><a href="#cb39-1263" aria-hidden="true" tabindex="-1"></a>            efficiency <span class="op">=</span> <span class="st">"Optimal"</span> <span class="cf">if</span> batch_size <span class="op">==</span> max_patches_per_batch <span class="cf">else</span> <span class="st">"Good"</span></span>
<span id="cb39-1264"><a href="#cb39-1264" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb39-1265"><a href="#cb39-1265" aria-hidden="true" tabindex="-1"></a>            n_batches <span class="op">=</span> <span class="st">"OOM"</span>  <span class="co"># Out of memory</span></span>
<span id="cb39-1266"><a href="#cb39-1266" aria-hidden="true" tabindex="-1"></a>            memory_gb <span class="op">=</span> (batch_size <span class="op">*</span> patch_memory_bytes) <span class="op">/</span> (<span class="dv">1024</span><span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb39-1267"><a href="#cb39-1267" aria-hidden="true" tabindex="-1"></a>            efficiency <span class="op">=</span> <span class="st">"Too large"</span></span>
<span id="cb39-1268"><a href="#cb39-1268" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1269"><a href="#cb39-1269" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>batch_size<span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span>n_batches<span class="sc">:&lt;8}</span><span class="ss"> </span><span class="sc">{</span>memory_gb<span class="sc">:&lt;12.2f}</span><span class="ss"> </span><span class="sc">{</span>efficiency<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1270"><a href="#cb39-1270" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1271"><a href="#cb39-1271" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_patches_per_batch</span>
<span id="cb39-1272"><a href="#cb39-1272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1273"><a href="#cb39-1273" aria-hidden="true" tabindex="-1"></a>optimal_batch_size <span class="op">=</span> demonstrate_efficient_processing()</span>
<span id="cb39-1274"><a href="#cb39-1274" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-1275"><a href="#cb39-1275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1276"><a href="#cb39-1276" aria-hidden="true" tabindex="-1"></a><span class="fu">### Real-World Pipeline Implementation</span></span>
<span id="cb39-1277"><a href="#cb39-1277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1278"><a href="#cb39-1278" aria-hidden="true" tabindex="-1"></a>Let's put it all together with a realistic implementation that you might use in practice:</span>
<span id="cb39-1279"><a href="#cb39-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1282"><a href="#cb39-1282" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb39-1283"><a href="#cb39-1283" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_production_pipeline():</span>
<span id="cb39-1284"><a href="#cb39-1284" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb39-1285"><a href="#cb39-1285" aria-hidden="true" tabindex="-1"></a><span class="co">    Demonstrate a production-ready patch extraction pipeline</span></span>
<span id="cb39-1286"><a href="#cb39-1286" aria-hidden="true" tabindex="-1"></a><span class="co">    with all the considerations we've discussed.</span></span>
<span id="cb39-1287"><a href="#cb39-1287" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb39-1288"><a href="#cb39-1288" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1289"><a href="#cb39-1289" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> SatelliteImageProcessor:</span>
<span id="cb39-1290"><a href="#cb39-1290" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, patch_size<span class="op">=</span><span class="dv">32</span>, stride<span class="op">=</span><span class="va">None</span>, padding<span class="op">=</span><span class="st">'reflect'</span>, </span>
<span id="cb39-1291"><a href="#cb39-1291" aria-hidden="true" tabindex="-1"></a>                     batch_size<span class="op">=</span><span class="dv">256</span>, overlap_threshold<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb39-1292"><a href="#cb39-1292" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.patch_size <span class="op">=</span> patch_size</span>
<span id="cb39-1293"><a href="#cb39-1293" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.stride <span class="op">=</span> stride <span class="cf">if</span> stride <span class="cf">else</span> patch_size</span>
<span id="cb39-1294"><a href="#cb39-1294" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.padding <span class="op">=</span> padding</span>
<span id="cb39-1295"><a href="#cb39-1295" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.batch_size <span class="op">=</span> batch_size</span>
<span id="cb39-1296"><a href="#cb39-1296" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.overlap_threshold <span class="op">=</span> overlap_threshold</span>
<span id="cb39-1297"><a href="#cb39-1297" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1298"><a href="#cb39-1298" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> extract_patches(<span class="va">self</span>, image):</span>
<span id="cb39-1299"><a href="#cb39-1299" aria-hidden="true" tabindex="-1"></a>            <span class="co">"""Extract patches with specified strategy."""</span></span>
<span id="cb39-1300"><a href="#cb39-1300" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1301"><a href="#cb39-1301" aria-hidden="true" tabindex="-1"></a>            H, W, C <span class="op">=</span> image.shape</span>
<span id="cb39-1302"><a href="#cb39-1302" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1303"><a href="#cb39-1303" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Apply padding if needed</span></span>
<span id="cb39-1304"><a href="#cb39-1304" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.padding <span class="op">==</span> <span class="st">'reflect'</span>:</span>
<span id="cb39-1305"><a href="#cb39-1305" aria-hidden="true" tabindex="-1"></a>                pad_h <span class="op">=</span> <span class="va">self</span>.patch_size <span class="op">-</span> (H <span class="op">%</span> <span class="va">self</span>.patch_size) <span class="cf">if</span> H <span class="op">%</span> <span class="va">self</span>.patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-1306"><a href="#cb39-1306" aria-hidden="true" tabindex="-1"></a>                pad_w <span class="op">=</span> <span class="va">self</span>.patch_size <span class="op">-</span> (W <span class="op">%</span> <span class="va">self</span>.patch_size) <span class="cf">if</span> W <span class="op">%</span> <span class="va">self</span>.patch_size <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb39-1307"><a href="#cb39-1307" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> pad_h <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">or</span> pad_w <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb39-1308"><a href="#cb39-1308" aria-hidden="true" tabindex="-1"></a>                    image <span class="op">=</span> np.pad(image, ((<span class="dv">0</span>, pad_h), (<span class="dv">0</span>, pad_w), (<span class="dv">0</span>, <span class="dv">0</span>)), mode<span class="op">=</span><span class="st">'reflect'</span>)</span>
<span id="cb39-1309"><a href="#cb39-1309" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="va">self</span>.padding <span class="op">==</span> <span class="st">'crop'</span>:</span>
<span id="cb39-1310"><a href="#cb39-1310" aria-hidden="true" tabindex="-1"></a>                crop_h <span class="op">=</span> (H <span class="op">//</span> <span class="va">self</span>.patch_size) <span class="op">*</span> <span class="va">self</span>.patch_size</span>
<span id="cb39-1311"><a href="#cb39-1311" aria-hidden="true" tabindex="-1"></a>                crop_w <span class="op">=</span> (W <span class="op">//</span> <span class="va">self</span>.patch_size) <span class="op">*</span> <span class="va">self</span>.patch_size</span>
<span id="cb39-1312"><a href="#cb39-1312" aria-hidden="true" tabindex="-1"></a>                image <span class="op">=</span> image[:crop_h, :crop_w, :]</span>
<span id="cb39-1313"><a href="#cb39-1313" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1314"><a href="#cb39-1314" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Extract patches</span></span>
<span id="cb39-1315"><a href="#cb39-1315" aria-hidden="true" tabindex="-1"></a>            patches <span class="op">=</span> []</span>
<span id="cb39-1316"><a href="#cb39-1316" aria-hidden="true" tabindex="-1"></a>            positions <span class="op">=</span> []</span>
<span id="cb39-1317"><a href="#cb39-1317" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1318"><a href="#cb39-1318" aria-hidden="true" tabindex="-1"></a>            H_new, W_new <span class="op">=</span> image.shape[:<span class="dv">2</span>]</span>
<span id="cb39-1319"><a href="#cb39-1319" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1320"><a href="#cb39-1320" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, H_new <span class="op">-</span> <span class="va">self</span>.patch_size <span class="op">+</span> <span class="dv">1</span>, <span class="va">self</span>.stride):</span>
<span id="cb39-1321"><a href="#cb39-1321" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, W_new <span class="op">-</span> <span class="va">self</span>.patch_size <span class="op">+</span> <span class="dv">1</span>, <span class="va">self</span>.stride):</span>
<span id="cb39-1322"><a href="#cb39-1322" aria-hidden="true" tabindex="-1"></a>                    patch <span class="op">=</span> image[y:y<span class="op">+</span><span class="va">self</span>.patch_size, x:x<span class="op">+</span><span class="va">self</span>.patch_size, :]</span>
<span id="cb39-1323"><a href="#cb39-1323" aria-hidden="true" tabindex="-1"></a>                    patches.append(patch)</span>
<span id="cb39-1324"><a href="#cb39-1324" aria-hidden="true" tabindex="-1"></a>                    positions.append((x, y))</span>
<span id="cb39-1325"><a href="#cb39-1325" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1326"><a href="#cb39-1326" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.array(patches), positions, image.shape</span>
<span id="cb39-1327"><a href="#cb39-1327" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb39-1328"><a href="#cb39-1328" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> process_in_batches(<span class="va">self</span>, patches, processing_func):</span>
<span id="cb39-1329"><a href="#cb39-1329" aria-hidden="true" tabindex="-1"></a>            <span class="co">"""Process patches in memory-efficient batches."""</span></span>
<span id="cb39-1330"><a href="#cb39-1330" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1331"><a href="#cb39-1331" aria-hidden="true" tabindex="-1"></a>            results <span class="op">=</span> []</span>
<span id="cb39-1332"><a href="#cb39-1332" aria-hidden="true" tabindex="-1"></a>            n_patches <span class="op">=</span> <span class="bu">len</span>(patches)</span>
<span id="cb39-1333"><a href="#cb39-1333" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1334"><a href="#cb39-1334" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_patches, <span class="va">self</span>.batch_size):</span>
<span id="cb39-1335"><a href="#cb39-1335" aria-hidden="true" tabindex="-1"></a>                batch_end <span class="op">=</span> <span class="bu">min</span>(i <span class="op">+</span> <span class="va">self</span>.batch_size, n_patches)</span>
<span id="cb39-1336"><a href="#cb39-1336" aria-hidden="true" tabindex="-1"></a>                batch <span class="op">=</span> patches[i:batch_end]</span>
<span id="cb39-1337"><a href="#cb39-1337" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb39-1338"><a href="#cb39-1338" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Simulate processing (could be model inference)</span></span>
<span id="cb39-1339"><a href="#cb39-1339" aria-hidden="true" tabindex="-1"></a>                batch_results <span class="op">=</span> processing_func(batch)</span>
<span id="cb39-1340"><a href="#cb39-1340" aria-hidden="true" tabindex="-1"></a>                results.extend(batch_results)</span>
<span id="cb39-1341"><a href="#cb39-1341" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb39-1342"><a href="#cb39-1342" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"Processed batch </span><span class="sc">{</span>i<span class="op">//</span><span class="va">self</span><span class="sc">.</span>batch_size <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>(n_patches <span class="op">+</span> <span class="va">self</span>.batch_size <span class="op">-</span> <span class="dv">1</span>)<span class="op">//</span><span class="va">self</span><span class="sc">.</span>batch_size<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1343"><a href="#cb39-1343" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb39-1344"><a href="#cb39-1344" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> results</span>
<span id="cb39-1345"><a href="#cb39-1345" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1346"><a href="#cb39-1346" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Demonstrate the pipeline</span></span>
<span id="cb39-1347"><a href="#cb39-1347" aria-hidden="true" tabindex="-1"></a>    processor <span class="op">=</span> SatelliteImageProcessor(</span>
<span id="cb39-1348"><a href="#cb39-1348" aria-hidden="true" tabindex="-1"></a>        patch_size<span class="op">=</span><span class="dv">32</span>,</span>
<span id="cb39-1349"><a href="#cb39-1349" aria-hidden="true" tabindex="-1"></a>        stride<span class="op">=</span><span class="dv">24</span>,  <span class="co"># 25% overlap</span></span>
<span id="cb39-1350"><a href="#cb39-1350" aria-hidden="true" tabindex="-1"></a>        padding<span class="op">=</span><span class="st">'reflect'</span>,</span>
<span id="cb39-1351"><a href="#cb39-1351" aria-hidden="true" tabindex="-1"></a>        batch_size<span class="op">=</span><span class="dv">64</span></span>
<span id="cb39-1352"><a href="#cb39-1352" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb39-1353"><a href="#cb39-1353" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1354"><a href="#cb39-1354" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Production Pipeline Demonstration"</span>)</span>
<span id="cb39-1355"><a href="#cb39-1355" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">40</span>)</span>
<span id="cb39-1356"><a href="#cb39-1356" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1357"><a href="#cb39-1357" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract patches</span></span>
<span id="cb39-1358"><a href="#cb39-1358" aria-hidden="true" tabindex="-1"></a>    patches, positions, processed_shape <span class="op">=</span> processor.extract_patches(satellite_img)</span>
<span id="cb39-1359"><a href="#cb39-1359" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1360"><a href="#cb39-1360" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Input image: </span><span class="sc">{</span>satellite_img<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1361"><a href="#cb39-1361" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Processed image: </span><span class="sc">{</span>processed_shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1362"><a href="#cb39-1362" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patches extracted: </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1363"><a href="#cb39-1363" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Patch overlap: </span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>(processor.patch_size <span class="op">-</span> processor.stride)<span class="op">/</span>processor<span class="sc">.</span>patch_size<span class="sc">:.0f}</span><span class="ss">%"</span>)</span>
<span id="cb39-1364"><a href="#cb39-1364" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1365"><a href="#cb39-1365" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simulate processing function (could be model inference)</span></span>
<span id="cb39-1366"><a href="#cb39-1366" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mock_processing(batch):</span>
<span id="cb39-1367"><a href="#cb39-1367" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Simulate model inference or feature extraction."""</span></span>
<span id="cb39-1368"><a href="#cb39-1368" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return mean spectral values per patch as example</span></span>
<span id="cb39-1369"><a href="#cb39-1369" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [np.mean(patch, axis<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>)) <span class="cf">for</span> patch <span class="kw">in</span> batch]</span>
<span id="cb39-1370"><a href="#cb39-1370" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1371"><a href="#cb39-1371" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process in batches</span></span>
<span id="cb39-1372"><a href="#cb39-1372" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Processing </span><span class="sc">{</span><span class="bu">len</span>(patches)<span class="sc">}</span><span class="ss"> patches in batches of </span><span class="sc">{</span>processor<span class="sc">.</span>batch_size<span class="sc">}</span><span class="ss">..."</span>)</span>
<span id="cb39-1373"><a href="#cb39-1373" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> processor.process_in_batches(patches, mock_processing)</span>
<span id="cb39-1374"><a href="#cb39-1374" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1375"><a href="#cb39-1375" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Processing complete!"</span>)</span>
<span id="cb39-1376"><a href="#cb39-1376" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Results shape: </span><span class="sc">{</span>np<span class="sc">.</span>array(results)<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb39-1377"><a href="#cb39-1377" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1378"><a href="#cb39-1378" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Visualize results (spectral signatures)</span></span>
<span id="cb39-1379"><a href="#cb39-1379" aria-hidden="true" tabindex="-1"></a>    results_array <span class="op">=</span> np.array(results)</span>
<span id="cb39-1380"><a href="#cb39-1380" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1381"><a href="#cb39-1381" aria-hidden="true" tabindex="-1"></a>    fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb39-1382"><a href="#cb39-1382" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1383"><a href="#cb39-1383" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show patch locations colored by first spectral band average</span></span>
<span id="cb39-1384"><a href="#cb39-1384" aria-hidden="true" tabindex="-1"></a>    x_coords <span class="op">=</span> [pos[<span class="dv">0</span>] <span class="op">+</span> processor.patch_size<span class="op">//</span><span class="dv">2</span> <span class="cf">for</span> pos <span class="kw">in</span> positions]</span>
<span id="cb39-1385"><a href="#cb39-1385" aria-hidden="true" tabindex="-1"></a>    y_coords <span class="op">=</span> [pos[<span class="dv">1</span>] <span class="op">+</span> processor.patch_size<span class="op">//</span><span class="dv">2</span> <span class="cf">for</span> pos <span class="kw">in</span> positions]</span>
<span id="cb39-1386"><a href="#cb39-1386" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1387"><a href="#cb39-1387" aria-hidden="true" tabindex="-1"></a>    scatter <span class="op">=</span> ax1.scatter(x_coords, y_coords, c<span class="op">=</span>results_array[:, <span class="dv">0</span>], </span>
<span id="cb39-1388"><a href="#cb39-1388" aria-hidden="true" tabindex="-1"></a>                         cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">50</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb39-1389"><a href="#cb39-1389" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlim(<span class="dv">0</span>, satellite_img.shape[<span class="dv">1</span>])</span>
<span id="cb39-1390"><a href="#cb39-1390" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylim(satellite_img.shape[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb39-1391"><a href="#cb39-1391" aria-hidden="true" tabindex="-1"></a>    ax1.set_title(<span class="st">'Patch Results (Red Band Average)'</span>)</span>
<span id="cb39-1392"><a href="#cb39-1392" aria-hidden="true" tabindex="-1"></a>    ax1.set_xlabel(<span class="st">'X Coordinate'</span>)</span>
<span id="cb39-1393"><a href="#cb39-1393" aria-hidden="true" tabindex="-1"></a>    ax1.set_ylabel(<span class="st">'Y Coordinate'</span>)</span>
<span id="cb39-1394"><a href="#cb39-1394" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(scatter, ax<span class="op">=</span>ax1)</span>
<span id="cb39-1395"><a href="#cb39-1395" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1396"><a href="#cb39-1396" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Show spectral signatures distribution</span></span>
<span id="cb39-1397"><a href="#cb39-1397" aria-hidden="true" tabindex="-1"></a>    band_names <span class="op">=</span> [<span class="st">'Red'</span>, <span class="st">'Green'</span>, <span class="st">'Blue'</span>, <span class="st">'NIR'</span>]</span>
<span id="cb39-1398"><a href="#cb39-1398" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(band_names):</span>
<span id="cb39-1399"><a href="#cb39-1399" aria-hidden="true" tabindex="-1"></a>        ax2.hist(results_array[:, i], bins<span class="op">=</span><span class="dv">20</span>, alpha<span class="op">=</span><span class="fl">0.6</span>, label<span class="op">=</span>band)</span>
<span id="cb39-1400"><a href="#cb39-1400" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1401"><a href="#cb39-1401" aria-hidden="true" tabindex="-1"></a>    ax2.set_xlabel(<span class="st">'Average Band Value'</span>)</span>
<span id="cb39-1402"><a href="#cb39-1402" aria-hidden="true" tabindex="-1"></a>    ax2.set_ylabel(<span class="st">'Frequency'</span>)  </span>
<span id="cb39-1403"><a href="#cb39-1403" aria-hidden="true" tabindex="-1"></a>    ax2.set_title(<span class="st">'Distribution of Spectral Values Across Patches'</span>)</span>
<span id="cb39-1404"><a href="#cb39-1404" aria-hidden="true" tabindex="-1"></a>    ax2.legend()</span>
<span id="cb39-1405"><a href="#cb39-1405" aria-hidden="true" tabindex="-1"></a>    ax2.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb39-1406"><a href="#cb39-1406" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1407"><a href="#cb39-1407" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb39-1408"><a href="#cb39-1408" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb39-1409"><a href="#cb39-1409" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-1410"><a href="#cb39-1410" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> processor, results</span>
<span id="cb39-1411"><a href="#cb39-1411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1412"><a href="#cb39-1412" aria-hidden="true" tabindex="-1"></a>pipeline, processing_results <span class="op">=</span> create_production_pipeline()</span>
<span id="cb39-1413"><a href="#cb39-1413" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb39-1414"><a href="#cb39-1414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1415"><a href="#cb39-1415" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-1416"><a href="#cb39-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1417"><a href="#cb39-1417" aria-hidden="true" tabindex="-1"></a><span class="fu">## Key Takeaways and Best Practices</span></span>
<span id="cb39-1418"><a href="#cb39-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1419"><a href="#cb39-1419" aria-hidden="true" tabindex="-1"></a>After working through these examples, here are the essential principles for effective patch extraction in geospatial foundation models:</span>
<span id="cb39-1420"><a href="#cb39-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1421"><a href="#cb39-1421" aria-hidden="true" tabindex="-1"></a><span class="fu">### 1. **Understand Your Memory Constraints**</span></span>
<span id="cb39-1422"><a href="#cb39-1422" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Calculate patch memory requirements before processing</span>
<span id="cb39-1423"><a href="#cb39-1423" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use batch processing for large images  </span>
<span id="cb39-1424"><a href="#cb39-1424" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Consider GPU memory limitations in your pipeline design</span>
<span id="cb39-1425"><a href="#cb39-1425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1426"><a href="#cb39-1426" aria-hidden="true" tabindex="-1"></a><span class="fu">### 2. **Choose Patch Size Strategically**</span></span>
<span id="cb39-1427"><a href="#cb39-1427" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Small patches (8-16px)**: Capture fine details, more patches, higher memory</span>
<span id="cb39-1428"><a href="#cb39-1428" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Medium patches (32-64px)**: Balance detail and context, most common choice</span>
<span id="cb39-1429"><a href="#cb39-1429" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Large patches (128px+)**: Capture broad context, fewer patches, less memory</span>
<span id="cb39-1430"><a href="#cb39-1430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1431"><a href="#cb39-1431" aria-hidden="true" tabindex="-1"></a><span class="fu">### 3. **Select Padding Strategy Based on Your Use Case**</span></span>
<span id="cb39-1432"><a href="#cb39-1432" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Crop**: Speed-critical applications, overlapping patches</span>
<span id="cb39-1433"><a href="#cb39-1433" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Zero padding**: Complete coverage required, simple implementation</span>
<span id="cb39-1434"><a href="#cb39-1434" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Reflect padding**: Image quality critical, natural imagery</span>
<span id="cb39-1435"><a href="#cb39-1435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1436"><a href="#cb39-1436" aria-hidden="true" tabindex="-1"></a><span class="fu">### 4. **Consider Overlap for Better Performance**</span></span>
<span id="cb39-1437"><a href="#cb39-1437" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**No overlap**: Fastest processing, good for classification</span>
<span id="cb39-1438"><a href="#cb39-1438" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**25-50% overlap**: Better boundary handling, moderate cost increase</span>
<span id="cb39-1439"><a href="#cb39-1439" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**75%+ overlap**: Maximum context, highest computational cost</span>
<span id="cb39-1440"><a href="#cb39-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1441"><a href="#cb39-1441" aria-hidden="true" tabindex="-1"></a><span class="fu">### 5. **Plan for Multi-Scale and Multi-Temporal Processing**</span></span>
<span id="cb39-1442"><a href="#cb39-1442" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Design pipelines that can handle different patch sizes</span>
<span id="cb39-1443"><a href="#cb39-1443" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Ensure spatial alignment across time series</span>
<span id="cb39-1444"><a href="#cb39-1444" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Consider temporal consistency in patch extraction</span>
<span id="cb39-1445"><a href="#cb39-1445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1446"><a href="#cb39-1446" aria-hidden="true" tabindex="-1"></a><span class="fu">### 6. **Optimize for Your Specific GFM Architecture**</span></span>
<span id="cb39-1447"><a href="#cb39-1447" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Match patch sizes to your model's training configuration</span>
<span id="cb39-1448"><a href="#cb39-1448" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Consider spectral band requirements</span>
<span id="cb39-1449"><a href="#cb39-1449" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Plan for masked autoencoder training if applicable</span>
<span id="cb39-1450"><a href="#cb39-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1451"><a href="#cb39-1451" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb39-1452"><a href="#cb39-1452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1453"><a href="#cb39-1453" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb39-1454"><a href="#cb39-1454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1455"><a href="#cb39-1455" aria-hidden="true" tabindex="-1"></a>Patch extraction is far more than a simple preprocessing step—it's a critical design choice that affects every aspect of your geospatial AI pipeline. The strategies we've explored provide a foundation for making informed decisions about:</span>
<span id="cb39-1456"><a href="#cb39-1456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1457"><a href="#cb39-1457" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Memory management** and computational efficiency</span>
<span id="cb39-1458"><a href="#cb39-1458" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Information preservation** vs. processing speed trade-offs  </span>
<span id="cb39-1459"><a href="#cb39-1459" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Spatial context** and boundary handling</span>
<span id="cb39-1460"><a href="#cb39-1460" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Multi-scale and temporal** processing requirements</span>
<span id="cb39-1461"><a href="#cb39-1461" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Model architecture** compatibility</span>
<span id="cb39-1462"><a href="#cb39-1462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1463"><a href="#cb39-1463" aria-hidden="true" tabindex="-1"></a>As you develop your own geospatial foundation models, remember that the "best" patch extraction strategy depends entirely on your specific use case, data characteristics, and computational constraints. Use these examples as starting points, but always validate your choices with your own data and requirements.</span>
<span id="cb39-1464"><a href="#cb39-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-1465"><a href="#cb39-1465" aria-hidden="true" tabindex="-1"></a>The techniques demonstrated here form the foundation for the more advanced topics we'll explore in subsequent chapters, including attention mechanisms, self-supervised learning, and model deployment at scale.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/geog-logo.png" class="img-fluid figure-img" width="250"></p>
<figcaption>Department of Geography logo</figcaption>
</figure>
</div>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <a href="https://github.com/kcaylor/GEOG-288KC-geospatial-foundation-models"><i class="fa-brands fa-github" title="the github octocat logo" aria-label="github"></i></a> and <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>